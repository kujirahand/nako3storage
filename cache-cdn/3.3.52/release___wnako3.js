/*! For license information please see wnako3.js.LICENSE.txt */
(function(){var __webpack_modules__={"./node_modules/hotkeys-js/dist/hotkeys.common.js":function(module){"use strict";eval("/**! \n * hotkeys-js v3.9.4 \n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. \n * \n * Copyright (c) 2022 kenny wong <wowohoo@qq.com> \n * http://jaywcjlove.github.io/hotkeys \n * Licensed under the MIT license \n */\n\n\n\nvar isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件\n\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function () {\n      method(window.event);\n    });\n  }\n} // 修饰键转换成对应的键码\n\n\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n\n  for (var i = 0; i < mods.length; i++) {\n    mods[i] = modifier[mods[i].toLowerCase()];\n  }\n\n  return mods;\n} // 处理传的key字符串转换成数组\n\n\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等\n\n  var keys = key.split(','); // 同时设置多个快捷键，以','分割\n\n  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理\n\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n\n  return keys;\n} // 比较修饰键的数组\n\n\nfunction compareArray(a1, a2) {\n  var arr1 = a1.length >= a2.length ? a1 : a2;\n  var arr2 = a1.length >= a2.length ? a2 : a1;\n  var isIndex = true;\n\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n\n  return isIndex;\n}\n\nvar _keyMap = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n}; // Modifier Keys\n\nvar _modifier = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {}; // F1~F12 special key\n\nfor (var k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\nvar _downKeys = []; // 记录摁下的绑定键\n\nvar winListendFocus = false; // window是否已经监听了focus事件\n\nvar _scope = 'all'; // 默认热键范围\n\nvar elementHasBindEvent = []; // 已绑定事件的节点记录\n// 返回键码\n\nvar code = function code(x) {\n  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\n}; // 设置获取当前范围（默认为'所有'）\n\n\nfunction setScope(scope) {\n  _scope = scope || 'all';\n} // 获取当前范围\n\n\nfunction getScope() {\n  return _scope || 'all';\n} // 获取摁下绑定键的键值\n\n\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n} // 表单控件控件判断 返回 Boolean\n// hotkey is effective only when filter return true\n\n\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n\n  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n\n  return flag;\n} // 判断摁下的键是否为某个键，返回true或者false\n\n\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // 转换成键码\n  }\n\n  return _downKeys.indexOf(keyCode) !== -1;\n} // 循环删除handlers中的所有 scope(范围)\n\n\nfunction deleteScope(scope, newScope) {\n  var handlers;\n  var i; // 没有指定scope，获取scope\n\n  if (!scope) scope = getScope();\n\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;\n      }\n    }\n  } // 如果scope被删除，将scope重置为all\n\n\n  if (getScope() === scope) setScope(newScope || 'all');\n} // 清除修饰键\n\n\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n\n  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键\n\n\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题\n\n\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除\n\n\n  if (key === 93 || key === 224) key = 91;\n\n  if (key in _mods) {\n    _mods[key] = false; // 将修饰键重置为false\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = false;\n    }\n  }\n}\n\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (typeof keysInfo === 'undefined') {\n    Object.keys(_handlers).forEach(function (key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(function (info) {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // support old method\n    // eslint-disable-line\n    var scope = args[0],\n        method = args[1];\n\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n\n    eachUnbind({\n      key: keysInfo,\n      scope: scope,\n      method: method,\n      splitKey: '+'\n    });\n  }\n} // 解除绑定某个范围的快捷键\n\n\nvar eachUnbind = function eachUnbind(_ref) {\n  var key = _ref.key,\n      scope = _ref.scope,\n      method = _ref.method,\n      _ref$splitKey = _ref.splitKey,\n      splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function (originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围\n\n    if (!scope) scope = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].filter(function (record) {\n      // 通过函数判断，是否解除绑定，函数相等直接返回\n      var isMatchingMethod = method ? record.method === method : true;\n      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));\n    });\n  });\n}; // 对监听对应快捷键的回调函数进行处理\n\n\nfunction eventHandler(event, handler, scope, element) {\n  if (handler.element !== element) {\n    return;\n  }\n\n  var modifiersMatch; // 看它是否在当前范围\n\n  if (handler.scope === scope || handler.scope === 'all') {\n    // 检查是否匹配修饰符（如果有返回true）\n    modifiersMatch = handler.mods.length > 0;\n\n    for (var y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    } // 调用处理程序，如果是修饰键不做处理\n\n\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n} // 处理keydown事件\n\n\nfunction dispatch(event, element) {\n  var asterisk = _handlers['*'];\n  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键\n\n  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致\n  // Webkit左右 command 键值不一样\n\n  if (key === 93 || key === 224) key = 91;\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n\n  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {\n    var keyNum = modifierMap[keyName];\n\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {\n      /**\n       * Fix if Command is pressed:\n       * ===============================\n       */\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  /**\n   * -------------------------------\n   */\n\n  if (key in _mods) {\n    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n\n    if (!asterisk) return;\n  } // 将 modifierMap 里面的修饰键绑定到 event 中\n\n\n  for (var e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n\n\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n\n    _mods[17] = true;\n    _mods[18] = true;\n  } // 获取范围 默认为 `all`\n\n\n  var scope = getScope(); // 对任何快捷键都需要做的处理\n\n  if (asterisk) {\n    for (var i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope, element);\n      }\n    }\n  } // key 不在 _handlers 中返回\n\n\n  if (!(key in _handlers)) return;\n\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = []; // 记录当前按键键值\n\n        for (var a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // 找到处理内容\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n} // 判断 element 是否已经绑定事件\n\n\nfunction isElementBind(element) {\n  return elementHasBindEvent.indexOf(element) > -1;\n}\n\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys = getKeys(key); // 需要处理的快捷键列表\n\n  var mods = [];\n  var scope = 'all'; // scope默认为all，所有范围都有效\n\n  var element = document; // 快捷键事件绑定节点\n\n  var i = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = '+';\n  var capture = false; // 对为设定范围的判断\n\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // eslint-disable-line\n\n    if (option.element) element = option.element; // eslint-disable-line\n\n    if (option.keyup) keyup = option.keyup; // eslint-disable-line\n\n    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n\n    if (option.capture !== undefined) capture = option.capture; // eslint-disable-line\n\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n  }\n\n  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理\n\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // 按键列表\n\n    mods = []; // 如果是组合快捷键取得组合快捷键\n\n    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码\n\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键\n    // 判断key是否在_handlers中，不在就赋一个空数组\n\n    if (!(key in _handlers)) _handlers[key] = [];\n\n    _handlers[key].push({\n      keyup: keyup,\n      keydown: keydown,\n      scope: scope,\n      mods: mods,\n      shortcut: keys[i],\n      method: method,\n      key: keys[i],\n      splitKey: splitKey,\n      element: element\n    });\n  } // 在全局document上设置快捷键\n\n\n  if (typeof element !== 'undefined' && !isElementBind(element) && window) {\n    elementHasBindEvent.push(element);\n    addEvent(element, 'keydown', function (e) {\n      dispatch(e, element);\n    }, capture);\n\n    if (!winListendFocus) {\n      winListendFocus = true;\n      addEvent(window, 'focus', function () {\n        _downKeys = [];\n      }, capture);\n    }\n\n    addEvent(element, 'keyup', function (e) {\n      dispatch(e, element);\n      clearModifier(e);\n    }, capture);\n  }\n}\n\nfunction trigger(shortcut) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n  Object.keys(_handlers).forEach(function (key) {\n    var data = _handlers[key].find(function (item) {\n      return item.scope === scope && item.shortcut === shortcut;\n    });\n\n    if (data && data.method) {\n      data.method();\n    }\n  });\n}\n\nvar _api = {\n  setScope: setScope,\n  getScope: getScope,\n  deleteScope: deleteScope,\n  getPressedKeyCodes: getPressedKeyCodes,\n  isPressed: isPressed,\n  filter: filter,\n  trigger: trigger,\n  unbind: unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap: modifierMap\n};\n\nfor (var a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\n\nif (typeof window !== 'undefined') {\n  var _hotkeys = window.hotkeys;\n\n  hotkeys.noConflict = function (deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n\n    return hotkeys;\n  };\n\n  window.hotkeys = hotkeys;\n}\n\nmodule.exports = hotkeys;\n\n\n//# sourceURL=webpack://nadesiko3/./node_modules/hotkeys-js/dist/hotkeys.common.js?")},"./node_modules/hotkeys-js/index.js":function(module,__unused_webpack_exports,__webpack_require__){eval('if (false) {} else {\n  // eslint-disable-next-line global-require\n  module.exports = __webpack_require__(/*! ./dist/hotkeys.common.js */ "./node_modules/hotkeys-js/dist/hotkeys.common.js");\n}\n\n\n//# sourceURL=webpack://nadesiko3/./node_modules/hotkeys-js/index.js?')},"./core/src/nako3.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoCompiler\": function() { return /* binding */ NakoCompiler; },\n/* harmony export */   \"newCompilerOptions\": function() { return /* binding */ newCompilerOptions; }\n/* harmony export */ });\n/* harmony import */ var _nako_parser3_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_parser3.mjs */ \"./core/src/nako_parser3.mjs\");\n/* harmony import */ var _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_lexer.mjs */ \"./core/src/nako_lexer.mjs\");\n/* harmony import */ var _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_prepare.mjs */ \"./core/src/nako_prepare.mjs\");\n/* harmony import */ var _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nako_gen.mjs */ \"./core/src/nako_gen.mjs\");\n/* harmony import */ var _nako_gen_async_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nako_gen_async.mjs */ \"./core/src/nako_gen_async.mjs\");\n/* harmony import */ var _nako_indent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nako_indent.mjs */ \"./core/src/nako_indent.mjs\");\n/* harmony import */ var _nako_from_dncl_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nako_from_dncl.mjs */ \"./core/src/nako_from_dncl.mjs\");\n/* harmony import */ var _nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nako_source_mapping.mjs */ \"./core/src/nako_source_mapping.mjs\");\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_logger_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./nako_logger.mjs */ \"./core/src/nako_logger.mjs\");\n/* harmony import */ var _nako_global_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./nako_global.mjs */ \"./core/src/nako_global.mjs\");\n/* harmony import */ var _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nako_core_version.mjs */ \"./core/src/nako_core_version.mjs\");\n/* harmony import */ var _plugin_system_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugin_system.mjs */ \"./core/src/plugin_system.mjs\");\n/* harmony import */ var _plugin_math_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugin_math.mjs */ \"./core/src/plugin_math.mjs\");\n/* harmony import */ var _plugin_csv_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugin_csv.mjs */ \"./core/src/plugin_csv.mjs\");\n/* harmony import */ var _plugin_promise_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugin_promise.mjs */ \"./core/src/plugin_promise.mjs\");\n/* harmony import */ var _plugin_test_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugin_test.mjs */ \"./core/src/plugin_test.mjs\");\n// parser / lexer\n\n\n\n\n\n\n\n\n\n\n\n// version info\n\n// basic plugins\n\n\n\n\n\nconst cloneAsJSON = (x) => JSON.parse(JSON.stringify(x));\n/** コンパイラ実行オプションを生成 */\nfunction newCompilerOptions(initObj = {}) {\n    if (typeof initObj !== 'object') {\n        initObj = {};\n    }\n    initObj.testOnly = initObj.testOnly || false;\n    initObj.resetEnv = initObj.resetEnv || false;\n    initObj.resetAll = initObj.resetAll || false;\n    initObj.preCode = initObj.preCode || '';\n    initObj.nakoGlobal = initObj.nakoGlobal || null;\n    return initObj;\n}\n/** なでしこコンパイラ */\nclass NakoCompiler {\n    /**\n     * @param {undefined | {'useBasicPlugin':true|false}} options\n     */\n    constructor(options = undefined) {\n        if (options === undefined) {\n            options = { useBasicPlugin: true };\n        }\n        // 環境のリセット\n        this.__varslist = [{}, {}, {}]; // このオブジェクトは変更しないこと (this.gen.__varslist と共有する)\n        this.__locals = {}; // ローカル変数\n        this.__self = this;\n        this.__vars = this.__varslist[2];\n        this.__v0 = this.__varslist[0];\n        this.__v1 = this.__varslist[1];\n        // バージョンを設定\n        this.version = _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"].version;\n        this.coreVersion = _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"].version;\n        /**\n         * @type {NakoGlobal[]}\n         */\n        this.__globals = []; // 生成した NakoGlobal のインスタンスを保持\n        /** @type {Record<string, Record<string, NakoFunction>>} */\n        this.__module = {}; // requireなどで取り込んだモジュールの一覧\n        this.pluginFunclist = {}; // プラグインで定義された関数\n        this.funclist = {}; // プラグインで定義された関数 + ユーザーが定義した関数\n        this.pluginfiles = {}; // 取り込んだファイル一覧\n        this.commandlist = new Set(); // プラグインで定義された定数・変数・関数の名前\n        this.nakoFuncList = {}; // __v1に配置するJavaScriptのコードで定義された関数\n        this.eventList = []; // 実行前に環境を変更するためのイベント\n        this.logger = new _nako_logger_mjs__WEBPACK_IMPORTED_MODULE_9__.NakoLogger();\n        /**\n         * 取り込み文を置換するためのオブジェクト。\n         * 正規化されたファイル名がキーになり、取り込み文の引数に指定された正規化されていないファイル名はaliasに入れられる。\n         * JavaScriptファイルによるプラグインの場合、contentは空文字列。\n         * funclistはシンタックスハイライトの高速化のために事前に取り出した、ファイルが定義する関数名のリスト。\n         */\n        this.dependencies = {};\n        this.usedFuncs = new Set();\n        this.numFailures = 0;\n        if (options.useBasicPlugin) {\n            this.addBasicPlugins();\n        }\n        // 必要なオブジェクトを覚えておく\n        this.prepare = _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoPrepare.getInstance();\n        this.parser = new _nako_parser3_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoParser(this.logger);\n        this.lexer = new _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer(this.logger);\n        // 関数一覧を設定\n        this.lexer.setFuncList(this.funclist);\n    }\n    getLogger() {\n        return this.logger;\n    }\n    getNakoFuncList() {\n        return this.nakoFuncList;\n    }\n    getNakoFunc(name) {\n        return this.nakoFuncList[name];\n    }\n    getPluginfiles() {\n        return this.pluginfiles;\n    }\n    /**\n     * 基本的なプラグインを追加する\n     */\n    addBasicPlugins() {\n        this.addPluginObject('PluginSystem', _plugin_system_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"]);\n        this.addPluginObject('PluginMath', _plugin_math_mjs__WEBPACK_IMPORTED_MODULE_13__[\"default\"]);\n        this.addPluginObject('PluginPromise', _plugin_promise_mjs__WEBPACK_IMPORTED_MODULE_15__[\"default\"]);\n        this.addPluginObject('PluginAssert', _plugin_test_mjs__WEBPACK_IMPORTED_MODULE_16__[\"default\"]);\n        this.addPluginObject('PluginCSV', _plugin_csv_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"]);\n    }\n    /**\n     * loggerを新しいインスタンスで置き換える。\n     */\n    replaceLogger() {\n        const logger = this.lexer.logger = this.parser.logger = this.logger = new _nako_logger_mjs__WEBPACK_IMPORTED_MODULE_9__.NakoLogger();\n        return logger;\n    }\n    /**\n     * ファイル内のrequire文の位置を列挙する。出力の配列はstartでソートされている。\n     * @param {Token[]} tokens rawtokenizeの出力\n     */\n    static listRequireStatements(tokens) {\n        const requireStatements = [];\n        for (let i = 0; i + 2 < tokens.length; i++) {\n            // not (string|string_ex) '取り込み'\n            if (!(tokens[i].type === 'not' &&\n                (tokens[i + 1].type === 'string' || tokens[i + 1].type === 'string_ex') &&\n                tokens[i + 2].value === '取込')) {\n                continue;\n            }\n            requireStatements.push({\n                ...tokens[i],\n                start: i,\n                end: i + 3,\n                value: tokens[i + 1].value + '',\n                firstToken: tokens[i],\n                lastToken: tokens[i + 2]\n            });\n            i += 2;\n        }\n        return requireStatements;\n    }\n    /**\n     * プログラムが依存するファイルを再帰的に取得する。\n     * - 依存するファイルがJavaScriptファイルの場合、そのファイルを実行して評価結果をthis.addPluginFileに渡す。\n     * - 依存するファイルがなでしこ言語の場合、ファイルの中身を取得して変数に保存し、再帰する。\n     *\n     * @param {string} code\n     * @param {string} filename\n     * @param {string} preCode\n     * @param {LoaderTool} tools 実行環境 (ブラウザ or Node.js) によって外部ファイルの取得・実行方法は異なるため、引数でそれらを行う関数を受け取る。\n     *  - resolvePath は指定した名前をもつファイルを検索し、正規化されたファイル名を返す関数。返されたファイル名はreadNako3かreadJsの引数になる。\n     *  - readNako3は指定されたファイルの中身を返す関数。\n     *  - readJsは指定したファイルをJavaScriptのプログラムとして実行し、`export default` でエクスポートされた値を返す関数。\n     * @returns {Promise<unknown> | void}\n     * @protected\n     */\n    _loadDependencies(code, filename, preCode, tools) {\n        const dependencies = {};\n        const compiler = new NakoCompiler({ useBasicPlugin: true });\n        /**\n         * @param {any} item\n         * @param {any} tasks\n         */\n        const loadJS = (item, tasks) => {\n            // jsならプラグインとして読み込む。(ESMでは必ず動的に読む)\n            const obj = tools.readJs(item.filePath, item.firstToken);\n            tasks.push(obj.task.then((res) => {\n                const pluginFuncs = res();\n                this.addPluginFile(item.value, item.filePath, pluginFuncs, false);\n                dependencies[item.filePath].funclist = pluginFuncs;\n                dependencies[item.filePath].addPluginFile = () => { this.addPluginFile(item.value, item.filePath, pluginFuncs, false); };\n            }));\n        };\n        const loadNako3 = (item, tasks) => {\n            // nako3ならファイルを読んでdependenciesに保存する。\n            const content = tools.readNako3(item.filePath, item.firstToken);\n            const registerFile = (code) => {\n                // シンタックスハイライトの高速化のために、事前にファイルが定義する関数名のリストを取り出しておく。\n                // preDefineFuncはトークン列に変更を加えるため、事前にクローンしておく。\n                // 「プラグイン名設定」を行う (#956)\n                const modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer.filenameToModName(item.filePath);\n                code = `『${modName}』にプラグイン名設定;` + code + ';『メイン』にプラグイン名設定;';\n                const tokens = this.rawtokenize(code, 0, item.filePath);\n                dependencies[item.filePath].tokens = tokens;\n                const funclist = {};\n                _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer.preDefineFunc(cloneAsJSON(tokens), this.logger, funclist);\n                dependencies[item.filePath].funclist = funclist;\n                // 再帰\n                return loadRec(code, item.filePath, '');\n            };\n            // 取り込み構文における問題を減らすため、必ず非同期でプログラムを読み込む仕様とした #1219\n            tasks.push(content.task.then((res) => registerFile(res)));\n        };\n        const loadRec = (code, filename, preCode) => {\n            const tasks = [];\n            // 取り込みが必要な情報一覧を調べる(トークン分割して、取り込みタグを得る)\n            const tags = NakoCompiler.listRequireStatements(compiler.rawtokenize(code, 0, filename, preCode));\n            // パスを解決する\n            const tagsResolvePath = tags.map((v) => ({ ...v, ...tools.resolvePath(v.value, v.firstToken, filename) }));\n            // 取り込み開始\n            for (const item of tagsResolvePath) {\n                // 2回目以降の読み込み\n                // eslint-disable-next-line no-prototype-builtins\n                if (dependencies.hasOwnProperty(item.filePath)) {\n                    dependencies[item.filePath].alias.add(item.value);\n                    continue;\n                }\n                // 初回の読み込み\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                dependencies[item.filePath] = { tokens: [], alias: new Set([item.value]), addPluginFile: () => { }, funclist: {} };\n                if (item.type === 'js' || item.type === 'mjs') {\n                    loadJS(item, tasks);\n                }\n                else if (item.type === 'nako3') {\n                    loadNako3(item, tasks);\n                }\n                else {\n                    throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__.NakoImportError(`ファイル『${item.value}』を読み込めません。ファイルが存在しないか未対応の拡張子です。`, item.firstToken.file, item.firstToken.line);\n                }\n            }\n            if (tasks.length > 0) {\n                return Promise.all(tasks);\n            }\n            return undefined;\n        };\n        try {\n            const result = loadRec(code, filename, preCode);\n            // 非同期な場合のエラーハンドリング\n            if (result !== undefined) {\n                result.catch((err) => {\n                    // 読み込みに失敗しても処理は続ける方針なので、失敗しても例外は投げない\n                    // たぶん、その後の構文解析でエラーになるため\n                    this.logger.warn(err.msg);\n                });\n            }\n            // すべてが終わってからthis.dependenciesに代入する。そうしないと、「実行」ボタンを連打した場合など、\n            // loadDependencies() が並列実行されるときに正しく動作しない。\n            this.dependencies = dependencies;\n            return result;\n        }\n        catch (err) {\n            // 同期処理では素直に例外を投げる\n            this.logger.warn('' + err);\n            throw err;\n        }\n    }\n    /**\n     * コードを単語に分割する\n     * @param {string} code なでしこのプログラム\n     * @param {number} line なでしこのプログラムの行番号\n     * @param {string} filename\n     * @param {string} [preCode]\n     * @returns {TokenWithSourceMap[]} トークンのリスト\n     */\n    rawtokenize(code, line, filename, preCode = '') {\n        if (!code.startsWith(preCode)) {\n            throw new Error('codeの先頭にはpreCodeを含める必要があります。');\n        }\n        // インデント構文 (#596)\n        const { code: code2, insertedLines, deletedLines } = _nako_indent_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].convert(code, filename);\n        // DNCL構文 (#1140)\n        const code3 = (0,_nako_from_dncl_mjs__WEBPACK_IMPORTED_MODULE_6__.convertDNCL)(code2, filename);\n        // 全角半角の統一処理\n        const preprocessed = this.prepare.convert(code3);\n        const tokenizationSourceMapping = new _nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__.SourceMappingOfTokenization(code2.length, preprocessed);\n        const indentationSyntaxSourceMapping = new _nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__.SourceMappingOfIndentSyntax(code2, insertedLines, deletedLines);\n        const offsetToLineColumn = new _nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__.OffsetToLineColumn(code);\n        // トークン分割\n        let tokens;\n        try {\n            tokens = this.lexer.tokenize(preprocessed.map((v) => v.text).join(''), line, filename);\n        }\n        catch (err) {\n            if (!(err instanceof _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__.InternalLexerError)) {\n                throw err;\n            }\n            // エラー位置をソースコード上の位置に変換して返す\n            const dest = indentationSyntaxSourceMapping.map(tokenizationSourceMapping.map(err.preprocessedCodeStartOffset), tokenizationSourceMapping.map(err.preprocessedCodeEndOffset));\n            /** @type {number | undefined} */\n            const line = dest.startOffset === null ? err.line : offsetToLineColumn.map(dest.startOffset, false).line;\n            const map = (0,_nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__.subtractSourceMapByPreCodeLength)({ ...dest, line }, preCode);\n            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__.NakoLexerError(err.msg, map.startOffset, map.endOffset, map.line, filename);\n        }\n        // ソースコード上の位置に変換\n        return tokens.map((token) => {\n            const dest = indentationSyntaxSourceMapping.map(tokenizationSourceMapping.map(token.preprocessedCodeOffset || 0), tokenizationSourceMapping.map((token.preprocessedCodeOffset || 0) + (token.preprocessedCodeLength || 0)));\n            let line = token.line;\n            let column = 0;\n            if (token.type === 'eol' && dest.endOffset !== null) {\n                // eolはparserで `line = ${eolToken.line};` に変換されるため、\n                // 行末のeolのlineは次の行の行数を表す必要がある。\n                const out = offsetToLineColumn.map(dest.endOffset, false);\n                line = out.line;\n                column = out.column;\n            }\n            else if (dest.startOffset !== null) {\n                const out = offsetToLineColumn.map(dest.startOffset, false);\n                line = out.line;\n                column = out.column;\n            }\n            return {\n                ...token,\n                ...(0,_nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_7__.subtractSourceMapByPreCodeLength)({ line, column, startOffset: dest.startOffset, endOffset: dest.endOffset }, preCode),\n                rawJosi: token.josi\n            };\n        });\n    }\n    /**\n     * 単語の属性を構文解析に先立ち補正する\n     * @param {Token[]} tokens トークンのリスト\n     * @param {boolean} isFirst 最初の呼び出しかどうか\n     * @param {string} filename\n     * @returns コード (なでしこ)\n     */\n    converttoken(tokens, isFirst, filename) {\n        const tok = this.lexer.replaceTokens(tokens, isFirst, filename);\n        return tok;\n    }\n    /**\n     * 環境のリセット\n     * {NakoResetOption|undefined}\n     */\n    reset(options = undefined) {\n        if (!options || options.needToClearPlugin) {\n            // (メモ) #1245\n            // 通常、リセット処理では、プラグインの!クリアを呼ぶ。\n            // しかし、エディタではクリアイベントを呼ぶと、時計などのコンテンツが止まってしまう\n            // そのため、例外的にオプションを指定すると、プラグインのクリアイベントを呼ばない\n            this.clearPlugins();\n        }\n        /**\n         * なでしこのローカル変数をスタックで管理\n         * __varslist[0] プラグイン領域\n         * __varslist[1] なでしこグローバル領域\n         * __varslist[2] 最初のローカル変数 ( == __vars }\n         */\n        this.__varslist = [this.__varslist[0], {}, {}];\n        this.__v0 = this.__varslist[0];\n        this.__v1 = this.__varslist[1];\n        this.__vars = this.__varslist[2];\n        this.__locals = {};\n        // プラグイン命令以外を削除する。\n        this.funclist = {};\n        for (const name of Object.keys(this.__v0)) {\n            const original = this.pluginFunclist[name];\n            if (!original) {\n                continue;\n            }\n            this.funclist[name] = JSON.parse(JSON.stringify(original));\n        }\n        this.lexer.setFuncList(this.funclist);\n        this.logger.clear();\n    }\n    /**\n     * typeがcodeのトークンを単語に分割するための処理\n     * @param {string} code\n     * @param {number} line\n     * @param {string} filename\n     * @param {number | null} startOffset\n     * @returns\n     * @private\n     */\n    lexCodeToken(code, line, filename, startOffset) {\n        // 単語に分割\n        let tokens = this.rawtokenize(code, line, filename, '');\n        // 文字列内位置からファイル内位置へ変換\n        if (startOffset === null) {\n            for (const token of tokens) {\n                token.startOffset = undefined;\n                token.endOffset = undefined;\n            }\n        }\n        else {\n            for (const token of tokens) {\n                if (token.startOffset !== undefined) {\n                    token.startOffset += startOffset;\n                }\n                if (token.endOffset !== undefined) {\n                    token.endOffset += startOffset;\n                }\n            }\n        }\n        // convertTokenで消されるコメントのトークンを残す\n        const commentTokens = tokens.filter((t) => t.type === 'line_comment' || t.type === 'range_comment')\n            .map((v) => ({ ...v })); // clone\n        tokens = this.converttoken(tokens, false, filename);\n        return { tokens, commentTokens };\n    }\n    /**\n     * 再帰的にrequire文を置換する。\n     * .jsであれば削除し、.nako3であればそのファイルのトークン列で置換する。\n     * @param {TokenWithSourceMap[]} tokens\n     * @param {Set<string>} [includeGuard]\n     * @returns {Token[]} 削除された取り込み文のトークン\n     */\n    replaceRequireStatements(tokens, includeGuard = new Set()) {\n        /** @type {TokenWithSourceMap[]} */\n        const deletedTokens = [];\n        for (const r of NakoCompiler.listRequireStatements(tokens).reverse()) {\n            // C言語のinclude guardと同じ仕組みで無限ループを防ぐ。\n            if (includeGuard.has(r.value)) {\n                deletedTokens.push(...tokens.splice((r.start || 0), (r.end || 0) - (r.start || 0)));\n                continue;\n            }\n            const filePath = Object.keys(this.dependencies).find((key) => this.dependencies[key].alias.has(r.value));\n            if (filePath === undefined) {\n                if (!r.firstToken) {\n                    throw new Error(`ファイル『${r.value}』が読み込まれていません。`);\n                }\n                throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__.NakoLexerError(`ファイル『${r.value}』が読み込まれていません。`, r.firstToken.startOffset || 0, r.firstToken.endOffset || 0, r.firstToken.line, r.firstToken.file);\n            }\n            this.dependencies[filePath].addPluginFile();\n            const children = cloneAsJSON(this.dependencies[filePath].tokens);\n            includeGuard.add(r.value);\n            deletedTokens.push(...this.replaceRequireStatements(children, includeGuard));\n            deletedTokens.push(...tokens.splice(r.start || 0, (r.end || 0) - (r.start || 0), ...children));\n        }\n        return deletedTokens;\n    }\n    /**\n     * replaceRequireStatementsのシンタックスハイライト用の実装。\n     * @param {TokenWithSourceMap[]} tokens\n     * @returns {TokenWithSourceMap[]} 削除された取り込み文のトークン\n     */\n    removeRequireStatements(tokens) {\n        /** @type {TokenWithSourceMap[]} */\n        const deletedTokens = [];\n        for (const r of NakoCompiler.listRequireStatements(tokens).reverse()) {\n            // プラグイン命令のシンタックスハイライトのために、addPluginFileを呼んで関数のリストをthis.dependencies[filePath].funclistに保存させる。\n            const filePath = Object.keys(this.dependencies).find((key) => this.dependencies[key].alias.has(r.value));\n            if (filePath !== undefined) {\n                this.dependencies[filePath].addPluginFile();\n            }\n            // 全ての取り込み文を削除する。そうしないとトークン化に時間がかかりすぎる。\n            deletedTokens.push(...tokens.splice(r.start || 0, (r.end || 0) - (r.start || 0)));\n        }\n        return deletedTokens;\n    }\n    /**\n     * @param {string} code\n     * @param {string} filename\n     * @param {string} [preCode]\n     */\n    lex(code, filename = 'main.nako3', preCode = '', syntaxHighlighting = false) {\n        // 単語に分割\n        let tokens = this.rawtokenize(code, 0, filename, preCode);\n        // require文を再帰的に置換する\n        const requireStatementTokens = syntaxHighlighting ? this.removeRequireStatements(tokens) : this.replaceRequireStatements(tokens, undefined);\n        for (const t of requireStatementTokens) {\n            if (t.type === 'word' || t.type === 'not') {\n                t.type = 'require';\n            }\n        }\n        if (requireStatementTokens.length >= 3) {\n            // modList を更新\n            for (let i = 0; i < requireStatementTokens.length; i += 3) {\n                let modName = requireStatementTokens[i + 1].value;\n                modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer.filenameToModName(modName);\n                if (this.lexer.modList.indexOf(modName) < 0) {\n                    this.lexer.modList.push(modName);\n                }\n            }\n        }\n        // convertTokenで消されるコメントのトークンを残す\n        /** @type {TokenWithSourceMap[]} */\n        const commentTokens = tokens.filter((t) => t.type === 'line_comment' || t.type === 'range_comment')\n            .map((v) => ({ ...v })); // clone\n        tokens = this.converttoken(tokens, true, filename);\n        for (let i = 0; i < tokens.length; i++) {\n            if (tokens[i] && tokens[i].type === 'code') {\n                const children = this.lexCodeToken(tokens[i].value, tokens[i].line, filename, tokens[i].startOffset || 0);\n                commentTokens.push(...children.commentTokens);\n                tokens.splice(i, 1, ...children.tokens);\n                i--;\n            }\n        }\n        this.logger.trace('--- lex ---\\n' + JSON.stringify(tokens, null, 2));\n        return { commentTokens, tokens, requireTokens: requireStatementTokens };\n    }\n    /**\n     * コードをパースしてASTにする\n     */\n    parse(code, filename, preCode = '') {\n        // 関数を字句解析と構文解析に登録\n        this.lexer.setFuncList(this.funclist);\n        this.parser.setFuncList(this.funclist);\n        const lexerOutput = this.lex(code, filename, preCode);\n        // 構文木を作成\n        let ast;\n        try {\n            this.parser.genMode = 'sync'; // set default\n            ast = this.parser.parse(lexerOutput.tokens, filename);\n        }\n        catch (err) {\n            if (typeof err.startOffset !== 'number') {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_8__.NakoSyntaxError.fromNode(err.message, lexerOutput.tokens[this.parser.getIndex()]);\n            }\n            throw err;\n        }\n        // 使用したシステム関数の一覧を this.usedFuns に入れる(エディタなどで利用される)\n        this.usedFuncs = this.parser.usedFuncs; // 全ての関数呼び出し\n        this.deleteUnNakoFuncs(); // システム関数以外を削除\n        this.logger.trace('--- ast ---\\n' + JSON.stringify(ast, null, 2));\n        return ast;\n    }\n    getUsedFuncs(ast) {\n        const queue = [ast];\n        this.usedFuncs = new Set();\n        while (queue.length > 0) {\n            const ast_ = queue.pop();\n            if (ast_ !== null && ast_ !== undefined && ast_.block !== null && ast_.block !== undefined) {\n                this.getUsedAndDefFuncs(queue, JSON.parse(JSON.stringify(ast_.block)));\n            }\n        }\n        return this.deleteUnNakoFuncs();\n    }\n    getUsedAndDefFuncs(astQueue, blockQueue) {\n        while (blockQueue.length > 0) {\n            const block = blockQueue.pop();\n            if (block !== null && block !== undefined) {\n                this.getUsedAndDefFunc(block, astQueue, blockQueue);\n            }\n        }\n    }\n    getUsedAndDefFunc(block, astQueue, blockQueue) {\n        if (['func', 'func_pointer'].includes(block.type) && block.name !== null && block.name !== undefined) {\n            this.usedFuncs.add(block.name);\n        }\n        astQueue.push([block, block.block]);\n        blockQueue.push.apply(blockQueue, [block.value].concat(block.args));\n    }\n    deleteUnNakoFuncs() {\n        for (const func of this.usedFuncs) {\n            if (!this.commandlist.has(func)) {\n                this.usedFuncs.delete(func);\n            }\n        }\n        return this.usedFuncs;\n    }\n    /**\n     * プログラムをコンパイルしてランタイム用のJavaScriptのコードを返す\n     * @param code コード (なでしこ)\n     * @param filename\n     * @param isTest テストかどうか\n     * @param preCode\n     */\n    compile(code, filename, isTest = false, preCode = '') {\n        const opt = newCompilerOptions();\n        opt.testOnly = isTest;\n        opt.preCode = preCode;\n        const res = this.compileFromCode(code, filename, opt);\n        return res.runtimeEnv;\n    }\n    /** parse & generate  */\n    compileFromCode(code, filename, options = undefined) {\n        if (filename === '') {\n            filename = 'main.nako3';\n        }\n        if (options === undefined) {\n            options = newCompilerOptions();\n        }\n        try {\n            if (options.resetEnv) {\n                this.reset();\n            }\n            if (options.resetAll) {\n                this.clearPlugins();\n            }\n            // onBeforeParse\n            this.eventList.filter(o => o.eventName === 'beforeParse').map(e => e.callback(code));\n            const ast = this.parse(code, filename, options.preCode);\n            // onBeforeGenerate\n            this.eventList.filter(o => o.eventName === 'beforeGenerate').map(e => e.callback(ast));\n            // generate\n            const outCode = this.generateCode(ast, new _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoGenOptions(options.testOnly));\n            // onAfterGenerate\n            this.eventList.filter(o => o.eventName === 'afterGenerate').map(e => e.callback(outCode));\n            return outCode;\n        }\n        catch (e) {\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    /**\n     * プログラムをコンパイルしてJavaScriptのコードオブジェクトを返す\n     * @param {AST} ast\n     * @param opt テストかどうか\n     * @return {Object}\n     */\n    generateCode(ast, opt) {\n        // Select Code Generator #637\n        switch (ast.genMode) {\n            // ノーマルモード\n            case 'sync':\n                return (0,_nako_gen_mjs__WEBPACK_IMPORTED_MODULE_3__.generateJS)(this, ast, opt);\n            // 『!非同期モード』は非推奨\n            case '非同期モード':\n                this.logger.warn('『!非同期モード』の利用は非推奨です。[詳細](https://github.com/kujirahand/nadesiko3/issues/1164)');\n                return _nako_gen_async_mjs__WEBPACK_IMPORTED_MODULE_4__.NakoGenASync.generate(this, ast, opt.isTest);\n            default:\n                throw new Error(`コードジェネレータの「${ast.genMode}」はサポートされていません。`);\n        }\n    }\n    /** (非推奨)\n     * @param code\n     * @param fname\n     * @param isReset\n     * @param isTest テストかどうか。stringの場合は1つのテストのみ。\n     * @param [preCode]\n     */\n    async _run(code, fname, isReset, isTest, preCode = '') {\n        const opts = newCompilerOptions({\n            resetEnv: isReset,\n            resetAll: isReset,\n            testOnly: isTest,\n            preCode\n        });\n        return this._runEx(code, fname, opts);\n    }\n    /** 各プラグインをリセットする */\n    clearPlugins() {\n        // 他に実行している「なでしこ」があればクリアする\n        this.__globals.forEach((sys) => {\n            sys.reset();\n        });\n        this.__globals = []; // clear\n    }\n    /**\n     * 環境を指定してJavaScriptのコードを実行する\n     * @param code JavaScriptのコード\n     * @param nakoGlobal 実行環境\n     */\n    evalJS(code, nakoGlobal) {\n        // 実行前に環境を初期化するイベントを実行(beforeRun)\n        this.eventList.filter(o => o.eventName === 'beforeRun').map(e => e.callback(nakoGlobal));\n        // eslint-disable-next-line no-new-func\n        const f = new Function(code);\n        f.apply(nakoGlobal);\n        // 実行後に終了イベントを実行(finish)\n        this.eventList.filter(o => o.eventName === 'finish').map(e => e.callback(nakoGlobal));\n    }\n    /**\n     * 同期的になでしこのプログラムcodeを実行する\n     * @param code なでしこのプログラム\n     * @param filename ファイル名\n     * @param options オプション\n     * @returns 実行に利用したグローバルオブジェクト\n     */\n    runSync(code, filename, options = undefined) {\n        // コンパイル\n        options = newCompilerOptions(options);\n        const out = this.compileFromCode(code, filename, options);\n        // 実行前に環境を生成\n        const nakoGlobal = this.getNakoGlobal(options, out.gen);\n        // 実行\n        this.evalJS(out.runtimeEnv, nakoGlobal);\n        return nakoGlobal;\n    }\n    /**\n     * 非同期になでしこのプログラムcodeを実行する\n     * @param code なでしこのプログラム\n     * @param filename ファイル名\n     * @param options オプション\n     * @returns 実行に利用したグローバルオブジェクト\n     */\n    async runAsync(code, filename, options = undefined) {\n        // コンパイル\n        options = newCompilerOptions(options);\n        const out = this.compileFromCode(code, filename, options);\n        // 実行前に環境を生成\n        const nakoGlobal = this.getNakoGlobal(options, out.gen);\n        // 実行\n        this.evalJS(out.runtimeEnv, nakoGlobal);\n        return nakoGlobal;\n    }\n    getNakoGlobal(options, gen) {\n        // オプションを参照\n        let g = options.nakoGlobal;\n        if (!g) {\n            // 空ならば前回の値を参照(リセットするなら新規で作成する)\n            if (this.__globals.length > 0 && options.resetAll === false && options.resetEnv === false) {\n                g = this.__globals[this.__globals.length - 1];\n            }\n            else {\n                g = new _nako_global_mjs__WEBPACK_IMPORTED_MODULE_10__.NakoGlobal(this, gen, (this.__globals.length + 1));\n            }\n        }\n        if (this.__globals.indexOf(g) < 0) {\n            this.__globals.push(g);\n        }\n        return g;\n    }\n    /**\n     * イベントを登録する\n     * @param eventName イベント名\n     * @param callback コールバック関数\n     */\n    addListener(eventName, callback) {\n        this.eventList.push({ eventName, callback });\n    }\n    /**\n     * テストを実行する\n     * @param code\n     * @param fname\n     * @param preCode\n     * @param testOnly\n     */\n    test(code, fname, preCode = '', testOnly = false) {\n        const options = newCompilerOptions();\n        options.preCode = preCode;\n        options.testOnly = testOnly;\n        return this.runSync(code, fname, options);\n    }\n    /**\n     * なでしこのプログラムを実行（他に実行しているインスタンスはそのまま）\n     * @param code\n     * @param fname\n     * @param [preCode]\n     */\n    run(code, fname = 'main.nako3', preCode = '') {\n        const options = newCompilerOptions();\n        options.preCode = preCode;\n        return this.runSync(code, fname, options);\n    }\n    /**\n     * JavaScriptのみで動くコードを取得する場合\n     * @param code\n     * @param filename\n     * @param opt\n     */\n    compileStandalone(code, filename, opt = null) {\n        if (opt === null) {\n            opt = new _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoGenOptions();\n        }\n        const ast = this.parse(code, filename);\n        return this.generateCode(ast, opt).standalone;\n    }\n    /**\n     * プラグイン・オブジェクトを追加\n     * @param po プラグイン・オブジェクト\n     * @param persistent falseのとき、次以降の実行では使えない\n     */\n    addPlugin(po, persistent = true) {\n        // 変数のメタ情報を確認\n        const __v0 = this.__varslist[0];\n        if (__v0.meta === undefined) {\n            __v0.meta = {};\n        }\n        // プラグインの値をオブジェクトにコピー\n        for (const key in po) {\n            const v = po[key];\n            this.funclist[key] = v;\n            if (persistent) {\n                this.pluginFunclist[key] = JSON.parse(JSON.stringify(v));\n            }\n            if (v.type === 'func') {\n                __v0[key] = v.fn;\n            }\n            else if (v.type === 'const' || v.type === 'var') {\n                __v0[key] = v.value;\n                __v0.meta[key] = {\n                    readonly: (v.type === 'const')\n                };\n            }\n            else {\n                console.error('[プラグイン追加エラー]', v);\n                throw new Error('プラグインの追加でエラー。');\n            }\n            // コマンドを登録するか?\n            if (key === '初期化' || key.substring(0, 1) === '!') { // 登録しない関数名\n                continue;\n            }\n            this.commandlist.add(key);\n        }\n    }\n    /**\n     * プラグイン・オブジェクトを追加(ブラウザ向け)\n     * @param objName オブジェクト名\n     * @param po 関数リスト\n     * @param persistent falseのとき、次以降の実行では使えない\n     */\n    addPluginObject(objName, po, persistent = true) {\n        this.__module[objName] = po;\n        this.pluginfiles[objName] = '*';\n        // 初期化をチェック\n        if (typeof (po['初期化']) === 'object') {\n            const def = po['初期化'];\n            delete po['初期化'];\n            const initKey = `!${objName}:初期化`;\n            po[initKey] = def;\n        }\n        // メタ情報をチェック (#1034)\n        if (po.meta && po.meta.value && typeof (po.meta) === 'object') {\n            const meta = po.meta;\n            delete po.meta;\n            const pluginName = meta.value.pluginName || objName;\n            const metaKey = `__${pluginName}`.replace('-', '__');\n            po[metaKey] = meta;\n        }\n        this.addPlugin(po, persistent);\n    }\n    /**\n     * プラグイン・ファイルを追加(Node.js向け)\n     * @param objName オブジェクト名\n     * @param fpath ファイルパス\n     * @param po 登録するオブジェクト\n     * @param persistent falseのとき、次以降の実行では使えない\n     */\n    addPluginFile(objName, fpath, po, persistent = true) {\n        // Windowsのパスがあると、JSファイル書き出しでエラーになるので、置換する\n        if (objName.indexOf('\\\\') >= 0) {\n            objName = objName.replace(/\\\\/g, '/');\n        }\n        this.addPluginObject(objName, po, persistent);\n        if (this.pluginfiles[objName] === undefined) {\n            this.pluginfiles[objName] = fpath;\n        }\n    }\n    /**\n     * 関数を追加する\n     * @param {string} key 関数名\n     * @param {string[][]} josi 助詞\n     * @param {Function} fn 関数\n     * @param {boolean} returnNone 値を返す関数の場合はfalseを指定\n     * @param {boolean} asyncFn Promiseを返す関数かを指定\n     */\n    addFunc(key, josi, fn, returnNone = true, asyncFn = false) {\n        this.funclist[key] = { josi, fn, type: 'func', return_none: returnNone, asyncFn };\n        this.pluginFunclist[key] = cloneAsJSON(this.funclist[key]);\n        this.__varslist[0][key] = fn;\n    }\n    // (非推奨) 互換性のため ... 関数を追加する\n    setFunc(key, josi, fn, returnNone = true, asyncFn = false) {\n        this.addFunc(key, josi, fn, returnNone, asyncFn);\n    }\n    /**\n     * プラグイン関数を参照する\n     * @param key プラグイン関数の関数名\n     * @returns プラグイン・オブジェクト\n     */\n    getFunc(key) {\n        return this.funclist[key];\n    }\n    /** (非推奨) 同期的になでしこのプログラムcodeを実行する */\n    _runEx(code, filename, opts, preCode = '', nakoGlobal = undefined) {\n        // コンパイル\n        opts.preCode = preCode;\n        if (nakoGlobal) {\n            opts.nakoGlobal = nakoGlobal;\n        }\n        return this.runSync(code, filename, opts);\n    }\n    /** (非推奨) 同期的に実行\n     * @param code\n     * @param fname\n     * @param opts\n     * @param [preCode]\n     */\n    runEx(code, fname, opts, preCode = '') {\n        return this._runEx(code, fname, opts, preCode);\n    }\n    /**\n     * (非推奨) なでしこのプログラムを実行（他に実行しているインスタンスもリセットする)\n     * @param code\n     * @param fname\n     * @param [preCode]\n     */\n    async runReset(code, fname = 'main.nako3', preCode = '') {\n        const opts = newCompilerOptions({ resetAll: true, resetEnv: true });\n        return this._runEx(code, fname, opts, preCode);\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako3.mjs?")},"./core/src/nako_colors.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoColors\": function() { return /* binding */ NakoColors; }\n/* harmony export */ });\n/**\n * ブラウザとNode.jsでテキストへの色付けを共通化するためのコード\n */\n/**\n * ANSI escape code の一部\n */\nconst color = { reset: '\\x1b[0m', bold: '\\x1b[1m', black: '\\x1b[30m', red: '\\x1b[31m', green: '\\x1b[32m', yellow: '\\x1b[33m', blue: '\\x1b[34m', magenta: '\\x1b[35m', cyan: '\\x1b[36m', white: '\\x1b[37m' };\n// 30 ~ 37\nconst colorNames = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];\n/** @param {string} t */\nconst escapeHTML = (t) => t.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;');\n/**\n * ANSI escape code で色付けしたテキストを、HTMLやブラウザのconsole.log用のフォーマットに変換する。\n * たとえば `convertColorTextFormat(`foo${color.red}bar`).html` で `\"foobar\"` の `\"bar\"` の部分が赤く表示されるHTMLを取得できる。\n * @param {string} text\n * @returns {{ nodeConsole: string, noColor: string, html: string, browserConsole: string[] }}\n */\nconst convertColorTextFormat = (text) => {\n    // textから [ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code) を削除して、色の無いテキストを作る。\n    // eslint-disable-next-line no-control-regex\n    const noColor = text.replace(/\\x1b\\[\\d+m/g, '');\n    // nodeConsoleからbrowserConsoleを作る\n    /** @type {string[]} */\n    const browserConsoleStyles = [];\n    let consoleColor = 'inherit'; // 文字色\n    let consoleFontWeight = 'inherit'; // 文字の太さ\n    // /\\x1b\\[(\\d+)m/ で正規表現マッチし、それぞれを %c で置換すると同時に browserConsoleStyles にCSSでの表現をpushする。\n    // console.log(browserConsoleText, ...browserConsoleStyles) で表示することを想定。\n    const browserConsoleText = text === noColor\n        ? noColor\n        // eslint-disable-next-line no-control-regex\n        : text.replace(/\\x1b\\[(\\d+)m/g, (_, m1str) => {\n            const m1 = +m1str;\n            if (m1 === 0) {\n                consoleColor = 'inherit';\n                consoleFontWeight = 'inherit';\n            }\n            if (m1 === 1) {\n                consoleFontWeight = 'bold';\n            }\n            if (m1 >= 30 && m1 <= 37) {\n                consoleColor = colorNames[m1 - 30];\n            }\n            browserConsoleStyles.push(`color: ${consoleColor}; font-weight: ${consoleFontWeight};`);\n            return '%c';\n        });\n    // nodeConsoleからhtmlを作る\n    let htmlColor = 'inherit'; // 文字色\n    let htmlFontWeight = 'inherit'; // 文字の太さ\n    // textが色情報を含まないならそれをそのまま使い、含むなら全体を <span>で囲んで、更に、ANSI escape code で囲まれた部分を対応する style を付けた <span> で囲む。\n    // eslint-disable-next-line multiline-ternary\n    const html = text === noColor ? noColor : ('<span>' + escapeHTML(text)\n        // eslint-disable-next-line no-control-regex\n        .replace(/\\x1b\\[(\\d+)m/g, (_, m1str) => {\n        const m1 = +m1str;\n        if (m1 === 0) { // リセット\n            htmlColor = 'inherit';\n            htmlFontWeight = 'inherit';\n        }\n        if (m1 === 1) { // 太字化\n            htmlFontWeight = 'bold';\n        }\n        if (m1 >= 30 && m1 <= 37) { // 文字色の変更\n            htmlColor = colorNames[m1 - 30];\n        }\n        return `</span><span style=\"color: ${htmlColor}; font-weight: ${htmlFontWeight};\">`;\n    }) + '</span>');\n    // 各表現を返す。\n    return {\n        noColor,\n        nodeConsole: text === noColor\n            ? noColor // textが色の情報を含まないならnoColorを返す。\n            : text + '\\x1b[0m',\n        html,\n        browserConsole: [browserConsoleText, ...browserConsoleStyles]\n    };\n};\nconst NakoColors = { convertColorTextFormat, colorNames, color };\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_colors.mjs?")},"./core/src/nako_core_version.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// 実際のバージョン定義 (自動生成されるので以下を編集しない)\nconst coreVersion = {\n    version: '3.3.52',\n    major: 3,\n    minor: 3,\n    patch: 52\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (coreVersion);\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_core_version.mjs?")},"./core/src/nako_csv.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"options\": function() { return /* binding */ options; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse; },\n/* harmony export */   \"replaceEolMark\": function() { return /* binding */ replaceEolMark; },\n/* harmony export */   \"resetEnv\": function() { return /* binding */ resetEnv; },\n/* harmony export */   \"stringify\": function() { return /* binding */ stringify; }\n/* harmony export */ });\nconst options = {\n    delimiter: ',',\n    eol: '\\r\\n'\n};\nfunction resetEnv() {\n    options.delimiter = ',';\n    options.eol = '\\r\\n';\n}\nfunction parse(txt, delimiter = undefined) {\n    // delimiter\n    if (delimiter === undefined) {\n        delimiter = options.delimiter;\n    }\n    // check txt\n    txt = '' + txt + '\\n';\n    // convert CRLF to LF, and CR to LF\n    txt = txt.replace(/(\\r\\n|\\r)/g, '\\n');\n    // trim right\n    txt = txt.replace(/\\s+$/, '') + '\\n';\n    // set pattern\n    const patToDelim = '^(.*?)([\\\\' + delimiter + '\\\\n])';\n    const reToDelim = new RegExp(patToDelim);\n    // if value is number then convert to float\n    const convType = function (v) {\n        if (typeof (v) === 'string') {\n            if (v.search(/^[0-9.]+$/) >= 0) {\n                v = parseFloat(v); // convert number\n            }\n        }\n        return v;\n    };\n    // parse txt\n    const res = [];\n    let cells = [];\n    let c = '';\n    while (txt !== '') {\n        // first check delimiter (because /^\\s+/ skip delimiter'\\t') (#3)\n        c = txt.charAt(0);\n        if (c === delimiter) {\n            txt = txt.substring(1);\n            cells.push('');\n            continue;\n        }\n        // second check LF (#7)\n        if (c === '\\n') {\n            cells.push('');\n            res.push(cells);\n            cells = [];\n            txt = txt.substring(1);\n            continue;\n        }\n        // trim white space\n        txt = txt.replace(/^\\s+/, '');\n        c = txt.charAt(0);\n        // no data\n        if (c === delimiter) {\n            console.log('delimiter');\n            cells.push('');\n            txt = txt.substring(delimiter.length);\n            continue;\n        }\n        // written using the dialect of Excel\n        if (c === '=' && txt.charAt(1) === '\"') {\n            txt = txt.substring(1);\n            continue;\n        }\n        // number or simple string\n        if (c !== '\"') { // number or simple str\n            const m = reToDelim.exec(txt);\n            if (!m) {\n                cells.push(convType(txt));\n                res.push(cells);\n                cells = [];\n                break;\n            }\n            if (m[2] === '\\n') {\n                cells.push(convType(m[1]));\n                res.push(cells);\n                cells = [];\n            }\n            else if (m[2] === delimiter) {\n                cells.push(convType(m[1]));\n            }\n            txt = txt.substring(m[0].length);\n            continue;\n        }\n        // \"\" ... blank data\n        if (txt.substring(0, 2) === '\"\"') {\n            cells.push('');\n            txt = txt.substring(2);\n            continue;\n        }\n        // \"...\"\n        let i = 1;\n        let s = '';\n        while (i < txt.length) {\n            const c1 = txt.charAt(i);\n            const c2 = txt.charAt(i + 1);\n            // console.log(\"@\" + c1 + c2);\n            // 2quote => 1quote char\n            if (c1 === '\"' && c2 === '\"') {\n                i += 2;\n                s += '\"';\n                continue;\n            }\n            if (c1 === '\"') {\n                i++;\n                if (c2 === delimiter) {\n                    i++;\n                    cells.push(convType(s));\n                    s = '';\n                    break;\n                }\n                if (c2 === '\\n') {\n                    i++;\n                    cells.push(convType(s));\n                    res.push(cells);\n                    cells = [];\n                    break;\n                }\n                // if (c2 === \" \" || c2 === \"\\t\") {\n                i++;\n                continue;\n            }\n            s += c1;\n            i++;\n        }\n        txt = txt.substr(i);\n    }\n    if (cells.length > 0)\n        res.push(cells);\n    return res;\n}\nfunction stringify(ary, delimiter = undefined, eol = undefined) {\n    // check arguments\n    if (delimiter === undefined) {\n        delimiter = options.delimiter;\n    }\n    if (eol === undefined) {\n        eol = options.eol;\n    }\n    const valueConv = genValueConverter(delimiter);\n    if (ary === undefined)\n        return '';\n    let r = '';\n    for (let i = 0; i < ary.length; i++) {\n        const cells = ary[i];\n        if (cells === undefined) {\n            r += eol;\n            continue;\n        }\n        for (let j = 0; j < cells.length; j++) {\n            cells[j] = valueConv(cells[j]);\n        }\n        r += cells.join(delimiter) + eol;\n    }\n    // replace return code\n    r = r.replace(/(\\r\\n|\\r|\\n)/g, eol);\n    return r;\n}\nfunction replaceEolMark(eol) {\n    eol = eol.replace(/\\n\\r/g, '[CRLF]');\n    eol = eol.replace(/\\r/g, '[CR]');\n    eol = eol.replace(/\\n/g, '[LF]');\n    return eol;\n}\nfunction genValueConverter(delimiter) {\n    return function (s) {\n        s = '' + s;\n        let fQuot = false;\n        if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0) {\n            fQuot = true;\n        }\n        if (s.indexOf(delimiter) >= 0) {\n            fQuot = true;\n        }\n        if (s.indexOf('\"') >= 0) {\n            fQuot = true;\n            s = s.replace(/\"/g, '\"\"');\n        }\n        if (fQuot)\n            s = '\"' + s + '\"';\n        return s;\n    };\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_csv.mjs?")},"./core/src/nako_errors.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InternalLexerError\": function() { return /* binding */ InternalLexerError; },\n/* harmony export */   \"NakoError\": function() { return /* binding */ NakoError; },\n/* harmony export */   \"NakoImportError\": function() { return /* binding */ NakoImportError; },\n/* harmony export */   \"NakoIndentError\": function() { return /* binding */ NakoIndentError; },\n/* harmony export */   \"NakoLexerError\": function() { return /* binding */ NakoLexerError; },\n/* harmony export */   \"NakoRuntimeError\": function() { return /* binding */ NakoRuntimeError; },\n/* harmony export */   \"NakoSyntaxError\": function() { return /* binding */ NakoSyntaxError; }\n/* harmony export */ });\n/* harmony import */ var _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_core_version.mjs */ \"./core/src/nako_core_version.mjs\");\n\n/**\n * なでしこ言語が投げる全てのエラーが継承するクラス\n */\nclass NakoError extends Error {\n    /**\n     * @param {string} tag\n     * @param {string} msg\n     * @param {string | undefined} file\n     * @param {number | undefined} line\n     */\n    constructor(tag, msg, file = undefined, line = undefined) {\n        // エラー位置を分かりやすく日本語に変換\n        const positionJa = `${file || ''}${line === undefined ? '' : `(${line + 1}行目): `}`;\n        // #1223 エラーメッセージに「main__関数名」と表示されるので、main__は省略して表示\n        msg = msg.replace(/『main__(.+?)』/g, '『$1』');\n        // 親のErrorを呼ぶ\n        super(`[${tag}]${positionJa}${msg}\\n[バージョン] ${_nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].version}`);\n        // エラーの種類を設定\n        this.name = 'NakoError';\n        this.type = 'NakoError';\n        this.tag = '[' + tag + ']';\n        this.positionJa = positionJa;\n        this.msg = msg;\n    }\n}\nclass NakoIndentError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number} line\n     * @param {string} file\n     */\n    constructor(msg, line, file) {\n        super('インデントエラー', msg, file, line);\n        this.type = 'NakoIndentError';\n        this.line = line;\n        this.file = file;\n    }\n}\n// コンパイラの内部でのみ使うエラー。投げられたらtryでキャッチしてLexerErrorへ変更する。\nclass InternalLexerError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number} preprocessedCodeStartOffset\n     * @param {number} preprocessedCodeEndOffset\n     * @param {number | undefined} [line]\n     * @param {string | undefined} [file]\n     */\n    constructor(msg, preprocessedCodeStartOffset, preprocessedCodeEndOffset, line, file) {\n        super('字句解析エラー（内部エラー）', msg, file, line);\n        this.type = 'InternalLexerError';\n        this.preprocessedCodeStartOffset = preprocessedCodeStartOffset;\n        this.preprocessedCodeEndOffset = preprocessedCodeEndOffset;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoLexerError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number | null} startOffset\n     * @param {number | null} endOffset,\n     * @param {number | undefined} line\n     * @param {string | undefined} file\n     */\n    constructor(msg, startOffset, endOffset, line, file) {\n        super('字句解析エラー', msg, file, line);\n        this.type = 'NakoLexerError';\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoSyntaxError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number | undefined} line\n     * @param {number | undefined} startOffset\n     * @param {number | undefined} endOffset\n     * @param {string | undefined} file\n     */\n    constructor(msg, line, startOffset, endOffset, file) {\n        super('文法エラー', msg, file, line);\n        this.type = 'NakoSyntaxError';\n        this.file = file;\n        this.line = line;\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n    }\n    /**\n     * @param {string} msg\n     * @param {Ast} first\n     * @param {Ast} [last]\n     */\n    static fromNode(msg, first, last = undefined) {\n        if (!first) {\n            return new NakoSyntaxError(msg, undefined, undefined, undefined, undefined);\n        }\n        const startOffset = typeof first.startOffset === 'number' ? first.startOffset : undefined;\n        const endOffset = (last && typeof last.endOffset === 'number')\n            ? last.endOffset\n            : (typeof first.endOffset === 'number' ? first.endOffset : undefined);\n        return new NakoSyntaxError(msg, first.line, startOffset, endOffset, first.file);\n    }\n}\nclass NakoRuntimeError extends NakoError {\n    /**\n     * @param error エラー\n     * @param lineNo 発生行\n     */\n    constructor(error, lineNo) {\n        let msg = 'unknown';\n        if (typeof error === 'string') {\n            msg = error;\n        }\n        else {\n            if (error instanceof NakoRuntimeError) {\n                msg = error.msg;\n            }\n            else if (error instanceof NakoError) {\n                msg = error.msg;\n            }\n            else if (error instanceof Error) {\n                if (error.name === 'Error') {\n                    msg = error.message;\n                }\n                else {\n                    msg = `${error.name}: ${error.message}`;\n                }\n            }\n        }\n        // 行番号を表す文字列をパースする。\n        let line;\n        let file;\n        let matches;\n        if (lineNo === undefined) {\n            line = undefined;\n            file = undefined;\n            // eslint-disable-next-line no-cond-assign\n        }\n        else if (matches = /^l(-?\\d+):(.*)$/.exec(lineNo)) {\n            line = parseInt(matches[1]);\n            file = matches[2];\n            // eslint-disable-next-line no-cond-assign\n        }\n        else if (matches = /^l(-?\\d+)$/.exec(lineNo)) {\n            line = parseInt(matches[1]);\n            file = 'main.nako3';\n        }\n        else {\n            line = 0;\n            file = lineNo;\n        }\n        super('実行時エラー', msg, file, line);\n        this.type = 'NakoRuntimeError';\n        this.lineNo = lineNo;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoImportError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {string} file\n     * @param {number} line\n     */\n    constructor(msg, file, line) {\n        super('取り込みエラー', msg, file, line);\n        this.file = file;\n        this.line = line;\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_errors.mjs?")},"./core/src/nako_from_dncl.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoDncl\": function() { return /* binding */ NakoDncl; },\n/* harmony export */   \"convertDNCL\": function() { return /* binding */ convertDNCL; }\n/* harmony export */ });\n/* harmony import */ var _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_prepare.mjs */ \"./core/src/nako_prepare.mjs\");\n/**\n * DNCLに対応する構文\n */\n// import { NakoIndentError } from './nako_errors.mjs'\n\n// DNCLモードのキーワード\nconst DNCL_KEYWORDS = ['!DNCLモード'];\n/**\n * DNCLのソースコードをなでしこに変換する\n * @param {String} src\n * @param {String} filename\n * @returns {String} converted soruce\n */\nfunction convertDNCL(src, filename) {\n    // 改行を合わせる\n    src = src.replace(/(\\r\\n|\\r)/g, '\\n');\n    // 「!DNCLモード」を使うかチェック\n    if (!(0,_nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_0__.checkNakoMode)(src, DNCL_KEYWORDS)) {\n        return src;\n    }\n    const result = dncl2nako(src, filename);\n    // console.log(\"=====\\n\" + result)\n    // process.exit()\n    return result;\n}\n/**\n * make space string\n * @param {number} n\n */\nfunction makeSpaces(n) {\n    let s = '';\n    for (let i = 0; i < n; i++) {\n        s += ' ';\n    }\n    return s;\n}\n/**\n * DNCLからなでしこに変換する(判定なし)\n * @param {string} src\n * @param {string} filename\n * @returns {string} converted source\n */\nfunction dncl2nako(src, filename) {\n    // 全角半角を統一\n    src = conv2half(src);\n    // 行頭の「|」はインデントを表す記号なので無視する\n    // 後判定の「繰り返し,」を「後判定で繰り返す」に置換する\n    const a = src.split('\\n');\n    for (let i = 0; i < a.length; i++) {\n        // インデントを消す\n        let line = a[i];\n        a[i] = line.replace(/^(\\s*[|\\s]+)(.*$)/, (m0, m1, m2) => {\n            return makeSpaces(m1.length) + m2;\n        });\n        line = a[i];\n        // 後判定の繰り返しの実装のため\n        const line2 = line.replace(/^\\s+/, '').replace(/\\s+$/, '');\n        if (line2 === '繰り返し,' || line2 === '繰り返し') {\n            a[i] = '後判定で繰り返し';\n        }\n        const r = line.match(/^\\s*を,?(.+)になるまで(繰り返す|実行する)/);\n        if (r) {\n            a[i] = `ここまで、(${r[1]})になるまでの間`;\n            continue;\n        }\n        // 『もしj>hakosuならばhakosu←jを実行する』のような単文のもし文\n        const rif = line.match(/^もし(.+)を実行する(。|．)*/);\n        if (rif) {\n            const sent = dncl2nako(rif[1], filename);\n            a[i] = `もし、${sent};`;\n            continue;\n        }\n        // 'のすべての値を0にする'\n        // 'のすべての要素を0にする'\n        // 'のすべての要素に0を代入する'\n        const rall = line.match(/^(.+?)のすべての(要素|値)(を|に)(.+?)(にする|を代入)/);\n        if (rall) {\n            const varname = rall[1];\n            const v = rall[4];\n            a[i] = `${varname} = [${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v},${v}]`;\n            continue;\n        }\n    }\n    src = a.join('\\n');\n    // ---------------------------------\n    // 置換開始\n    // ---------------------------------\n    // 単純置換リスト\n    const simpleConvList = {\n        'を実行する': 'ここまで',\n        'を実行し,そうでなくもし': '違えば、もし',\n        'を実行し，そうでなくもし': '違えば、もし',\n        'を実行し、そうでなくもし': '違えば、もし',\n        'を実行し,そうでなければ': '違えば',\n        'を実行し，そうでなければ': '違えば',\n        'を実行し、そうでなければ': '違えば',\n        'を繰り返す': 'ここまで',\n        '改行なしで表示': '連続無改行表示',\n        'ずつ増やしながら': 'ずつ増やし繰り返す',\n        'ずつ減らしながら': 'ずつ減らし繰り返す',\n        '二進で表示': '二進表示',\n        'でないならば': 'でなければ'\n    };\n    const nextChar = () => {\n        const ch = src.charAt(0);\n        src = src.substring(1);\n        return ch;\n    };\n    // 文字列を判定するフラグ\n    let flagStr = false;\n    let poolStr = '';\n    let endStr = '';\n    // 結果\n    let result = '';\n    while (src !== '') {\n        // 代入記号を変更\n        const ch = src.charAt(0);\n        if (flagStr) {\n            if (ch === endStr) {\n                result += poolStr + endStr;\n                poolStr = '';\n                flagStr = false;\n                nextChar();\n                continue;\n            }\n            poolStr += nextChar();\n            continue;\n        }\n        // 文字列？\n        if (ch === '\"') {\n            flagStr = true;\n            endStr = '\"';\n            poolStr = nextChar();\n            continue;\n        }\n        if (ch === '「') {\n            flagStr = true;\n            endStr = '」';\n            poolStr = nextChar();\n            continue;\n        }\n        if (ch === '『') {\n            flagStr = true;\n            endStr = '』';\n            poolStr = nextChar();\n            continue;\n        }\n        // 空白を飛ばす\n        if (ch === ' ' || ch === '　' || ch === '\\t') {\n            result += nextChar();\n            continue;\n        }\n        // 表示を連続表示に置き換える\n        const ch3 = src.substring(0, 3);\n        if (ch3 === 'を表示') {\n            result += 'を連続表示';\n            src = src.substring(3);\n            continue;\n        }\n        if (src.substring(0, 4) === 'を 表示') {\n            result += 'を連続表示';\n            src = src.substring(4);\n            continue;\n        }\n        // 乱数を乱数範囲に置き換える\n        if (src.substring(0, 2) === '乱数' && src.substring(0, 4) !== '乱数範囲') {\n            result += '乱数範囲';\n            src = src.substring(2);\n            continue;\n        }\n        // 増やす・減らすの前に「だけ」を追加する #1149\n        if (ch3 === '増やす' || ch3 === '減らす') {\n            if (result.substring(result.length - 2) !== 'だけ') {\n                result += 'だけ';\n            }\n            result += ch3;\n            src = src.substring(3);\n        }\n        // 一覧から単純な変換\n        let flag = false;\n        for (const key in simpleConvList) {\n            const srcKey = src.substring(0, key.length);\n            if (srcKey === key) {\n                result += simpleConvList[key];\n                src = src.substring(key.length);\n                flag = true;\n                break;\n            }\n        }\n        if (flag) {\n            continue;\n        }\n        // 1文字削る\n        result += nextChar();\n    }\n    return result;\n}\n/**\n * 半角に変換\n * @param {String} src\n * @returns {string} converted source\n */\nfunction conv2half(src) {\n    const prepare = _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoPrepare.getInstance(); // `※`, `／/`, `／＊` といったパターン全てに対応するために必要\n    // 全角半角の統一\n    let result = '';\n    let flagStr = false;\n    let flagStrClose = '';\n    for (let i = 0; i < src.length; i++) {\n        const c = src.charAt(i);\n        let cHalf = prepare.convert1ch(c);\n        if (flagStr) {\n            if (cHalf === flagStrClose) {\n                flagStr = false;\n                flagStrClose = '';\n                result += cHalf;\n                continue;\n            }\n            result += c;\n            continue;\n        }\n        if (cHalf === '「') {\n            flagStr = true;\n            flagStrClose = '」';\n            result += cHalf;\n            continue;\n        }\n        if (cHalf === '\"') {\n            flagStr = true;\n            flagStrClose = '\"';\n            result += cHalf;\n            continue;\n        }\n        // 単純な置き換えはここでやってしまう\n        // 配列記号の { ... } を [ ... ] に置換\n        if (cHalf === '{') {\n            cHalf = '[';\n        }\n        if (cHalf === '}') {\n            cHalf = ']';\n        }\n        if (cHalf === '←') {\n            cHalf = '=';\n        }\n        if (cHalf === '÷') {\n            cHalf = '÷÷';\n        } // #1152\n        result += cHalf;\n    }\n    return result;\n}\n/** @type {Object} */\nconst NakoDncl = {\n    convert: convertDNCL\n};\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_from_dncl.mjs?")},"./core/src/nako_gen.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoGen\": function() { return /* binding */ NakoGen; },\n/* harmony export */   \"NakoGenOptions\": function() { return /* binding */ NakoGenOptions; },\n/* harmony export */   \"generateJS\": function() { return /* binding */ generateJS; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_lexer.mjs */ \"./core/src/nako_lexer.mjs\");\n/**\n * パーサーが生成した中間オブジェクトを実際のJavaScriptのコードに変換する。\n * なお速度優先で忠実にJavaScriptのコードを生成する。\n */\n\n\n// なでしこで定義した関数の開始コードと終了コード\nconst topOfFunction = '(function(){\\n';\nconst endOfFunction = '})';\nconst topOfFunctionAsync = '(async function(){\\n';\n/** コード生成オプション */\nclass NakoGenOptions {\n    constructor(isTest = false, importFiles = [], codeStandalone = '', convEnv = '') {\n        this.isTest = isTest;\n        this.codeStandalone = codeStandalone;\n        this.codeEnv = convEnv;\n        this.importFiles = ['plugin_system.mjs', 'plugin_math.mjs', 'plugin_csv.mjs', 'plugin_promise.mjs', 'plugin_test.mjs'];\n        for (const fname of importFiles) {\n            this.importFiles.push(fname);\n        }\n    }\n}\n/**\n * 構文木からJSのコードを生成するクラス\n */\nclass NakoGen {\n    /** constructor\n     * @param com コンパイラのインスタンス\n     */\n    constructor(com) {\n        /**\n         * 出力するJavaScriptコードのヘッダー部分で定義する必要のある関数。fnはjsのコード。\n         * プラグイン関数は含まれない。\n         */\n        this.nakoFuncList = { ...com.getNakoFuncList() };\n        /**\n         * なでしこで定義したテストの一覧\n         */\n        this.nakoTestFuncs = {};\n        /**\n         * プログラム内で参照された関数のリスト。プラグインの命令を含む。\n         * JavaScript単体で実行するとき、このリストにある関数の定義をJavaScriptコードの先頭に付け足す。\n         */\n        this.usedFuncSet = new Set();\n        /**\n         * ループ時の一時変数が被らないようにIDで管理\n         */\n        this.loopId = 1;\n        /**\n         * 非同関数を何回使ったか\n         */\n        this.numAsyncFn = 0;\n        /**\n         * 関数定義の際、関数の中でasyncFn=trueの関数を呼び出したかどうかを調べる @see convDefFuncCommon\n         */\n        this.usedAsyncFn = false;\n        /** 変換中の処理が、ループの中かどうかを判定する */\n        this.flagLoop = false;\n        this.__self = com;\n        /** コードジェネレータの種類 */\n        this.genMode = 'sync';\n        /** 行番号とファイル名が分かるときは `l123:main.nako3`、行番号だけ分かるときは `l123`、そうでなければ任意の文字列。 */\n        this.lastLineNo = null;\n        /** スタック */\n        this.varslistSet = com.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        /** スタックトップ */\n        this.varsSet = { isFunction: false, names: new Set(), readonly: new Set() };\n        this.varslistSet[2] = this.varsSet;\n        // 1以上のとき高速化する。\n        // 実行速度優先ブロック内で1増える。\n        this.speedMode = {\n            lineNumbers: 0,\n            implicitTypeCasting: 0,\n            invalidSore: 0,\n            forcePure: 0 // 全てのシステム命令をpureとして扱う。命令からローカル変数への参照が出来なくなる。\n        };\n        // 1以上のとき測定をinjectする。\n        // パフォーマンスモニタのブロック内で1増える。\n        this.performanceMonitor = {\n            userFunction: 0,\n            systemFunction: 0,\n            systemFunctionBody: 0,\n            mumeiId: 0\n        };\n        /**\n         * 未定義の変数の警告を行う\n         */\n        this.warnUndefinedVar = true;\n        // 暫定変数\n        this.warnUndefinedReturnUserFunc = 1;\n        this.warnUndefinedCallingUserFunc = 1;\n        this.warnUndefinedCallingSystemFunc = 1;\n        this.warnUndefinedCalledUserFuncArgs = 1;\n    }\n    static isValidIdentifier(name) {\n        // TODO: いらなそうな部分は削る\n        // https://stackoverflow.com/a/9337047\n        // eslint-disable-next-line no-misleading-character-class\n        return /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/.test(name);\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} forceUpdate\n     */\n    convLineno(node, forceUpdate = false) {\n        if (this.speedMode.lineNumbers > 0) {\n            return '';\n        }\n        let lineNo;\n        if (typeof node.line !== 'number') {\n            lineNo = 'unknown';\n        }\n        else if (typeof node.file !== 'string') {\n            lineNo = `l${node.line}`;\n        }\n        else {\n            lineNo = `l${node.line}:${node.file}`;\n        }\n        // 強制的に行番号をアップデートするか\n        if (!forceUpdate) {\n            if (lineNo === this.lastLineNo) {\n                return '';\n            }\n            this.lastLineNo = lineNo;\n        }\n        // 例: __v0.line='l1:main.nako3'\n        return `__v0.line=${JSON.stringify(lineNo)};`;\n    }\n    /**\n     * ローカル変数のJavaScriptコードを生成する。\n     * @param {string} name\n     */\n    varname(name) {\n        if (this.varslistSet.length === 3) {\n            // グローバル\n            return `__varslist[${2}][${JSON.stringify(name)}]`;\n        }\n        else {\n            // 関数内\n            if (NakoGen.isValidIdentifier(name)) {\n                return name;\n            }\n            else {\n                return `__vars[${JSON.stringify(name)}]`;\n            }\n        }\n    }\n    /**\n     * @param {string} name\n     * @returns {string}\n    */\n    static getFuncName(name) {\n        if (name.indexOf('__') >= 0) { // スコープがある場合\n            const a = name.split('__');\n            const scope = a[0];\n            const name3 = NakoGen.getFuncName(a[1]);\n            return `${scope}__${name3}`;\n        }\n        let name2 = name.replace(/[ぁ-ん]+$/, '');\n        if (name2 === '') {\n            name2 = name;\n        }\n        return name2;\n    }\n    /** @param {Ast} node */\n    static convPrint(node) {\n        return `__print(${node});`;\n    }\n    /** @param {Ast} node */\n    convRequire(node) {\n        const moduleName = node.value;\n        return this.convLineno(node, false) +\n            `__module['${moduleName}'] = require('${moduleName}');\\n`;\n    }\n    /**\n     * プログラムの実行に必要な関数定義を書き出す(グローバル領域)\n     * convGenの結果を利用するため、convGenの後に呼び出すこと。\n     * @param com\n     * @param opt\n     */\n    getDefFuncCode(com, opt) {\n        let code = '';\n        // よく使う変数のショートカット\n        code += `const nakoVersion = { version: ${JSON.stringify(com.version)} }\\n`;\n        code += 'const __self = self;\\n';\n        code += 'self.__self = self;\\n';\n        code += 'const __varslist = self.__varslist;\\n';\n        code += 'const __module = self.__module;\\n';\n        code += 'const __v0 = self.__v0 = self.__varslist[0];\\n';\n        code += 'const __v1 = self.__v1 = self.__varslist[1];\\n';\n        code += 'const __vars = self.__vars = self.__varslist[2];\\n';\n        // なでしこの関数定義を行う\n        let nakoFuncCode = '';\n        for (const key in this.nakoFuncList) {\n            const f = this.nakoFuncList[key].fn;\n            const isAsync = this.nakoFuncList[key].asyncFn ? 'true' : 'false';\n            nakoFuncCode += '' +\n                `//[DEF_FUNC name='${key}' asyncFn=${isAsync}]\\n` +\n                `self.__varslist[1][\"${key}\"]=${f};\\n;` +\n                `//[/DEF_FUNC name='${key}']\\n`;\n        }\n        if (nakoFuncCode !== '') {\n            code += '__v0.line=\\'関数の定義\\';\\n' + nakoFuncCode;\n        }\n        // テストの定義を行う\n        if (opt.isTest) {\n            let testCode = 'const __tests = [];\\n';\n            for (const key in this.nakoTestFuncs) {\n                const f = this.nakoTestFuncs[key].fn;\n                testCode += `${f};\\n;`;\n            }\n            if (testCode !== '') {\n                code += '__v0.line=\\'テストの定義\\';\\n';\n                code += testCode + '\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プラグイン・オブジェクトを追加\n     * @param po プラグイン・オブジェクト\n     */\n    addPlugin(po) {\n        return this.__self.addPlugin(po);\n    }\n    /**\n     * プラグイン・オブジェクトを追加(ブラウザ向け)\n     * @param name オブジェクト名\n     * @param po 関数リスト\n     */\n    addPluginObject(name, po) {\n        this.__self.addPluginObject(name, po);\n    }\n    /**\n     * プラグイン・ファイルを追加(Node.js向け)\n     * @param objName オブジェクト名\n     * @param path ファイルパス\n     * @param po 登録するオブジェクト\n     */\n    addPluginFile(objName, path, po) {\n        this.__self.addPluginFile(objName, path, po);\n    }\n    /**\n     * 関数を追加する\n     * @param key 関数名\n     * @param josi 助詞\n     * @param fn 関数\n     */\n    addFunc(key, josi, fn) {\n        this.__self.addFunc(key, josi, fn);\n    }\n    /**\n     * プラグイン関数を参照する\n     * @param key プラグイン関数の関数名\n     * @returns プラグイン・オブジェクト\n     */\n    getFunc(key) {\n        return this.__self.getFunc(key);\n    }\n    /**\n     * 関数を先に登録してしまう\n     */\n    registerFunction(ast) {\n        if (ast.type !== 'block') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('構文解析に失敗しています。構文は必ずblockが先頭になります', ast);\n        }\n        /** 関数一覧 */\n        const funcList = [];\n        // なでしこ関数を定義して this.nako_func[name] に定義する\n        const registFunc = (node) => {\n            if (!node.block) {\n                return;\n            }\n            const blockList = (node.block instanceof Array) ? node.block : [node.block];\n            for (let i = 0; i < blockList.length; i++) {\n                const t = blockList[i];\n                if (t.type === 'def_func') {\n                    if (!t.name) {\n                        throw new Error('[System Error] 関数の定義で関数名が指定されていない');\n                    }\n                    const name = t.name.value;\n                    this.usedFuncSet.add(name);\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    this.__self.__varslist[1][name] = function () { }; // 事前に適当な値を設定\n                    this.varslistSet[1].names.add(name); // global\n                    const meta = (t.name).meta; // todo: 強制変換したが正しいかチェック\n                    this.nakoFuncList[name] = {\n                        josi: meta.josi,\n                        // eslint-disable-next-line @typescript-eslint/no-empty-function\n                        fn: () => { },\n                        type: 'func',\n                        asyncFn: t.asyncFn\n                    };\n                    funcList.push({ name, node: t });\n                    // eslint-disable-next-line brace-style\n                }\n                // 実行速度優先 などのオプションが付いている場合の処理\n                else if (t.type === 'speed_mode') {\n                    if (!t.block) {\n                        continue;\n                    }\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n                else if (t.type === 'performance_monitor') {\n                    if (!t.block) {\n                        continue;\n                    }\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n            }\n        };\n        // 関数の登録\n        registFunc(ast);\n        // __self.__varslistの変更を反映\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: false, names: initialNames, readonly: new Set() };\n        this.varslistSet = this.__self.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        this.varslistSet[2] = this.varsSet;\n    }\n    /**\n     * @param node\n     * @param opt\n     */\n    convGen(node, opt) {\n        const result = this.convLineno(node, false) + this._convGen(node, true);\n        if (opt.isTest) {\n            return '';\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    _convGen(node, isExpression) {\n        if (!node) {\n            return '';\n        }\n        let code = '';\n        if (node instanceof Array) {\n            for (let i = 0; i < node.length; i++) {\n                const n = node[i];\n                code += this._convGen(n, isExpression);\n            }\n            return code;\n        }\n        if (node === null) {\n            return 'null';\n        }\n        if (node === undefined) {\n            return 'undefined';\n        }\n        if (typeof (node) !== 'object') {\n            return '' + node;\n        }\n        // switch\n        switch (node.type) {\n            case 'nop':\n                break;\n            case 'block':\n                // eslint-disable-next-line no-case-declarations\n                const modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer.filenameToModName(node.file || '');\n                code += `;__self.__modName='${modName}';\\n`;\n                if (!node.block) {\n                    return code;\n                }\n                // eslint-disable-next-line no-case-declarations\n                const blocks = (node.block instanceof Array) ? node.block : [node.block];\n                for (let i = 0; i < blocks.length; i++) {\n                    const b = blocks[i];\n                    code += this._convGen(b, false);\n                }\n                break;\n            case 'comment':\n            case 'eol':\n                code += this.convComment(node);\n                break;\n            case 'break':\n                code += this.convCheckLoop(node, 'break');\n                break;\n            case 'continue':\n                code += this.convCheckLoop(node, 'continue');\n                break;\n            case 'end':\n                code += '__varslist[0][\\'終\\']();';\n                break;\n            case 'number':\n                code += node.value;\n                break;\n            case 'string':\n                code += this.convString(node);\n                break;\n            case 'def_local_var':\n                code += this.convDefLocalVar(node);\n                break;\n            case 'def_local_varlist':\n                code += this.convDefLocalVarlist(node);\n                break;\n            case 'let':\n                code += this.convLet(node);\n                break;\n            case 'inc':\n                code += this.convInc(node);\n                break;\n            case 'word':\n            case 'variable':\n                code += this.convGetVar(node);\n                break;\n            case 'op':\n            case 'calc':\n                code += this.convOp(node);\n                break;\n            case 'renbun':\n                code += this.convRenbun(node);\n                break;\n            case 'not':\n                code += '((' + this._convGen(node.value, true) + ')?0:1)';\n                break;\n            case 'func':\n            case 'func_pointer':\n            case 'calc_func':\n                code += this.convCallFunc(node, isExpression);\n                break;\n            case 'if':\n                code += this.convIf(node);\n                break;\n            case 'tikuji':\n                code += this.convTikuji(node);\n                break;\n            case 'for':\n                code += this.convFor(node);\n                break;\n            case 'foreach':\n                code += this.convForeach(node);\n                break;\n            case 'repeat_times':\n                code += this.convRepeatTimes(node);\n                break;\n            case 'speed_mode':\n                code += this.convSpeedMode(node, isExpression);\n                break;\n            case 'performance_monitor':\n                code += this.convPerformanceMonitor(node, isExpression);\n                break;\n            case 'while':\n                code += this.convWhile(node);\n                break;\n            case 'atohantei':\n                code += this.convAtohantei(node);\n                break;\n            case 'switch':\n                code += this.convSwitch(node);\n                break;\n            case 'let_array':\n                code += this.convLetArray(node);\n                break;\n            case '配列参照':\n                code += this.convRefArray(node);\n                break;\n            case 'json_array':\n                code += this.convJsonArray(node);\n                break;\n            case 'json_obj':\n                code += this.convJsonObj(node);\n                break;\n            case 'func_obj':\n                code += this.convFuncObj(node);\n                break;\n            case 'bool':\n                code += (node.value) ? 'true' : 'false';\n                break;\n            case 'null':\n                code += 'null';\n                break;\n            case 'def_test':\n                code += this.convDefTest(node);\n                break;\n            case 'def_func':\n                code += this.convDefFunc(node);\n                break;\n            case 'return':\n                code += this.convReturn(node);\n                break;\n            case 'try_except':\n                code += this.convTryExcept(node);\n                break;\n            case 'require':\n                code += this.convRequire(node);\n                break;\n            default:\n                throw new Error('System Error: unknown_type=' + node.type);\n        }\n        return code;\n    }\n    /** 変数を検索 */\n    findVar(name) {\n        // __vars ? (ローカル変数)\n        if (this.varslistSet.length > 3 && this.varsSet.names.has(name)) {\n            return { i: this.varslistSet.length - 1, name, isTop: true, js: this.varname(name) };\n        }\n        // __varslist ?\n        for (let i = 2; i >= 0; i--) {\n            if (this.varslistSet[i].names.has(name)) {\n                // ユーザーの定義したグローバル変数 (__varslist[2]) は、変数展開されている（そのままの名前で定義されている）可能性がある。\n                // それ以外の変数は、必ず__varslistに入っている。\n                return { i, name, isTop: false, js: `__varslist[${i}][${JSON.stringify(name)}]` };\n            }\n        }\n        return null;\n    }\n    /**\n     * 定義済みの変数の参照\n     * @param {string} name\n     * @param {Ast} position\n     */\n    genVar(name, position) {\n        const res = this.findVar(name);\n        const lno = position.line;\n        if (res === null) {\n            // 定義されていない名前の参照は変数の定義とみなす。\n            // 多くの場合はundefined値を持つ変数であり分かりづらいバグを引き起こすが、\n            // 「ナデシコする」などの命令の中で定義された変数の参照の場合があるため警告に留める。\n            // ただし、自動的に定義される変数『引数』『それ』などは例外 #952\n            if (name === '引数' || name === 'それ' || name === '対象' || name === '対象キー') {\n                // デフォルト定義されている変数名\n            }\n            else {\n                if (this.warnUndefinedVar) {\n                    // main__は省略して表示するように。 #1223\n                    const dispName = name.replace(/^main__(.+)$/, '$1');\n                    this.__self.getLogger().warn(`変数『${dispName}』は定義されていません。`, position);\n                }\n            }\n            this.varsSet.names.add(name);\n            return this.varname(name);\n        }\n        const i = res.i;\n        // システム関数・変数の場合\n        if (i === 0) {\n            const pv = this.__self.getNakoFunc(name);\n            if (!pv) {\n                return `${res.js}/*err:${lno}*/`;\n            }\n            if (pv.type === 'const' || pv.type === 'var') {\n                return res.js;\n            }\n            if (pv.type === 'func') {\n                if (!pv.josi || pv.josi.length === 0) {\n                    return `(${res.js}())`;\n                }\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』が複文で使われました。単文で記述してください。(v1非互換)`, position);\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』は関数であり参照できません。`, position);\n        }\n        return res.js;\n    }\n    convGetVar(node) {\n        const name = node.value;\n        return this.genVar(name, node);\n    }\n    convComment(node) {\n        let commentSrc = String(node.value);\n        commentSrc = commentSrc.replace(/\\n/g, '¶');\n        const lineNo = this.convLineno(node, false);\n        if (commentSrc === '' && lineNo === '') {\n            return ';';\n        }\n        if (commentSrc === '') {\n            return ';' + lineNo + '\\n';\n        }\n        return ';' + lineNo + '//' + commentSrc + '\\n';\n    }\n    convReturn(node) {\n        // 関数の中であれば利用可能\n        if (this.varsSet.names.has('!関数')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『戻る』がありますが、関数定義内のみで使用可能です。', node);\n        }\n        const lno = this.convLineno(node, false);\n        let value;\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        else if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        else {\n            return lno + 'return;';\n        }\n        if (this.warnUndefinedReturnUserFunc === 0) {\n            return lno + `return ${value};`;\n        }\n        else {\n            return lno + `return (function(a){if(a===undefined){__self.logger.warn('ユーザ関数からundefinedが返されています',{file:'${node.file}',line:${node.line}});};return a;})(${value});`;\n        }\n    }\n    convCheckLoop(node, cmd) {\n        // ループの中であれば利用可能\n        if (!this.flagLoop) {\n            const cmdj = (cmd === 'continue') ? '続ける' : '抜ける';\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${cmdj}』文がありますが、それは繰り返しの中で利用してください。`, node);\n        }\n        return this.convLineno(node) + cmd + ';';\n    }\n    convDefFuncCommon(node, name) {\n        // パフォーマンスモニタ:ユーザ関数のinjectの定義\n        let performanceMonitorInjectAtStart = '';\n        let performanceMonitorInjectAtEnd = '';\n        if (this.performanceMonitor.userFunction !== 0) {\n            let key = name;\n            if (!key) {\n                if (typeof this.performanceMonitor.mumeiId === 'undefined') {\n                    this.performanceMonitor.mumeiId = 0;\n                }\n                this.performanceMonitor.mumeiId++;\n                key = `anous_${this.performanceMonitor.mumeiId}`;\n            }\n            performanceMonitorInjectAtStart = 'const performanceMonitorEnd = (function (key, type) {\\n' +\n                'const uf_start = performance.now() * 1000;\\n' +\n                'return function () {\\n' +\n                'const el_time = performance.now() * 1000 - uf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: el_time, min_usec: el_time, max_usec: el_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: el_time, min_usec: el_time, max_usec: el_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=el_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>el_time){__self.__performance_monitor[key].min_usec=el_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<el_time){__self.__performance_monitor[key].max_usec=el_time;}\\n' +\n                `}};})('${key}', 'user');` +\n                'try {\\n';\n            performanceMonitorInjectAtEnd = '} finally { performanceMonitorEnd(); }\\n';\n        }\n        let variableDeclarations = '';\n        const popStack = '';\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: true, names: initialNames, readonly: new Set() };\n        // ローカル変数をPUSHする\n        this.varslistSet.push(this.varsSet);\n        // JSの引数と引数をバインド\n        variableDeclarations += '  var 引数 = arguments;\\n';\n        // ローカル変数を生成\n        variableDeclarations += '  var __vars = {};\\n';\n        // 宣言済みの名前を保存\n        const varsDeclared = Array.from(this.varsSet.names.values());\n        let code = '';\n        // 引数をローカル変数に設定\n        const meta = (!name) ? node.meta : node.name.meta;\n        for (let i = 0; i < meta.varnames.length; i++) {\n            const word = meta.varnames[i];\n            if (this.warnUndefinedCalledUserFuncArgs === 0) {\n                code += `  ${this.varname(word)} = arguments[${i}];\\n`;\n            }\n            else if (name) {\n                code += `  ${this.varname(word)} = (function(a){if(a===undefined){__self.logger.warn('ユーザ関数(${name})の引数(${this.varname(word)})にundefinedが渡されました',{file:'${node.file}',line:${node.line}});};return a;})(arguments[${i}]);\\n`;\n            }\n            else {\n                code += `  ${this.varname(word)} = (function(a){if(a===undefined){__self.logger.warn('匿名関数の引数(${this.varname(word)})にundefinedが渡されました',{file:'${node.file}',line:${node.line}});};return a;})(arguments[${i}]);\\n`;\n            }\n            this.varsSet.names.add(word);\n        }\n        // 関数定義は、グローバル領域で。\n        if (name) {\n            this.usedFuncSet.add(name);\n            this.varslistSet[1].names.add(name);\n            if (this.nakoFuncList[name] === undefined) {\n                // 既に generate で作成済みのはず(念のため)\n                this.nakoFuncList[name] = {\n                    josi: node.name.meta.josi,\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    fn: () => { },\n                    type: 'func',\n                    asyncFn: false\n                };\n            }\n        }\n        // ブロックを解析\n        const oldUsedAsyncFn = this.usedAsyncFn;\n        this.usedAsyncFn = false;\n        const block = this._convGen(node.block, false);\n        code += block.split('\\n').map((line) => '  ' + line).join('\\n') + '\\n';\n        // 関数の最後に、変数「それ」をreturnするようにする\n        if (this.speedMode.invalidSore === 0) {\n            code += `  return (${this.varname('それ')});\\n`;\n        }\n        // パフォーマンスモニタ:ユーザ関数のinject\n        code += performanceMonitorInjectAtEnd;\n        // ブロックでasyncFnを使ったか\n        if (name && this.usedAsyncFn) {\n            this.nakoFuncList[name].asyncFn = true;\n        }\n        // 関数の末尾に、ローカル変数をPOP\n        // 関数内で定義されたローカル変数の宣言\n        for (const name of Array.from(this.varsSet.names.values())) {\n            if (!varsDeclared.includes(name)) {\n                if (NakoGen.isValidIdentifier(name)) {\n                    variableDeclarations += `  var ${name};\\n`;\n                }\n            }\n        }\n        if (this.speedMode.invalidSore === 0) {\n            if (NakoGen.isValidIdentifier('それ')) {\n                variableDeclarations += '  var それ = \\'\\';\\n';\n            }\n            else {\n                variableDeclarations += `  ${this.varname('それ')} = '';`;\n            }\n        }\n        // usedAsyncFnの値に応じて関数定義の方法を変更\n        const tof = (this.usedAsyncFn) ? topOfFunctionAsync : topOfFunction;\n        // 関数コード全体を構築\n        code = tof + performanceMonitorInjectAtStart + variableDeclarations + code + popStack;\n        code += endOfFunction;\n        // 名前があれば、関数を登録する\n        if (name) {\n            this.nakoFuncList[name].fn = code;\n            this.nakoFuncList[name].asyncFn = this.usedAsyncFn;\n            meta.asyncFn = this.usedAsyncFn;\n        }\n        this.usedAsyncFn = oldUsedAsyncFn; // 以前の値を戻す\n        this.varslistSet.pop();\n        this.varsSet = this.varslistSet[this.varslistSet.length - 1];\n        if (name) {\n            this.__self.__varslist[1][name] = code;\n        }\n        return code;\n    }\n    convDefTest(node) {\n        const name = node.name.value;\n        let code = `__tests.push({ name: '${name}', f: () => {\\n`;\n        // ブロックを解析\n        const block = this._convGen(node.block, false);\n        code += `   ${block}\\n` +\n            '}});';\n        this.nakoTestFuncs[name] = {\n            josi: node.name.meta.josi,\n            fn: code,\n            type: 'test_func'\n        };\n        // ★この時点ではテストコードを生成しない★\n        // プログラム冒頭でコード生成時にテストの定義を行う\n        return '';\n    }\n    convDefFunc(node) {\n        // ※ [関数定義のメモ]\n        // ※ 関数の定義はプログラムの冒頭に移される。\n        // ※ そのため、生成されたコードはここでは返さない\n        // ※ registerFunction を参照\n        if (!node.name) {\n            return '';\n        }\n        const name = NakoGen.getFuncName(node.name.value);\n        this.convDefFuncCommon(node, name);\n        return '';\n    }\n    convFuncObj(node) {\n        return this.convDefFuncCommon(node, '');\n    }\n    convJsonObj(node) {\n        const list = node.value;\n        const codelist = list.map((e) => {\n            const key = this._convGen(e.key, true);\n            const val = this._convGen(e.value, true);\n            return `${key}:${val}`;\n        });\n        return '{' + codelist.join(',') + '}';\n    }\n    convJsonArray(node) {\n        const list = node.value;\n        const codelist = list.map((e) => {\n            return this._convGen(e, true);\n        });\n        return '[' + codelist.join(',') + ']';\n    }\n    convRefArray(node) {\n        const name = this._convGen(node.name, true);\n        const list = node.index;\n        let code = name;\n        if (!list) {\n            return code;\n        }\n        for (let i = 0; i < list.length; i++) {\n            const idx = this._convGen(list[i], true);\n            code += '[' + idx + ']';\n        }\n        return code;\n    }\n    convLetArray(node) {\n        const name = this._convGen(node.name, true);\n        const list = node.index || [];\n        let codeInit = '';\n        let code = name;\n        let codeArray = '';\n        // codeInit?\n        if (node.checkInit) {\n            const arrayDefCode = '[0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0]';\n            codeInit += `\\n/*配列初期化*/if (!(${name} instanceof Array)) { ${name} = ${arrayDefCode}; console.log('初期化:${name}') };`;\n            for (let i = 0; i < list.length - 1; i++) {\n                const idx = this._convGen(list[i], true);\n                codeArray += `[${idx}]`;\n                codeInit += `\\n/*配列初期化${i}*/if (!(${name}${codeArray} instanceof Array)) { ${name}${codeArray} = ${arrayDefCode}; };`;\n                // codeInit += `\\n/*配列初期化${i}*/if (!(${name}${codeArray} instanceof Array)) { ${name}${codeArray} = ${arrayDefCode}; console.log('初期化:${i}:${name}${codeArray}',JSON.stringify(${name})) }; `\n            }\n            codeInit += '\\n';\n        }\n        // array\n        for (let i = 0; i < list.length; i++) {\n            const idx = this._convGen(list[i], true);\n            code += '[' + idx + ']';\n        }\n        const value = this._convGen(node.value, true);\n        code += ' = ' + value + ';\\n';\n        // generate code\n        const src = this.convLineno(node, false) + codeInit + code;\n        return src;\n    }\n    convGenLoop(node) {\n        const tmpflag = this.flagLoop;\n        this.flagLoop = true;\n        try {\n            return this._convGen(node, false);\n        }\n        finally {\n            this.flagLoop = tmpflag;\n        }\n    }\n    convFor(node) {\n        // ループ変数について\n        let word;\n        if (node.word !== null) { // ループ変数を使う時\n            const varName = node.word.value; // todo: Forの最初のパラメータが Token か Astか確認\n            this.varsSet.names.add(varName);\n            word = this.varname(varName);\n        }\n        else {\n            this.varsSet.names.add('dummy');\n            word = this.varname('dummy');\n        }\n        const idLoop = this.loopId++;\n        const varI = `$nako_i${idLoop}`;\n        // ループ条件を確認\n        const kara = this._convGen(node.from, true);\n        const made = this._convGen(node.to, true);\n        let inc = '1';\n        if (node.inc !== null || node.inc === undefined || node.inc === 'null') {\n            inc = this._convGen(node.inc, true);\n        }\n        // ループ内のブロック内容を得る\n        const block = this.convGenLoop(node.block);\n        // ループ条件を変数に入れる用\n        const varFrom = `$nako_from${idLoop}`;\n        const varTo = `$nako_to${idLoop}`;\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `\\n//[FOR id=${idLoop}]\\n` +\n            `const ${varFrom} = ${kara};\\n` +\n            `const ${varTo} = ${made};\\n` +\n            `if (${varFrom} <= ${varTo}) { // up\\n` +\n            `  for (let ${varI} = ${varFrom}; ${varI} <= ${varTo}; ${varI}+= ${inc}) {\\n` +\n            `    ${sorePrefex}${word} = ${varI};\\n` +\n            `    ${block}\\n` +\n            '  };\\n' +\n            '} else { // down\\n' +\n            `  for (let ${varI} = ${varFrom}; ${varI} >= ${varTo}; ${varI}-= ${inc}) {\\n` +\n            `    ${sorePrefex}${word} = ${varI};` + '\\n' +\n            `    ${block}\\n` +\n            '  };\\n' +\n            `};\\n//[/FOR id=${idLoop}]\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    convForeach(node) {\n        let target;\n        if (node.target === null) {\n            if (this.speedMode.invalidSore === 0) {\n                target = this.varname('それ');\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『反復』の対象がありません。', node);\n            }\n        }\n        else {\n            target = this._convGen(node.target, true);\n        }\n        // blockより早く変数を定義する必要がある\n        let nameS = '__v0[\"対象\"]';\n        if (node.name) {\n            nameS = this.varname(node.name.value);\n            this.varsSet.names.add(node.name.value);\n        }\n        const block = this.convGenLoop(node.block);\n        const id = this.loopId++;\n        const key = '__v0[\"対象キー\"]';\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `let $nako_foreach_v${id}=${target};\\n` +\n            `for (let $nako_i${id} in $nako_foreach_v${id})` + '{\\n' +\n            `  if ($nako_foreach_v${id}.hasOwnProperty($nako_i${id})) {\\n` +\n            `    ${nameS} = ${sorePrefex}$nako_foreach_v${id}[$nako_i${id}];` + '\\n' +\n            `    ${key} = $nako_i${id};\\n` +\n            `    ${block}\\n` +\n            '  }\\n' +\n            '};\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convRepeatTimes(node) {\n        const id = this.loopId++;\n        const value = this._convGen(node.value, true);\n        const block = this.convGenLoop(node.block);\n        const kaisu = '__v0[\"回数\"]';\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `let $nako_times_v${id} = ${value};\\n` +\n            `for(var $nako_i${id} = 1; $nako_i${id} <= $nako_times_v${id}; $nako_i${id}++)` + '{\\n' +\n            `  ${sorePrefex}${kaisu} = $nako_i${id};` + '\\n' +\n            '  ' + block + '\\n}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convSpeedMode(node, isExpression) {\n        if (!node.options) {\n            return '';\n        }\n        const prev = { ...this.speedMode };\n        if (node.options['行番号無し']) {\n            this.speedMode.lineNumbers++;\n        }\n        if (node.options['暗黙の型変換無し']) {\n            this.speedMode.implicitTypeCasting++;\n        }\n        if (node.options['強制ピュア']) {\n            this.speedMode.forcePure++;\n        }\n        if (node.options['それ無効']) {\n            this.speedMode.invalidSore++;\n        }\n        try {\n            return this._convGen(node.block, isExpression);\n        }\n        finally {\n            this.speedMode = prev;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convPerformanceMonitor(node, isExpression) {\n        const prev = { ...this.performanceMonitor };\n        if (!node.options) {\n            return '';\n        }\n        if (node.options['ユーザ関数']) {\n            this.performanceMonitor.userFunction++;\n        }\n        if (node.options['システム関数本体']) {\n            this.performanceMonitor.systemFunctionBody++;\n        }\n        if (node.options['システム関数']) {\n            this.performanceMonitor.systemFunction++;\n        }\n        try {\n            return this._convGen(node.block, isExpression);\n        }\n        finally {\n            this.performanceMonitor = prev;\n        }\n    }\n    convWhile(node) {\n        const cond = this._convGen(node.cond, true);\n        const block = this.convGenLoop(node.block);\n        const code = `while (${cond})` + '{\\n' +\n            `  ${block}` + '\\n' +\n            '}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convAtohantei(node) {\n        const id = this.loopId++;\n        const varId = `$nako_i${id}`;\n        const cond = this._convGen(node.cond, true);\n        const block = this.convGenLoop(node.block);\n        const code = 'for(;;) {\\n' +\n            `  ${block}\\n` +\n            `  let ${varId} = ${cond};\\n` +\n            `  if (${varId}) { continue } else { break }\\n` +\n            '}\\n\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convSwitch(node) {\n        const value = this._convGen(node.value, true);\n        const cases = node.cases || [];\n        let body = '';\n        for (let i = 0; i < cases.length; i++) {\n            const cvalue = cases[i][0];\n            const cblock = this.convGenLoop(cases[i][1]);\n            if (cvalue.type === '違えば') {\n                body += '  default:\\n';\n            }\n            else {\n                const cvalueCode = this._convGen(cvalue, true);\n                body += `  case ${cvalueCode}:\\n`;\n            }\n            body += `    ${cblock}\\n` +\n                '    break\\n';\n        }\n        const code = `switch (${value})` + '{\\n' +\n            `${body}` + '\\n' +\n            '}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convIf(node) {\n        const expr = this._convGen(node.expr, true);\n        const block = this._convGen(node.block, false);\n        const falseBlock = (node.false_block === null)\n            ? ''\n            : 'else {' + this._convGen(node.false_block, false) + '};\\n';\n        return this.convLineno(node, false) +\n            `if (${expr}) {\\n  ${block}\\n}` + falseBlock + ';\\n';\n    }\n    convTikuji(node) {\n        const pid = this.loopId++;\n        // gen tikuji blocks\n        const curName = `__tikuji${pid}`;\n        let code = `const ${curName} = []\\n`;\n        const blocks = (node.blocks) ? node.blocks : [];\n        for (let i = 0; i < blocks.length; i++) {\n            const block = this._convGen(blocks[i], false).replace(/\\s+$/, '') + '\\n';\n            const blockLineNo = this.convLineno(blocks[i], true);\n            const blockCode = `${curName}.push(function(resolve, reject) {\\n` +\n                '  __self.resolve = resolve;\\n' +\n                '  __self.reject = reject;\\n' +\n                '  __self.resolveCount = 0;\\n' +\n                `  ${blockLineNo}\\n` +\n                `  ${block}` +\n                '  if (__self.resolveCount === 0) resolve();\\n' +\n                // eslint-disable-next-line no-template-curly-in-string\n                '}); // end of tikuji__${pid}[{$i}]\\n';\n            code += blockCode;\n        }\n        code += `// end of ${curName} \\n`;\n        // gen error block\n        let errorCode = `  ${curName}.splice(0);\\n` + // clear\n            '  __v0[\"エラーメッセージ\"]=errMsg;\\n';\n        if (node.errorBlock != null) {\n            const errBlock = this._convGen(node.errorBlock, false).replace(/\\s+$/, '') + '\\n';\n            errorCode += errBlock;\n        }\n        code += `const ${curName}__reject = function(errMsg){\\n${errorCode}};\\n`;\n        // gen run block\n        code += '__self.resolve = undefined;\\n';\n        code += `const ${curName}__resolve = function(){\\n`;\n        code += '  setTimeout(function(){\\n';\n        code += `    if (${curName}.length == 0) {return}\\n`;\n        code += `    const f = ${curName}.shift()\\n`;\n        code += `    f(${curName}__resolve, ${curName}__reject);\\n`;\n        code += '  }, 0);\\n';\n        code += '};\\n';\n        code += `${curName}__resolve()\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    convFuncGetArgsCalcType(_funcName, _func, node) {\n        const args = [];\n        const opts = {};\n        const nodeArgs = (node.args) ? node.args : [];\n        for (let i = 0; i < nodeArgs.length; i++) {\n            const arg = nodeArgs[i];\n            if (i === 0 && arg === null && this.speedMode.invalidSore === 0) {\n                args.push(this.varname('それ'));\n                opts.sore = true;\n            }\n            else {\n                args.push(this._convGen(arg, true));\n            }\n        }\n        return [args, opts];\n    }\n    getPluginList() {\n        const r = [];\n        for (const name in this.__self.__module) {\n            r.push(name);\n        }\n        return r;\n    }\n    /**\n     * 関数の呼び出し\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     * @returns string コード\n     */\n    convCallFunc(node, isExpression) {\n        const funcName = NakoGen.getFuncName(node.name);\n        const res = this.findVar(funcName);\n        if (res === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`関数『${funcName}』が見当たりません。有効プラグイン=[` + this.getPluginList().join(', ') + ']', node);\n        }\n        // どの関数を呼び出すのか関数を特定する\n        let func;\n        if (res.i === 0) { // plugin function\n            func = this.__self.getFunc(funcName);\n            if (!func) {\n                throw new Error(`[System Error] 関数「${funcName}」NakoCompiler.nakoFuncList の不整合があります。`);\n            }\n            if (func.type !== 'func') {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${funcName}』は関数ではありません。`, node);\n            }\n        }\n        else {\n            func = this.nakoFuncList[funcName];\n            // 無名関数の可能性\n            if (func === undefined) {\n                func = { return_none: false };\n            }\n        }\n        // 関数の参照渡しか？\n        if (node.type === 'func_pointer') {\n            return res.js;\n        }\n        // 関数の参照渡しでない場合\n        // 関数定義より助詞を一つずつ調べる\n        const argsInfo = this.convFuncGetArgsCalcType(funcName, func, node);\n        const args = argsInfo[0];\n        const argsOpts = argsInfo[1];\n        // function\n        this.usedFuncSet.add(funcName);\n        // 関数呼び出しで、引数の末尾にthisを追加する-システム情報を参照するため\n        args.push('__self');\n        let funcDef = 'function';\n        let funcBegin = '';\n        let funcEnd = '';\n        // setter?\n        if (node.setter) {\n            funcBegin += ';__self.isSetter = true;\\n';\n            funcEnd += ';__self.isSetter = false;\\n';\n        }\n        // 関数内 (__varslist.length > 3) からプラグイン関数 (res.i === 0) を呼び出すとき、 そのプラグイン関数がpureでなければ\n        // 呼び出しの直前に全てのローカル変数をthis.__localsに入れる。\n        if (res.i === 0 && this.varslistSet.length > 3 && func.pure !== true && this.speedMode.forcePure === 0) { // undefinedはfalseとみなす\n            // 展開されたローカル変数の列挙\n            const localVars = [];\n            for (const name of Array.from(this.varsSet.names.values())) {\n                if (NakoGen.isValidIdentifier(name)) {\n                    localVars.push({ str: JSON.stringify(name), js: this.varname(name) });\n                }\n            }\n            // --- 実行前 ---\n            // 全ての展開されていないローカル変数を __self.__locals にコピーする\n            funcBegin += '__self.__locals = __vars;\\n';\n            // 全ての展開されたローカル変数を __self.__locals に保存する\n            for (const v of localVars) {\n                funcBegin += `__self.__locals[${v.str}] = ${v.js};\\n`;\n            }\n            // --- 実行後 ---\n            // 全ての展開されたローカル変数を __self.__locals から受け取る\n            // 「それ」は関数の実行結果を受け取るために使うためスキップ。\n            for (const v of localVars) {\n                if (v.js !== 'それ') {\n                    funcEnd += `${v.js} = __self.__locals[${v.str}];\\n`;\n                }\n            }\n        }\n        // 変数「それ」が補完されていることをヒントとして出力\n        if (argsOpts.sore) {\n            funcBegin += '/*[sore]*/';\n        }\n        const indent = (text, n) => {\n            let result = '';\n            for (const line of text.split('\\n')) {\n                if (line !== '') {\n                    result += '  '.repeat(n) + line + '\\n';\n                }\n            }\n            return result;\n        };\n        // 関数呼び出しコードの構築\n        let argsCode;\n        if ((this.warnUndefinedCallingUserFunc === 0 && res.i !== 0) || (this.warnUndefinedCallingSystemFunc === 0 && res.i === 0)) {\n            argsCode = args.join(',');\n        }\n        else {\n            argsCode = '';\n            args.forEach((arg) => {\n                if (arg === '__self') {\n                    argsCode += `,${arg}`;\n                }\n                else {\n                    if (res.i === 0) {\n                        argsCode += `,(function(a){if(a===undefined){__self.logger.warn('命令『${funcName}』の引数にundefinedを渡しています。',{file:'${node.file}',line:${node.line}});};return a;})(${arg})`;\n                    }\n                    else {\n                        argsCode += `,(function(a){if(a===undefined){__self.logger.warn('ユーザ関数『${funcName}』の引数にundefinedを渡しています。',{file:'${node.file}',line:${node.line}});};return a;})(${arg})`;\n                    }\n                }\n            });\n            argsCode = argsCode.substring(1);\n        }\n        let funcCall = `${res.js}(${argsCode})`;\n        if (func.asyncFn) {\n            funcDef = `async ${funcDef}`;\n            funcCall = `await ${funcCall}`;\n            this.numAsyncFn++;\n            this.usedAsyncFn = true;\n        }\n        if (res.i === 0 && this.performanceMonitor.systemFunctionBody !== 0) {\n            let key = funcName;\n            if (!key) {\n                if (typeof this.performanceMonitor.mumeiId === 'undefined') {\n                    this.performanceMonitor.mumeiId = 0;\n                }\n                this.performanceMonitor.mumeiId++;\n                key = `anous_${this.performanceMonitor.mumeiId}`;\n            }\n            funcCall = `(${funcDef} (key, type) {\\n` +\n                'const sbf_start = performance.now() * 1000;\\n' +\n                'try {\\n' +\n                'return ' + funcCall + ';\\n' +\n                '} finally {\\n' +\n                'const sbl_time = performance.now() * 1000 - sbf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sbl_time, min_usec: sbl_time, max_usec: sbl_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sbl_time, min_usec: sbl_time, max_usec: sbl_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=sbl_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>sbl_time){__self.__performance_monitor[key].min_usec=sbl_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<sbl_time){__self.__performance_monitor[key].max_usec=sbl_time;}\\n' +\n                `}}})('${funcName}_body', 'sysbody')\\n`;\n        }\n        let code = '';\n        if (func.return_none) {\n            // 戻り値のない関数の場合\n            if (funcEnd === '') {\n                if (funcBegin === '') {\n                    code = `${funcCall};\\n`;\n                }\n                else {\n                    code = `${funcBegin} ${funcCall};\\n`;\n                }\n            }\n            else {\n                code = `${funcBegin}try {\\n${indent(funcCall, 1)};\\n} finally {\\n${indent(funcEnd, 1)}}\\n`;\n            }\n        }\n        else {\n            // 戻り値のある関数の場合\n            let sorePrefex = '';\n            if (this.speedMode.invalidSore === 0) {\n                sorePrefex = `${this.varname('それ')} = `;\n            }\n            if (funcBegin === '' && funcEnd === '') {\n                code = `(${sorePrefex}${funcCall})`;\n            }\n            else {\n                if (funcEnd === '') {\n                    code = `(${funcDef}(){\\n${indent(`${funcBegin};\\nreturn ${sorePrefex} ${funcCall}`, 1)}}).call(this)`;\n                }\n                else {\n                    code = `(${funcDef}(){\\n${indent(`${funcBegin}try {\\n${indent(`return ${sorePrefex}${funcCall};`, 1)}\\n} finally {\\n${indent(funcEnd, 1)}}`, 1)}}).call(this)`;\n                }\n            }\n            // ...して\n            if (node.josi === 'して' || (node.josi === '' && !isExpression)) {\n                code += ';\\n';\n            }\n        }\n        if (res.i === 0 && this.performanceMonitor.systemFunction !== 0) {\n            code = '(function (key, type) {\\n' +\n                'const sf_start = performance.now() * 1000;\\n' +\n                'try {\\n' +\n                'return ' + code + ';\\n' +\n                '} finally {\\n' +\n                'const sl_time = performance.now() * 1000 - sf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sl_time, min_usec: sl_time, max_usec: sl_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sl_time, min_usec: sl_time, max_usec: sl_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=sl_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>sl_time){__self.__performance_monitor[key].min_usec=sl_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<sl_time){__self.__performance_monitor[key].max_usec=sl_time;}\\n' +\n                `}}})('${funcName}_sys', 'system')\\n`;\n        }\n        return code;\n    }\n    convRenbun(node) {\n        const right = this._convGen(node.right, true);\n        const left = this._convGen(node.left, false);\n        return `(function(){${left}; return ${right}}).call(this)`;\n    }\n    convOp(node) {\n        const OP_TBL = {\n            '&': '+\"\"+',\n            eq: '==',\n            noteq: '!=',\n            '===': '===',\n            '!==': '!==',\n            gt: '>',\n            lt: '<',\n            gteq: '>=',\n            lteq: '<=',\n            and: '&&',\n            or: '||',\n            shift_l: '<<',\n            shift_r: '>>',\n            shift_r0: '>>>',\n            '÷': '/'\n        };\n        let op = node.operator || ''; // 演算子\n        let right = this._convGen(node.right, true);\n        let left = this._convGen(node.left, true);\n        if (op === '+' && this.speedMode.implicitTypeCasting === 0) {\n            if (node.left && node.left.type !== 'number') {\n                left = `parseFloat(${left})`;\n            }\n            if (node.right && node.right.type !== 'number') {\n                right = `parseFloat(${right})`;\n            }\n        }\n        // 階乗\n        if (op === '^') {\n            return `(Math.pow(${left}, ${right}))`;\n        }\n        // 整数の割り算 #1152\n        if (op === '÷÷') {\n            return `(Math.floor(${left} / ${right}))`;\n        }\n        // 一般的なオペレータに変換\n        if (OP_TBL[op]) {\n            op = OP_TBL[op];\n        }\n        //\n        return `(${left} ${op} ${right})`;\n    }\n    convInc(node) {\n        // もし値が省略されていたら、変数「それ」に代入する\n        let value = null;\n        if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        if (value == null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('加算する先の変数名がありません。', node);\n        }\n        // 変数名\n        const name = node.name.value;\n        let res = this.findVar(name);\n        let code = '';\n        if (res === null) {\n            this.varsSet.names.add(name);\n            res = this.findVar(name);\n            if (!res) {\n                throw new Error('『増』または『減』で変数が見当たりません。');\n            }\n        }\n        const jsName = res.js;\n        // 自動初期化するか\n        code += `if (typeof(${jsName}) === 'undefined') { ${jsName} = 0; }`;\n        code += `${jsName} += ${value}`;\n        return ';' + this.convLineno(node, false) + code + '\\n';\n    }\n    convLet(node) {\n        // もし値が省略されていたら、変数「それ」に代入する\n        let value = null;\n        if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        if (value == null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('代入する先の変数名がありません。', node);\n        }\n        // 変数名\n        const name = node.name.value;\n        const res = this.findVar(name);\n        let code = '';\n        if (res === null) {\n            this.varsSet.names.add(name);\n            code = `${this.varname(name)} = ${value};`;\n        }\n        else {\n            // 定数ならエラーを出す\n            if (this.varslistSet[res.i].readonly.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`定数『${name}』は既に定義済みなので、値を代入することはできません。`, node);\n            }\n            code = `${res.js} = ${value};`;\n        }\n        return ';' + this.convLineno(node, false) + code + '\\n';\n    }\n    convDefLocalVar(node) {\n        const value = (node.value === null) ? 'null' : this._convGen(node.value, true);\n        const name = node.name.value;\n        const vtype = node.vartype; // 変数 or 定数\n        // 二重定義？\n        if (this.varsSet.names.has(name)) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n        }\n        //\n        this.varsSet.names.add(name);\n        if (vtype === '定数') {\n            this.varsSet.readonly.add(name);\n        }\n        const code = `${this.varname(name)}=${value};\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    // #563 複数変数への代入\n    convDefLocalVarlist(node) {\n        let code = '';\n        const vtype = node.vartype; // 変数 or 定数\n        const value = (node.value === null) ? 'null' : this._convGen(node.value, true);\n        this.loopId++;\n        const varI = `$nako_i${this.loopId}`;\n        code += `${varI}=${value}\\n`;\n        code += `if (!(${varI} instanceof Array)) { ${varI}=[${varI}] }\\n`;\n        const names = (node.names) ? node.names : [];\n        for (let i = 0; i < names.length; i++) {\n            const nameObj = names[i];\n            const name = nameObj.value;\n            // 二重定義？\n            if (this.varsSet.names.has(name)) {\n                // 複数変数文では、二重定義も許容する #1027\n                // throw NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node)\n            }\n            this.varsSet.names.add(name);\n            if (vtype === '定数') {\n                this.varsSet.readonly.add(name);\n            }\n            const vname = this.varname(name);\n            code += `${vname}=${varI}[${i}];\\n`;\n        }\n        return this.convLineno(node, false) + code;\n    }\n    convString(node) {\n        let value = '' + node.value;\n        const mode = node.mode;\n        value = value.replace(/\\\\/g, '\\\\\\\\');\n        value = value.replace(/\"/g, '\\\\\"');\n        value = value.replace(/\\r/g, '\\\\r');\n        value = value.replace(/\\n/g, '\\\\n');\n        if (mode === 'ex') {\n            const rf = (a, name) => {\n                return '\"+' + this.genVar(name, node) + '+\"';\n            };\n            value = value.replace(/\\{(.+?)\\}/g, rf);\n            value = value.replace(/｛(.+?)｝/g, rf);\n        }\n        return '\"' + value + '\"';\n    }\n    convTryExcept(node) {\n        const block = this._convGen(node.block, false);\n        const errBlock = this._convGen(node.errBlock, false);\n        return this.convLineno(node, false) +\n            `try {\\n${block}\\n} catch (e) {\\n` +\n            '  __v0[\"エラーメッセージ\"] = e.message;\\n' +\n            ';\\n' +\n            `${errBlock}}\\n`;\n    }\n    getUsedFuncSet() {\n        return this.usedFuncSet;\n    }\n    getPluginInitCode() {\n        // プラグインの初期化関数を実行する\n        let code = '';\n        let pluginCode = '';\n        for (const name in this.__self.__module) {\n            const initkey = `!${name}:初期化`;\n            if (this.varslistSet[0].names.has(initkey)) {\n                this.usedFuncSet.add(`!${name}:初期化`);\n                pluginCode += `__v0[\"!${name}:初期化\"](__self);\\n`;\n            }\n        }\n        if (pluginCode !== '') {\n            code += '__v0.line=\\'l0:プラグインの初期化\\';\\n' + pluginCode;\n        }\n        return code;\n    }\n}\n/**\n * @param com\n * @param ast\n * @param opt\n */\nfunction generateJS(com, ast, opt) {\n    const gen = new NakoGen(com);\n    // ※ [関数定義に関するコード生成のヒント]\n    // ※ 関数の名前だけを(1)で登録して、(2)で実際に関数のコードを生成する。\n    // ※ ただし(2)では生成するだけなので、(3)でプログラム冒頭に関数定義のコードを記述する。\n    // この順番を変えることはできない (グローバル変数が認識できなくなったり、関数定義のタイミングがずれる)\n    // (1) ユーザー定義関数をシステムに登録する\n    gen.registerFunction(ast);\n    // (2) JSコードを生成する\n    let js = gen.convGen(ast, opt);\n    // (3) JSコードを実行するための事前ヘッダ部分の生成\n    const jsInit = gen.getDefFuncCode(com, opt);\n    // テストの実行\n    if (js && opt.isTest) {\n        js += '\\n__self._runTests(__tests);\\n';\n    }\n    // async method\n    if (gen.numAsyncFn > 0) {\n        const asyncMain = '__nako3async' + (new Date()).getTime() + '_' + ('' + Math.random()).replace('.', '_') + '__';\n        js = `\n// --------------------------------------------------\n// <nadesiko3::gen::async times=\"${gen.numAsyncFn}\">\nasync function ${asyncMain}(self) {\n${jsInit}\n${js}\n} // end of ${asyncMain}\n${asyncMain}.call(self, self).catch(err => {\n  self.numFailures++\n  throw new NakoRuntimeError(err, self.__v0.line) // エラー位置を認識\n})\n// <nadesiko3::gen::async>\n// --------------------------------------------------\n`;\n    }\n    else {\n        js = `\n// --------------------------------------------------\ntry {\n  ${jsInit}\n  ${js}\n} catch (err) {\n  self.numFailures++\n  throw new NakoRuntimeError(err, self.__v0.line) // エラー位置を認識\n}\n// --------------------------------------------------\n`;\n    }\n    // デバッグメッセージ\n    com.getLogger().trace('--- generate ---\\n' + js);\n    let codeImportFiles = '';\n    const importNames = [];\n    for (const f of opt.importFiles) {\n        if (f === 'nako_errors.mjs') {\n            continue;\n        }\n        const ff = 'nako3runtime_' + f.replace(/\\.(js|mjs)$/, '').replace(/[^a-zA-Z0-9_]/g, '_');\n        importNames.push(ff);\n        codeImportFiles += `import ${ff} from './nako3runtime/${f}'\\n`;\n    }\n    const standaloneJSCode = `\\\n// <standaloneCode>\nimport path from 'path'\nimport { NakoRuntimeError } from './nako3runtime/nako_errors.mjs'\n${codeImportFiles}\nconst self = {}\nself.coreVersion = '${com.coreVersion}'\nself.version = '${com.version}'\nself.logger = {\n  error: (message) => { console.error(message) },\n  warn: (message) => { console.warn(message) },\n  send: (level, message) => { console.log(message) },\n};\nself.__varslist = [{}, {}, {}]\nself.__v0 = self.__varslist[0]\nself.initFuncList = []\nself.clearFuncList = []\n// Copy module functions\nfor (const mod of [${importNames.join(', ')}]) {\n  for (const funcName in mod) {\n    if (funcName === '初期化') {\n      self.initFuncList.push(mod[funcName].fn)\n      continue\n    }\n    if (funcName === '!クリア') {\n      self.clearFuncList.push(mod[funcName].fn)\n      continue\n    }\n    self.__varslist[0][funcName] = mod[funcName].fn\n  }\n}\nself.__vars = self.__varslist[2];\nself.__module = {};\nself.__locals = {};\nself.__genMode = 'sync';\n\n// プラグインの初期化コードを実行\nself.initFuncList.map(f => f(self))\n\ntry {\n${opt.codeStandalone}\n// <JS:standalone>\n${js}\n// </JS:standalone>\n  // standaloneCodeでは、即時プラグインのクリアコードを実行\n  self.clearFuncList.map(f => f(self))\n} catch (err) {\n  self.logger.error(err);\n  throw err;\n}\n// </standaloneCode>\n`;\n    // ---\n    const initCode = gen.getPluginInitCode();\n    const runtimeEnvCode = `\n// runtimeEnv\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoError.toString()}\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError.toString()}\nconst self = this\n${opt.codeEnv}\n${jsInit}\n${initCode}\n${js}\n// end of runtimeEnv\n`;\n    return {\n        // なでしこの実行環境ありの場合(thisが有効)\n        runtimeEnv: runtimeEnvCode,\n        // JavaScript単体で動かす場合\n        standalone: standaloneJSCode,\n        // コード生成に使ったNakoGenのインスタンス\n        gen\n    };\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_gen.mjs?")},"./core/src/nako_gen_async.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoGenASync\": function() { return /* binding */ NakoGenASync; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_core_version.mjs */ \"./core/src/nako_core_version.mjs\");\n/* harmony import */ var _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_gen.mjs */ \"./core/src/nako_gen.mjs\");\n/**\n * file: nako_gen_async\n * パーサーが生成した中間オブジェクトを実際のJavaScriptのコードに変換する。\n * なお、扱いやすさ優先で、なでしこの一文を一つの関数として生成し、非同期実行する。\n */\n\n\n\n/**\n * なでしこのインタプリタコード\n */\nconst NakoCodeNop = 'NOP';\nconst NakoCodeLabel = 'LBL';\nconst NakoCodeEOL = 'EOL';\nconst NakoCodeJump = 'JMP'; // JUMP addr\nconst NakoCodeJumpIfTrue = 'JMP_T'; // pop and jump addr\nconst NakoCodeJumpIfFalse = 'JMP_F'; // pop and jump addr\nconst NakoCodeCall = 'CALL'; // call addr\nconst NakoCodeCallObj = 'CALL_OBJ'; // call addr\nconst NakoCodeReturn = 'RET';\nconst NakoCodeTry = 'TRY';\nconst NakoCodeCode = 'CODE';\nconst NakoCodeTagIsFuncpoint = 0x0F;\n/**\n * なでしこのインタプリタが用いる簡易コードを表現するクラス\n */\nclass NakoCode {\n    /**\n     * @param type\n     * @param value\n     */\n    constructor(type, value) {\n        /** Codeのタイプ\n         * @type {string}\n         */\n        this.type = type;\n        /** Codeの値 / ラベルならラベル名\n         * @type {string}\n         */\n        this.value = value;\n        /** ラベルならジャンプ先\n         * @type {number}\n         */\n        this.no = -1;\n        /** タグ\n         * @type {number}\n         */\n        this.tag = 0;\n    }\n}\n/**\n * 構文木からJSのコードを生成するクラス\n */\nclass NakoGenASync {\n    /**\n     * @param com コンパイラのインスタンス\n     */\n    constructor(com) {\n        this.com = com;\n        /**\n         * 出力するJavaScriptコードのヘッダー部分で定義する必要のある関数。fnはjsのコード。\n         * プラグイン関数は含まれない。\n         */\n        this.nakoFuncList = { ...com.getNakoFuncList() };\n        /**\n         * なでしこで定義したテストの一覧\n         * @type {Record<string, { josi: string[][], fn: string, type: 'test_func' }>}\n         */\n        this.nakoTestList = {};\n        /**\n         * プログラム内で参照された関数のリスト。プラグインの命令を含む。\n         * JavaScript単体で実行するとき、このリストにある関数の定義をJavaScriptコードの先頭に付け足す。\n         * @type {Set<string>}\n         */\n        this.usedFuncSet = new Set();\n        /**\n         * ループ時の一時変数が被らないようにIDで管理\n         * @type {number}\n         */\n        this.loopId = 1;\n        /**\n         * 変換中の処理が、ループの中かどうかを判定する\n         * @type {boolean}\n         */\n        this.flagLoop = false;\n        /**\n         * 変換後のコード管理番号\n         * @type {number}\n         */\n        this.codeId = 0;\n        /**\n         * 変換後のコードを保持する配列\n         * @type {Array<NakoCode>}\n         */\n        this.codeArray = [];\n        /** @type {NakoCode | null} */\n        this.labelContinue = null;\n        /** @type {NakoCode | null} */\n        this.labelBreak = null;\n        /**\n         * ジャンプ先を表現するラベル\n         * @type {Object<string, number>}\n         */\n        this.labels = {};\n        // コンパイラのインスタンス\n        this.__self = com;\n        /**\n         * コードジェネレータの種類\n         * @type {string}\n         */\n        this.genMode = '非同期モード';\n        /**\n         * 行番号とファイル名が分かるときは `l123:main.nako3`、行番号だけ分かるときは `l123`、そうでなければ任意の文字列。\n         * @type {string | null}\n         */\n        this.lastLineNo = null;\n        /**\n         * スタック\n         * @type {{ isFunction: boolean, names: Set<string>, readonly: Set<string> }[]}\n         */\n        this.varslistSet = com.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        /**\n         * スタックトップ\n         * @type {{ isFunction: boolean, names: Set<string>, readonly: Set<string> }}\n         */\n        this.varsSet = { isFunction: false, names: new Set(), readonly: new Set() };\n        this.varslistSet[2] = this.varsSet;\n        // 1以上のとき高速化する。\n        // 実行速度優先ブロック内で1増える。\n        this.speedMode = {\n            lineNumbers: 0,\n            implicitTypeCasting: 0,\n            invalidSore: 0,\n            forcePure: 0 // 全てのシステム命令をpureとして扱う。命令からローカル変数への参照が出来なくなる。\n        };\n        // 1以上のとき測定をinjectする。\n        // パフォーマンスモニタのブロック内で1増える。\n        this.performanceMonitor = {\n            userFunction: 0,\n            systemFunction: 0,\n            systemFunctionBody: 0 // システム関数(呼び出しコードを除く)\n        };\n    }\n    /**\n     * @param com\n     * @param {Ast} ast\n     * @param {boolean | string} isTest 文字列なら1つのテストだけを実行する\n     */\n    static generate(com, ast, isTest) {\n        const gen = new NakoGenASync(com);\n        // ユーザー定義関数をシステムに登録する\n        gen.registerFunction(ast);\n        // JSコードを生成する\n        let js = gen.convGen(ast, !!isTest);\n        // JSコードを実行するための事前ヘッダ部分の生成\n        js = gen.getDefFuncCode(isTest) + js;\n        com.getLogger().trace('--- generate(非同期モード) ---\\n' + js);\n        // テストの実行\n        if (js && isTest) {\n            js += '\\n__self._runTests(__tests);\\n';\n        }\n        return {\n            // なでしこの実行環境ありの場合\n            runtimeEnv: js,\n            // JavaScript単体で動かす場合\n            standalone: `\\\nconst nakoVersion = ${JSON.stringify(_nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])};\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoError.toString()}\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError.toString()}\nthis.logger = {\n  error(message) { console.error(message) },\n  send(level, message) { console.log(message) },\n};\nthis.__varslist = [{}, {}, {}];\nthis.__vars = this.__varslist[2];\nthis.__module = {};\nthis.__locals = {};\nthis.__labels = {};\nthis.__code = [];\nthis.__callstack = [];\nthis.__stack = [];\nthis.__genMode = '非同期モード';\ntry {\n  ${gen.getVarsCode()}\n  ${js}\n} catch (err) {\n  if (!(err instanceof NakoRuntimeError)) {\n    err = new NakoRuntimeError(err, this.__varslist[0].line);\n  }\n  this.logger.error(err);\n  throw err;\n}`,\n            gen // コード生成に使ったNakoGenのインスタンス\n        };\n    }\n    /**\n     * @param {import(\"./nako3\").Ast} node\n     * @param {boolean} forceUpdate\n     */\n    convLineno(node, forceUpdate) {\n        if (this.speedMode.lineNumbers > 0) {\n            return '';\n        }\n        /** @type {string} */\n        let lineNo;\n        if (typeof node.line !== 'number') {\n            lineNo = 'unknown';\n        }\n        else if (typeof node.file !== 'string') {\n            lineNo = `l${node.line}`;\n        }\n        else {\n            lineNo = `l${node.line}:${node.file}`;\n        }\n        // 強制的に行番号をアップデートするか\n        if (!forceUpdate) {\n            if (lineNo === this.lastLineNo) {\n                return '';\n            }\n            this.lastLineNo = lineNo;\n        }\n        // 例: __v0.line='l1:main.nako3'\n        return `__v0.line=${JSON.stringify(lineNo)};`;\n    }\n    /**\n     * ローカル変数のJavaScriptコードを生成する。\n     * 基本的に取得のために利用\n     * @param {string} name\n     */\n    varname(name) {\n        const keys = JSON.stringify(name);\n        return `sys.__vars[${keys}]`;\n    }\n    /**\n     * プログラムの実行に必要な関数を書き出す(システム領域)\n     * @returns {string}\n     */\n    getVarsCode() {\n        let code = '';\n        // プログラム中で使った関数を列挙して書き出す\n        for (const key of Array.from(this.usedFuncSet.values())) {\n            const f = this.__self.__varslist[0][key];\n            const name = `this.__varslist[0][\"${key}\"]`;\n            if (typeof (f) === 'function') {\n                code += name + '=' + f.toString() + ';\\n';\n            }\n            else {\n                code += name + '=' + JSON.stringify(f) + ';\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プログラムの実行に必要な関数定義を書き出す(グローバル領域)\n     * convGenの結果を利用するため、convGenの後に呼び出すこと。\n     * @param {boolean | string} isTest テストかどうか。stringの場合は1つのテストのみ。\n     * @returns {string}\n     */\n    getDefFuncCode(isTest) {\n        let code = '';\n        // よく使う変数のショートカット\n        code += 'const __self = this.__self = this;\\n';\n        code += 'const __varslist = this.__varslist;\\n';\n        code += 'const __module = this.__module;\\n';\n        code += 'const __v0 = this.__v0 = this.__varslist[0];\\n';\n        code += 'const __v1 = this.__v1 = this.__varslist[1];\\n';\n        code += 'const __vars = this.__vars = this.__varslist[2];\\n';\n        code += 'const __code = this.__code;\\n';\n        // なでしこの関数定義を行う\n        let nakoFuncCode = '';\n        for (const key in this.nakoFuncList) {\n            const f = this.nakoFuncList[key].fn;\n            nakoFuncCode += '' +\n                `//[DEF_FUNC name='${key}']\\n` +\n                `__v1[\"${key}\"]=${f};\\n;` +\n                `//[/DEF_FUNC name='${key}']\\n`;\n        }\n        if (nakoFuncCode !== '') {\n            code += '__v0.line=\\'関数の定義\\';\\n' + nakoFuncCode;\n        }\n        // プラグインの初期化関数を実行する\n        let pluginCode = '';\n        for (const name in this.__self.__module) {\n            const initkey = `!${name}:初期化`;\n            if (this.varslistSet[0].names.has(initkey)) {\n                this.usedFuncSet.add(`!${name}:初期化`);\n                pluginCode += `__v0[\"!${name}:初期化\"](__self);\\n`;\n            }\n        }\n        if (pluginCode !== '') {\n            code += '__v0.line=\\'プラグインの初期化\\';\\n' + pluginCode;\n        }\n        // テストの定義を行う\n        if (isTest) {\n            let testCode = 'const __tests = [];\\n';\n            for (const key in this.nakoTestList) {\n                if (isTest === true || (typeof isTest === 'string' && isTest === key)) {\n                    const f = this.nakoTestList[key].fn;\n                    testCode += `${f};\\n;`;\n                }\n            }\n            if (testCode !== '') {\n                code += '__v0.line=\\'テストの定義\\';\\n';\n                code += testCode + '\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プラグイン・オブジェクトを追加\n     * @param po プラグイン・オブジェクト\n     */\n    addPlugin(po) {\n        return this.__self.addPlugin(po);\n    }\n    /**\n     * プラグイン・オブジェクトを追加(ブラウザ向け)\n     * @param name オブジェクト名\n     * @param po 関数リスト\n     */\n    addPluginObject(name, po) {\n        this.__self.addPluginObject(name, po);\n    }\n    /**\n     * プラグイン・ファイルを追加(Node.js向け)\n     * @param objName オブジェクト名\n     * @param path ファイルパス\n     * @param po 登録するオブジェクト\n     */\n    addPluginFile(objName, path, po) {\n        this.__self.addPluginFile(objName, path, po);\n    }\n    /**\n     * 関数を追加する\n     * @param key 関数名\n     * @param josi 助詞\n     * @param fn 関数\n     */\n    addFunc(key, josi, fn) {\n        this.__self.addFunc(key, josi, fn);\n    }\n    /**\n     * プラグイン関数を参照する\n     * @param key プラグイン関数の関数名\n     * @returns プラグイン・オブジェクト\n     */\n    getFunc(key) {\n        return this.__self.getFunc(key);\n    }\n    /**\n     * 関数を先に登録してしまう\n     */\n    registerFunction(ast) {\n        if (ast.type !== 'block') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('構文解析に失敗しています。構文は必ずblockが先頭になります', ast);\n        }\n        const registFunc = (node) => {\n            for (let i = 0; i < node.block.length; i++) {\n                const t = node.block[i];\n                if (t.type === 'def_func') {\n                    const name = t.name.value;\n                    this.usedFuncSet.add(name);\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    this.__self.__varslist[1][name] = function () { }; // 事前に適当な値を設定\n                    this.nakoFuncList[name] = {\n                        josi: t.name.meta.josi,\n                        fn: '',\n                        type: 'func'\n                    };\n                }\n                else if (t.type === 'speed_mode') {\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n                else if (t.type === 'performance_monitor') {\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n            }\n        };\n        registFunc(ast);\n        // __self.__varslistの変更を反映\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: false, names: initialNames, readonly: new Set() };\n        this.varslistSet = this.__self.__varslist.map(v => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        this.varslistSet[2] = this.varsSet;\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isTest\n     */\n    convGen(node, isTest) {\n        // convert\n        this._convGen(node, true);\n        // ラベルアドレスの解決が必要なコード一覧\n        const needToFixAddr = new Set([\n            NakoCodeJump, NakoCodeJumpIfTrue, NakoCodeJumpIfFalse, NakoCodeCall, NakoCodeTry\n        ]);\n        // コードの最適化をするか?\n        const optimization = true;\n        let codes = this.codeArray;\n        //\n        if (optimization) {\n            // NOPを削除\n            codes = codes.filter((code) => {\n                return code.type !== NakoCodeNop;\n            });\n            // 未参照のラベルを探す - ただし関数呼び出しは削除しない\n            const usedLabels = new Set();\n            codes.forEach((code) => {\n                if (needToFixAddr.has(code.type)) {\n                    usedLabels.add(code.value);\n                }\n            });\n            // 未参照のラベルを削除\n            codes = codes.filter((code) => {\n                if (code.type !== NakoCodeLabel) {\n                    return true;\n                }\n                if (code.tag === NakoCodeTagIsFuncpoint) {\n                    return true;\n                }\n                return usedLabels.has(code.value);\n            });\n            // EOLが連続していたら削除する\n            let i = 0;\n            while (i < codes.length - 1) {\n                if (codes[i].type === NakoCodeEOL && codes[i + 1].type === NakoCodeEOL) {\n                    codes.splice(i + 1, 1);\n                    continue;\n                }\n                i++;\n            }\n            this.codeArray = codes;\n        }\n        // ラベルアドレスの解決\n        codes.forEach((code, index) => {\n            if (code.type === NakoCodeLabel) {\n                this.labels[code.value] = index;\n            }\n        });\n        codes.forEach((code) => {\n            if (needToFixAddr.has(code.type)) {\n                if (code.no < 0) {\n                    code.no = this.labels[code.value];\n                }\n            }\n        });\n        let result = '';\n        // コードの生成\n        codes.forEach((code, index) => {\n            switch (code.type) {\n                case NakoCodeNop:\n                    result += `case ${index}: break; // [NOP] ${code.value}\\n`;\n                    break;\n                case NakoCodeLabel:\n                    result += `case ${index}: break; // [LABEL] ${code.value}\\n`;\n                    break;\n                case NakoCodeEOL:\n                    result += `case ${index}: ${code.value}; break; // [EOL]\\n`;\n                    break;\n                case NakoCodeJump:\n                    result += `case ${index}: sys.nextIndex = ${code.no}; break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeJumpIfTrue:\n                    result += `case ${index}: if (sys.__stack.pop()) { sys.nextIndex = ${code.no};} break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeJumpIfFalse:\n                    result += `case ${index}: if (!sys.__stack.pop()) { sys.nextIndex = ${code.no}} break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeReturn:\n                    result += `case ${index}: sys.__return(sys); break;\\n`;\n                    break;\n                case NakoCodeCall:\n                    result += `case ${index}: sys.__call(${code.no}, sys); break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeCallObj:\n                    result += `case ${index}: sys.__callObj('${code.value}', ${index}, sys); break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeTry:\n                    result += `case ${index}: sys.tryIndex = ${code.no}; break; // TRY \\n`;\n                    break;\n                case NakoCodeCode:\n                    {\n                        // trim last\n                        const s = code.value.replace(/\\s+$/, '');\n                        result += `case ${index}: {\\n${s}\\n};break;\\n`;\n                        break;\n                    }\n                default:\n                    throw new Error('invalid code type');\n            }\n        });\n        result = `\n    //-------------------------\n    // main_code\n    this.__labels = ${JSON.stringify(this.labels)};\n    this.nextAsync = (sys) => {\n      if (sys.index >= sys.codeSize || sys.index < 0) {return}\n      const __v0 = sys.__v0\n      try {\n        sys.inLoop = true\n        while (sys.index < sys.codeSize && sys.index >= 0) {\n          // console.log('@@[run]', sys.index)\n          switch (sys.index) {\n            // --- CODE.BEGIN ---\n            ${result}\n            // --- CODE.END ---\n            default:\n              sys.inLoop = false\n              console.log(sys.index, sys.__stack)\n              throw new Error('Invalid sys.index:' + sys.index)\n              break\n          }\n          // check next\n          if (sys.nextIndex >= 0) {\n            sys.index = sys.nextIndex\n            sys.nextIndex = -1\n          } else {\n            sys.index++\n          }\n          if (sys.async) {\n            sys.__saveSysenv(sys)\n            sys.async = false\n            break\n          }\n        } // end of while\n        sys.inLoop = false\n      } catch (e) {\n        sys.__errorAsync(e, sys)\n      }\n    }\n    this.__errorAsync = (e, sys) => { // エラーが起きた時呼び出す\n      sys.__v0[\"エラーメッセージ\"] = e.message;\n      if (e.message == '__終わる__') {\n        sys.__stopAsync(sys)\n        return\n      }\n      if (sys.tryIndex >= 0) {\n        sys.index = sys.tryIndex;\n        setTimeout(() => {sys.nextAsync(sys)}, 1)\n      } else {\n        throw e\n      }\n    }\n    this.__call = (no, sys) => {\n      const info = {lastVars:sys.__vars, backNo: this.index + 1}\n      sys.__callstack.push(info);\n      sys.__vars = {\"それ\":\"\"}\n      sys.__varslist.push(sys.__vars)\n      sys.nextIndex = no;\n    }\n    this.__return = sys => {\n      if (sys.__callstack.length === 0) {\n        sys.__destroySysenv(sys, sys.curSysenv.envid)\n        sys.index = -2\n        sys.nextIndex = -1\n        return\n      }\n      const sore = sys.__vars['それ'];\n      sys.__varslist.pop();\n      const info = sys.__callstack.pop();\n      sys.nextIndex = info.backNo;\n      sys.__vars = info.lastVars;\n      sys.__vars['それ'] = sore\n      sys.__stack.push(sore);\n    }\n    this.__resetAsync = sys => {\n      sys.index = 0\n      sys.codeSize = ${codes.length};\n      sys.async = false\n      sys.nextIndex = -1\n      sys.tryIndex = -1\n    }\n    this.__stopAsync = sys => {\n      sys.__resetAsync(sys)\n      sys.index = -1 // force stop!!\n    }\n    this.__callNakoCode = (no, backNo, sys) => {\n      this.__call(backNo, sys)\n      sys.nextIndex = no\n      const sysenv = sys.setAsync(sys)\n      setTimeout(() => {\n        // console.log('//__callNakoCode, back=', backNo, 'no=', no)\n        sys.compAsync(sys, sysenv)\n      } ,1)\n    }\n    this.__callNakoCodeEntry = (no, sys) => {\n      sys.__saveSysenv(sys)\n      sys.curSysenv = sys.__generateSysenv(sys)\n      sys.__restoreSysenv(sys)\n      sys.__vars = {\"それ\":\"\"}\n      sys.__varslist.push(sys.__vars)\n      sys.index = no;\n      sys.nextAsync(sys)\n    }\n    this.__callObj = (vname, curNo, sys) => {\n      if (sys.__vars[vname]) {\n        const fname = sys.__vars[vname]\n        // console.log(sys.__labels)\n        if (fname && sys.__labels[fname]) {\n          const no = sys.__labels[fname]\n          sys.__call(no, sys)\n          return\n        } else {\n          console.log('vname=', vname, 'label=', fname)\n        }\n      }\n      throw new Error('async error in __callObj::', vname)\n    }\n    this.__generateSysenv = sys => {\n      sys.envid = ( sys.envid == null ? 0 : sys.envid ) + 1\n      const sysenv = {\n        callstack: [],\n        varstack: [],\n        varslist: [sys.__varslist[0], sys.__varslist[1], sys.__varslist[2]],\n        index: -1,\n        nextIndex: -1,\n        tryIndex: -1,\n        envid: sys.envid\n      }\n      sysenv.vars = sysenv.varslist[2]\n      if (sys.sysenvs == null) { sys.sysenvs={} }\n      sys.sysenvs[sys.envid] = sysenv\n      // console.log('generete envid '+sys.envid)\n      return sysenv\n    }\n    this.__destroySysenv = (sys, envid) => {\n      delete sys.sysenvs[envid]\n      // console.log('destroy envid '+envid)\n    }\n    this.__saveSysenv = sys => {\n      const sysenv = sys.curSysenv\n      sysenv.callstack = sys.__callstack\n      sysenv.varstack = sys.__stack\n      sysenv.varslist = sys.__varslist\n      sysenv.vars = sys.__vars\n      sysenv.index = sys.index\n      sysenv.nextIndex = sys.nextIndex\n      sysenv.tryIndex = sys.tryIndex\n    }\n    this.__restoreSysenv = sys => {\n      const sysenv = sys.curSysenv\n      sys.__callstack = sysenv.callstack\n      sys.__stack = sysenv.varstack\n      sys.__varslist = sysenv.varslist\n      sys.__vars = sysenv.vars\n      ___vars = sys.__vars\n      sys.index = sysenv.index\n      sys.nextIndex = sysenv.nextIndex\n      sys.tryIndex = sysenv.tryIndex\n    }\n    this.setAsync = sys => {\n      sys.async = true\n      return sys.curSysenv\n    }\n    this.compAsync = (sys,sysenv) => {\n      if (sys.async && sys.curSysenv != null && sysenv != null && sys.curSysenv.envid === sysenv.envid) {\n        sys.async = false\n      } else {\n        if (sys.curSysenv == null || sysenv == null || sys.curSysenv.envid !== sysenv.envid) {\n          sys.__saveSysenv(sys)\n          const envid = sys.curSysenv.envid\n          sys.curSysenv = sysenv\n          sys.__restoreSysenv(sys)\n          // console.log('switch envid '+envid+' to '+sys.curSysenv.envid)\n        }\n        sys.nextAsync(sys)\n      }\n    }\n\n    this.__resetAsync(this)\n    this.curSysenv = this.__generateSysenv(this)\n    this.nextAsync(this)\n    //-------------------------\n    `;\n        if (isTest) {\n            return '';\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    _convGen(node, isExpression) {\n        let code = '';\n        if (node instanceof Array) {\n            for (let i = 0; i < node.length; i++) {\n                const n = node[i];\n                code += this._convGen(n, isExpression);\n            }\n            return code;\n        }\n        if (node === null) {\n            return 'null';\n        }\n        if (node === undefined) {\n            return 'undefined';\n        }\n        if (typeof (node) !== 'object') {\n            return '' + node;\n        }\n        // switch\n        switch (node.type) {\n            // === NOP ===\n            case 'nop':\n                break;\n            case 'comment':\n                if (!node.value) {\n                    node.value = '';\n                }\n                this.addCode(new NakoCode(NakoCodeNop, node.value));\n                break;\n            case 'eol':\n                this.addCode(new NakoCode(NakoCodeEOL, this.convLineno(node, true)));\n                break;\n            // === 単純なコード変換 ===\n            case 'number':\n                this.addCodeStr(`sys.__stack.push(${node.value});//number`);\n                break;\n            case 'string':\n                this.convString(node);\n                break;\n            case 'word':\n            case 'variable':\n                this.convGetVar(node);\n                break;\n            case 'op':\n            case 'calc':\n                this.convOp(node);\n                break;\n            case 'renbun':\n                this.convRenbun(node);\n                break;\n            case 'not':\n                this._convGen(node.value, true);\n                this.addCodeStr('if (sys.__stack.length==0) throw new Error(\\'NOTでスタックに値がありません\\');' +\n                    'sys.__stack[sys.__stack.length-1] = (sys.__stack[sys.__stack.length-1]) ? 0:1');\n                break;\n            case '配列参照':\n                this.convRefArray(node);\n                break;\n            case 'json_array':\n                this.convJsonArray(node);\n                break;\n            case 'json_obj':\n                this.convJsonObj(node);\n                break;\n            case 'bool':\n                {\n                    const b = (node.value) ? 'true' : 'false';\n                    this.addCodeStr(`sys.__stack.push(${b})`);\n                    break;\n                }\n            case 'null':\n                this.addCodeStr('sys.__stack.push(null)');\n                break;\n            case 'func':\n            case 'func_pointer':\n            case 'calc_func':\n                this.convFunc(node, isExpression); // 関数の呼び出し\n                break;\n            // === 文の変換 ===\n            case 'let':\n                this.convLet(node);\n                break;\n            case 'let_array':\n                this.convLetArray(node);\n                break;\n            case 'block':\n                for (let i = 0; i < node.block.length; i++) {\n                    const b = node.block[i];\n                    this._convGen(b, false);\n                }\n                break;\n            case 'if':\n                this.convIf(node);\n                break;\n            case 'repeat_times':\n                this.convRepeatTimes(node);\n                break;\n            case 'break':\n                this.addCodeStr(this.convCheckLoop(node, 'break'));\n                break;\n            case 'continue':\n                this.addCodeStr(this.convCheckLoop(node, 'continue'));\n                break;\n            case 'for':\n                this.convFor(node);\n                break;\n            case 'foreach':\n                this.convForeach(node);\n                break;\n            case 'while':\n                this.convWhile(node);\n                break;\n            case 'switch':\n                this.convSwitch(node);\n                break;\n            case 'return':\n                this.convReturn(node);\n                break;\n            case 'end':\n                code += this.addCodeStr('__varslist[0][\\'終\\']();');\n                break;\n            case 'def_local_var':\n                this.convDefLocalVar(node);\n                break;\n            case 'def_local_varlist':\n                code += this.addCodeStr(this.convDefLocalVarlist(node));\n                break;\n            case 'tikuji':\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('「逐次実行」構文は「!非同期モード」では使えません。', node);\n            case 'speed_mode':\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('「速度有線」構文は「!非同期モード」では使えません。', node);\n            case 'performance_monitor':\n                this.convPerformanceMonitor(node, isExpression);\n                break;\n            case 'func_obj':\n                this.convFuncObj(node);\n                break;\n            case 'def_test':\n                this.convDefTest(node);\n                break;\n            case 'def_func':\n                code += this.addCodeStr(this.convDefFunc(node));\n                break;\n            // TODO\n            case 'try_except':\n                code += this.convTryExcept(node);\n                break;\n            case 'require':\n                code += this.convRequire(node);\n                break;\n            default:\n                throw new Error('System Error: unknown_type=' + node.type);\n        }\n        return code;\n    }\n    convRequire(node) {\n        const gen = new _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen(this.com);\n        this.addCodeStr(gen.convRequire(node));\n        return '';\n    }\n    /**\n     * add code to array\n     * @param {string} codeStr\n     * @returns {string}\n     */\n    addCodeStr(codeStr) {\n        if (codeStr === '') {\n            return '';\n        }\n        const a = codeStr.split('\\n');\n        const a2 = a.map((row) => '  ' + row.replace(/\\s+$/, ''));\n        const c = new NakoCode(NakoCodeCode, a2.join('\\n'));\n        return this.addCode(c);\n    }\n    /**\n     * add code to array\n     * @param {NakoCode} code\n     * @returns {string}\n     */\n    addCode(code) {\n        this.codeArray[this.codeId] = code;\n        this.codeId++;\n        return '';\n    }\n    /**\n     * make label for jump\n     * @param {string} name\n     * @returns {NakoCode}\n     */\n    makeLabel(name) {\n        const uniqLabel = name + '_' + (this.loopId++);\n        return this.makeLabelDirectly(uniqLabel);\n    }\n    /**\n     * make label for function\n     * @param {string} labelName\n     * @returns {NakoCode}\n     */\n    makeLabelDirectly(labelName) {\n        const c = new NakoCode(NakoCodeLabel, labelName);\n        this.labels[labelName] = -1;\n        return c;\n    }\n    /**\n     * make Jump\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJump(label) {\n        return new NakoCode(NakoCodeJump, label.value);\n    }\n    /**\n     * make Jump if true\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJumpIfTrue(label) {\n        return new NakoCode(NakoCodeJumpIfTrue, label.value);\n    }\n    /**\n     * make Jump if false\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJumpIfFalse(label) {\n        return new NakoCode(NakoCodeJumpIfFalse, label.value);\n    }\n    /**\n     * @param {Ast} node\n     */\n    convIf(node) {\n        const labelBegin = this.makeLabel('もし:ここから');\n        const labelEnd = this.makeLabel('もし:ここまで');\n        const labelIfFalse = this.makeLabel('もし:違えば');\n        //\n        this.addCode(labelBegin);\n        this._convGen(node.expr, true);\n        this.addCode(this.makeJumpIfFalse(labelIfFalse));\n        this._convGen(node.block, false);\n        this.addCode(this.makeJump(labelEnd));\n        this.addCode(labelIfFalse);\n        if (node.falseBlock) {\n            this._convGen(node.falseBlock, false);\n        }\n        this.addCode(labelEnd);\n        return '';\n    }\n    convRepeatTimes(node) {\n        this.flagLoop = true;\n        this.varsSet.names.add('回数');\n        this.varsSet.readonly.add('回数');\n        // ループ管理変数を作成\n        const loopVar = `sys.__tmp_i${this.loopId}`;\n        this.loopId++;\n        // ループ回数を取得\n        const loopCount = `sys.__tmp_count${this.loopId}`;\n        this.loopId++;\n        this._convGen(node.value, true);\n        this.addCodeStr(`${loopCount} = sys.__stack.pop(); ${loopVar} = 0;`);\n        const labelCheck = this.makeLabel('回:条件チェック');\n        this.addCode(labelCheck);\n        const labelEnd = this.makeLabel('回:ここまで');\n        this.labelBreak = labelEnd;\n        this.labelContinue = labelCheck;\n        // 繰り返し判定\n        const kaisu = 'sys.__vars[\"回数\"]';\n        const cond = `${kaisu} = ++${loopVar}\\n` +\n            `sys.__stack.push(${loopVar} > ${loopCount})\\n`;\n        this.addCodeStr(cond);\n        this.addCode(this.makeJumpIfTrue(labelEnd));\n        this.convGenLoop(node.block); // read block\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    /**\n     * @param {string} name\n     * @returns {{i: number, name: string, isTop: boolean, js: string} | null}\n     */\n    findVar(name) {\n        // __vars ? (ローカル変数)\n        if (this.varsSet.names.has(name)) {\n            return { i: this.varslistSet.length - 1, name, isTop: true, js: `sys.__vars[${JSON.stringify(name)}]` };\n        }\n        // __varslist ?\n        for (let i = 2; i >= 0; i--) {\n            if (this.varslistSet[i].names.has(name)) {\n                return { i, name, isTop: false, js: `sys.__varslist[${i}][${JSON.stringify(name)}]` };\n            }\n        }\n        return null;\n    }\n    /**\n     * 定義済みの変数の参照\n     * @param {string} name\n     * @param {Ast} position\n     */\n    genVar(name, position) {\n        const res = this.findVar(name);\n        const lno = position.line;\n        if (res === null) {\n            // 定義されていない名前の参照は変数の定義とみなす。\n            // 多くの場合はundefined値を持つ変数であり分かりづらいバグを引き起こすが、\n            // 「ナデシコする」などの命令の中で定義された変数の参照の場合があるため警告に留める。\n            // ただし、自動的に定義される変数『引数』『それ』などは例外 #952\n            if (name === '引数' || name === 'それ' || name === '対象' || name === '対象キー' || name === '回数') {\n                // デフォルト定義されている変数名\n            }\n            else {\n                this.__self.getLogger().warn(`変数『${name}』は定義されていません。`, position);\n            }\n            this.varsSet.names.add(name);\n            return this.varname(name);\n        }\n        const i = res.i;\n        // システム関数・変数の場合\n        if (i === 0) {\n            const pv = this.__self.getFunc(name);\n            if (!pv) {\n                return `${res.js}/*err:${lno}*/`;\n            }\n            if (pv.type === 'const' || pv.type === 'var') {\n                return res.js;\n            }\n            if (pv.type === 'func') {\n                if (!pv.josi) {\n                    throw new Error('[System Error]');\n                }\n                if (pv.josi.length === 0) {\n                    return `(${res.js}())`;\n                }\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』が複文で使われました。単文で記述してください。(v1非互換)`, position);\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』は関数であり参照できません。`, position);\n        }\n        return res.js;\n    }\n    convGetVar(node) {\n        const name = node.value;\n        let varName = `sys.__vars[${JSON.stringify(name)}]`;\n        const o = this.findVar(name);\n        if (o != null) {\n            varName = o.js;\n        }\n        this.addCodeStr(`sys.__stack.push(${varName});`);\n    }\n    convComment(node) {\n        let commentSrc = String(node.value);\n        commentSrc = commentSrc.replace(/\\n/g, '¶');\n        const lineNo = this.convLineno(node, false);\n        if (commentSrc === '' && lineNo === '') {\n            return ';';\n        }\n        if (commentSrc === '') {\n            return ';' + lineNo + '\\n';\n        }\n        return ';' + lineNo + '//' + commentSrc + '\\n';\n    }\n    convReturn(node) {\n        // 関数の中であれば利用可能\n        if (this.varsSet.names.has('!関数')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『戻る』がありますが、関数定義内のみで使用可能です。', node);\n        }\n        if (node.value) {\n            this._convGen(node.value, true);\n            this.addCodeStr('sys.__vars[\"それ\"] = sys.__stack.pop()');\n        }\n        this.addCode(new NakoCode(NakoCodeReturn, ''));\n        return '';\n    }\n    convCheckLoop(node, cmd) {\n        // ループの中であれば利用可能\n        if (!this.flagLoop) {\n            const cmdj = (cmd === 'continue') ? '続ける' : '抜ける';\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${cmdj}』文がありますが、それは繰り返しの中で利用してください。`, node);\n        }\n        if (cmd === 'continue') {\n            if (this.labelContinue) {\n                this.addCode(this.makeJump(this.labelContinue));\n            }\n        }\n        else {\n            if (this.labelBreak) {\n                this.addCode(this.makeJump(this.labelBreak));\n            }\n        }\n        return '';\n    }\n    convDefFuncCommon(node, name) {\n        // deffunc_code\n        const isMumeiFunc = (name === '');\n        let funcName = name;\n        if (isMumeiFunc) {\n            funcName = `無名関数:${this.loopId++}`;\n        }\n        const labelEnd = this.makeLabel(`関数「${funcName}」:ここまで`);\n        this.addCode(this.makeJump(labelEnd));\n        const labelBegin = this.makeLabelDirectly(funcName);\n        labelBegin.tag = NakoCodeTagIsFuncpoint; // 削除対象からはずすため\n        this.addCode(labelBegin);\n        //\n        const initialNames = new Set();\n        this.varsSet = { isFunction: true, names: initialNames, readonly: new Set() };\n        this.varsSet.names.add('それ');\n        // ローカル変数をPUSHする\n        this.varslistSet.push(this.varsSet);\n        // JSの引数と引数をバインド\n        const meta = isMumeiFunc ? node.meta : node.name.meta;\n        let code = '';\n        let codeCall = '';\n        code += `//関数『${funcName}』の初期化処理\\n`;\n        // 宣言済みの名前を保存\n        // const varsDeclared = Array.from(this.varsSet.names.values())\n        // 引数をローカル変数に設定 (スタックの末尾から取得する必要があるので、逆順に値を得る)\n        code += '// 引数をローカル変数として登録\\n';\n        for (let i = meta.varnames.length - 1; i >= 0; i--) {\n            const word = meta.varnames[i];\n            code += `  ${this.varname(word)} = sys.__stack.pop();\\n`;\n            this.varsSet.names.add(word);\n            codeCall += ''; //  sys.__stack.push(arguments[${i}]);\\n\n        }\n        code += '// ここまで:引数をローカル変数として登録\\n';\n        this.addCodeStr(code);\n        // 関数定義は、グローバル領域で。\n        this.usedFuncSet.add(funcName);\n        this.varslistSet[1].names.add(funcName);\n        this.nakoFuncList[funcName] = {\n            josi: meta.josi,\n            fn: '(function(){\\n' +\n                '  const sys = (arguments.length > 0) ? arguments[arguments.length-1] : {}; \\n' +\n                '  if (sys.newenv) { \\n' +\n                '    sys.newenv = false\\n' +\n                `    sys.__callNakoCodeEntry(sys.__labels['${funcName}'], sys);` + '\\n' +\n                '  } else {\\n' +\n                '  ' + codeCall + '\\n' +\n                `    sys.__callNakoCode(sys.__labels['${funcName}'], sys.nextIndex, sys);` + '\\n' +\n                '    if (!sys.inLoop) { sys.nextAsync(sys) }\\n' +\n                '  }  })',\n            type: 'func'\n        };\n        // ブロックを解析\n        this._convGen(node.block, false);\n        this.varslistSet.pop();\n        this.varsSet = this.varslistSet[this.varslistSet.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this.__self.__varslist[1][funcName] = function () { };\n        this.addCode(new NakoCode(NakoCodeReturn, ''));\n        this.addCode(labelEnd);\n        // 無名関数の定義であれば無名関数をPUSH\n        if (!name) {\n            this.addCodeStr(`sys.__stack.push('${funcName}')`);\n        }\n        return '';\n    }\n    convDefTest(node) {\n        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('テスト構文は!非同期モードでは使えません。', node);\n    }\n    convDefFunc(node) {\n        const name = _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen.getFuncName(node.name.value);\n        this.convDefFuncCommon(node, name);\n        // ★この時点では関数のコードを生成しない★\n        // プログラム冒頭でコード生成時に関数定義を行う\n        return '';\n    }\n    convFuncObj(node) {\n        return this.convDefFuncCommon(node, '');\n    }\n    convJsonObj(node) {\n        const list = node.value;\n        const objName = `sys.__tmp_obj${this.loopId++}`;\n        this.addCodeStr(objName + '={}; // convJsonObj::ここから');\n        list.forEach((e) => {\n            this._convGen(e.value, true);\n            this._convGen(e.key, true);\n            this.addCodeStr(`${objName}[sys.__stack.pop()]=sys.__stack.pop()`);\n        });\n        this.addCodeStr(`this.__stack.push(${objName}); delete $objName; // convJsonObj::ここまで`);\n        return '';\n    }\n    convJsonArray(node) {\n        const list = node.value;\n        this.addCode(this.makeLabel('convJsonArray::ここから'));\n        list.forEach((e) => this._convGen(e, true));\n        const size = list.length;\n        this.addCodeStr(`sys.__stack.push(sys.__stack.splice(sys.__stack.length-${size},${size}))`);\n        return '';\n    }\n    convRefArray(node) {\n        // 名前をPUSH\n        this._convGen(node.name, true);\n        const list = node.index;\n        for (let i = 0; i < list.length; i++) {\n            // push index\n            this._convGen(list[i], true);\n            // pop index & push value\n            this.addCodeStr('const idx = sys.__stack.pop();\\n' +\n                'const obj = sys.__stack.pop();\\n' +\n                'sys.__stack.push(obj[idx]);');\n        }\n        return '';\n    }\n    convLetArray(node) {\n        // 代入する値をPUSH\n        this._convGen(node.value, true);\n        // 変数を取得\n        this._convGen(node.name, true);\n        const list = node.index;\n        for (let i = 0; i < list.length; i++) {\n            this._convGen(list[i], true);\n            if (i === list.length - 1) { // 代入\n                this.addCodeStr('const idx = this.__stack.pop();' +\n                    'const obj = this.__stack.pop();' +\n                    'const val = this.__stack.pop();' +\n                    'obj[idx]=val;');\n                break;\n            }\n            // index アクセス\n            this.addCodeStr('const idx = sys.__stack.pop();\\n' +\n                'const obj = sys.__stack.pop();\\n' +\n                'sys.__stack.push(obj[idx]);');\n        }\n        return '';\n    }\n    convGenLoop(node) {\n        const tmpflag = this.flagLoop;\n        this.flagLoop = true;\n        try {\n            return this._convGen(node, false);\n        }\n        finally {\n            this.flagLoop = tmpflag;\n        }\n    }\n    convFor(node) {\n        this.flagLoop = true;\n        // ループ変数について\n        let word;\n        if (node.word !== null) { // ループ変数を使う時\n            const varName = node.word.value;\n            this.varsSet.names.add(varName);\n            word = this.varname(varName);\n        }\n        else {\n            this.varsSet.names.add('dummy');\n            word = this.varname('dummy');\n        }\n        const sore = this.varname('それ');\n        const idLoop = this.loopId++;\n        const varI = `sys.__tmp__i${idLoop}`;\n        // ループ条件を変数に入れる用\n        const varTo = `sys.__tmp__to${idLoop}`;\n        // ループ条件を確認\n        this._convGen(node.from, true);\n        this._convGen(node.to, true);\n        this.addCodeStr(`${varTo}=sys.__stack.pop();${varI}=sys.__stack.pop();`);\n        // ループ変数を初期化\n        this.addCodeStr(`${sore} = ${word} = ${varI}`);\n        // 繰り返し判定\n        const labelCheck = this.makeLabel('繰返:条件確認');\n        const labelInc = this.makeLabel('繰返:加算');\n        this.addCode(labelCheck);\n        const labelEnd = this.makeLabel('繰返:ここまで');\n        this.addCodeStr(`sys.__stack.push(${word} <= ${varTo})`);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        this.labelContinue = labelInc;\n        this.labelBreak = labelEnd;\n        // ループ内のブロック内容を得る\n        this.convGenLoop(node.block); // block\n        this.addCode(labelInc);\n        this.addCodeStr(`${sore} = ++${word};`);\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.addCodeStr(`delete ${varI};delete ${varTo};//繰返:掃除`);\n        this.flagLoop = false;\n        return '';\n    }\n    convForeach(node) {\n        this.flagLoop = true;\n        // 対象を用意する\n        let taisyo = '__v0[\"対象\"]';\n        const taisyoKey = '__v0[\"対象キー\"]';\n        if (node.name) {\n            taisyo = this.varname(node.name.value);\n            this.varsSet.names.add(node.name.value);\n        }\n        // 反復対象を調べる\n        const target = node.target;\n        if (target === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『反復』の対象がありません。', node);\n        }\n        const sore = this.varname('それ');\n        const targetArray = `sys.__tmp__target${this.loopId++}`;\n        const targetKeys = `sys.__tmp__keys${this.loopId++}`;\n        const loopVar = `sys.__tmp__i${this.loopId++}`;\n        const loopCount = `sys.__tmp__count${this.loopId++}`;\n        // 反復対象を評価\n        this._convGen(node.target, true);\n        // どのように反復するか判定\n        const initCode = '// 反復: 初期化\\n' +\n            `${targetArray} = sys.__stack.pop();\\n` +\n            `${loopVar} = 0;\\n` +\n            // 文字列や数値なら反復できるように配列に入れる\n            `if (typeof(${targetArray}) == 'string' || typeof(${targetArray}) == 'number') { ${targetArray} = [${targetArray}]; }\\n` +\n            // Objectならキー一覧を得る\n            `if (${targetArray} instanceof Array) { ${loopCount} = ${targetArray}.length; }\\n` +\n            'else { // キーの一覧を得る\\n' +\n            `  ${targetKeys} = Object.keys(${targetArray}); \\n` +\n            '  // hasOwnPropertyがfalseならばkeyを消す処理\\n' +\n            `  ${targetKeys} = ${targetKeys}.filter((key)=>{ return ${targetArray}.hasOwnProperty(key) })\\n` +\n            `  ${loopCount} = ${targetKeys}.length;\\n` +\n            '}\\n';\n        this.addCodeStr(initCode);\n        const labelCheck = this.makeLabel('反復:条件確認');\n        const labelInc = this.makeLabel('反復:加算');\n        const labelEnd = this.makeLabel('反復:ここまで');\n        this.labelBreak = labelEnd;\n        this.labelContinue = labelInc;\n        this.addCode(labelCheck);\n        const setTarget = `if (${targetArray} instanceof Array) {\\n` +\n            // eslint-disable-next-line no-irregular-whitespace\n            `  ${taisyo} = ${sore} = ${targetArray}[${loopVar}];　${taisyoKey} = ${loopVar};\\n` +\n            '} else {\\n' +\n            `  ${taisyoKey} = ${targetKeys}[${loopVar}]; ${taisyo} = ${sore} = ${targetArray}[${taisyoKey}];\\n` +\n            '}\\n';\n        this.addCodeStr(`${setTarget}\\nsys.__stack.push(${loopVar} < ${loopCount});`);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        // 反復ブロックを定義\n        this.convGenLoop(node.block); // block\n        // 加算\n        this.addCode(labelInc);\n        this.addCodeStr(`${loopVar}++`);\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    convWhile(node) {\n        this.flagLoop = true;\n        const labelBegin = this.makeLabel('間:ここから');\n        const labelEnd = this.makeLabel('間:ここまで');\n        this.labelContinue = labelBegin;\n        this.labelBreak = labelEnd;\n        this.addCode(labelBegin);\n        // 条件をスタックに\n        this._convGen(node.cond, true);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        // ブロックを追加\n        this.convGenLoop(node.block);\n        this.addCode(this.makeJump(labelBegin));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    /**\n     * @param {Ast} _node\n     * @param {boolean} _isExpression\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    convSpeedMode(_node, _isExpression) {\n        return '';\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convPerformanceMonitor(node, isExpression) {\n        const prev = { ...this.performanceMonitor };\n        if (node.options['ユーザ関数']) {\n            this.performanceMonitor.userFunction++;\n        }\n        if (node.options['システム関数本体']) {\n            this.performanceMonitor.systemFunctionBody++;\n        }\n        if (node.options['システム関数']) {\n            this.performanceMonitor.systemFunction++;\n        }\n        this._convGen(node.block, isExpression);\n        this.performanceMonitor = prev;\n    }\n    convSwitch(node) {\n        // 値をPUSH\n        this._convGen(node.value, true);\n        const varValue = `sys.__tmp__i${this.loopId++}`;\n        this.addCodeStr(`${varValue} = sys.__stack.pop()`);\n        const labelEnd = this.makeLabel('条件分岐:ここまで');\n        const cases = node.cases;\n        for (let i = 0; i < cases.length; i++) {\n            const cvalue = cases[i][0];\n            if (cvalue.type === '違えば') {\n                this.convGenLoop(cases[i][1]);\n            }\n            else {\n                const nextLabel = this.makeLabel('条件分岐:次');\n                this._convGen(cvalue, true);\n                this.addCodeStr(`sys.__stack.push(sys.__stack.pop() == ${varValue})`);\n                this.addCode(this.makeJumpIfFalse(nextLabel));\n                this.convGenLoop(cases[i][1]);\n                this.addCode(this.makeJump(labelEnd));\n                this.addCode(nextLabel);\n            }\n        }\n        this.addCode(labelEnd);\n        this.addCodeStr(`delete ${varValue}//条件分岐:掃除`);\n        return '';\n    }\n    convFuncGetArgsCalcType(funcName, func, node) {\n        const opts = {};\n        for (let i = 0; i < node.args.length; i++) {\n            const arg = node.args[i];\n            if (i === 0 && arg === null) {\n                this.addCodeStr('sys.__stack.push(sys.__vars[\\'それ\\'])');\n                opts.sore = true;\n            }\n            else {\n                // 関数の引数を評価\n                this._convGen(arg, true);\n            }\n        }\n        return opts;\n    }\n    getPluginList() {\n        const r = [];\n        for (const name in this.__self.__module) {\n            r.push(name);\n        }\n        return r;\n    }\n    /**\n     * 関数の呼び出し\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     * @returns string コード\n     */\n    convFunc(node, isExpression) {\n        let isJSFunc = false;\n        let isMumeiFunc = false;\n        const funcName = _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen.getFuncName(node.name);\n        const res = this.findVar(funcName);\n        if (res === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`関数『${funcName}』が見当たりません。有効プラグイン=[` + this.getPluginList().join(', ') + ']', node);\n        }\n        let func;\n        if (res.i === 0) { // plugin function\n            func = this.__self.getFunc(funcName);\n            if (func.type !== 'func') {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${funcName}』は関数ではありません。`, node);\n            }\n            isJSFunc = true;\n        }\n        else {\n            func = this.nakoFuncList[funcName];\n            // 無名関数の可能性\n            if (func === undefined) {\n                isMumeiFunc = true;\n                func = { return_none: false };\n            }\n        }\n        // 関数の参照渡しか？\n        if (node.type === 'func_pointer') {\n            return res.js;\n        }\n        // 関数の参照渡しでない場合\n        // 関数定義より助詞を一つずつ調べる\n        const argsOpts = this.convFuncGetArgsCalcType(funcName, func, node);\n        // function\n        this.usedFuncSet.add(funcName);\n        let funcBegin = '';\n        let funcEnd = '';\n        // setter?\n        if (node.setter) {\n            funcBegin += ';__self.isSetter = true;\\n';\n            funcEnd += ';__self.isSetter = false;\\n';\n        }\n        // 変数「それ」が補完されていることをヒントとして出力\n        if (argsOpts.sore) {\n            funcBegin += '/*[sore]*/';\n        }\n        // 引数をスタックに積む\n        const arcCount = node.args.length;\n        // 必要な引数分だけスタックから下ろして呼び出す\n        let code = '';\n        if (isJSFunc) {\n            code += funcBegin;\n            code += `const args = sys.__stack.splice(sys.__stack.length - ${arcCount}, ${arcCount});\\n`;\n            // code += `console.log(\"call:${funcName}\", args, 'sys');\\n`\n            code += 'args.push(sys);\\n';\n            code += `const ret = ${res.js}.apply(sys, args);\\n`;\n            if (!func.return_none) {\n                code += 'sys.__vars[\\'それ\\'] = ret;\\n';\n                if (isExpression) {\n                    code += 'sys.__stack.push(ret);\\n';\n                }\n            }\n            code += funcEnd;\n            this.addCodeStr(code);\n        }\n        else {\n            if (isMumeiFunc) {\n                this.addCode(new NakoCode(NakoCodeCallObj, funcName));\n            }\n            else {\n                this.addCode(new NakoCode(NakoCodeCall, funcName));\n            }\n            if (!isExpression) {\n                this.addCodeStr('sys.__stack.pop();// 戻り値を利用しない関数呼出');\n            }\n        }\n    }\n    convRenbun(node) {\n        this._convGen(node.left, false);\n        this._convGen(node.right, true);\n    }\n    convOp(node) {\n        const OP_TBL = {\n            '&': '+\"\"+',\n            eq: '==',\n            noteq: '!=',\n            '===': '===',\n            '!==': '!==',\n            gt: '>',\n            lt: '<',\n            gteq: '>=',\n            lteq: '<=',\n            and: '&&',\n            or: '||',\n            shift_l: '<<',\n            shift_r: '>>',\n            shift_r0: '>>>',\n            '÷': '/'\n        };\n        const op = node.operator; // 演算子\n        // 値はスタックに載せられる\n        // left\n        this._convGen(node.left, true);\n        // right\n        this._convGen(node.right, true);\n        // calc\n        let code = 'const rv = sys.__stack.pop();\\n' +\n            'const lv = sys.__stack.pop();\\n';\n        if (op === '^') {\n            code += 'const v = (Math.pow(lv, rv))\\n';\n        }\n        else {\n            const op2 = OP_TBL[op] || op;\n            code += `const v = ((lv) ${op2} (rv));\\n`;\n        }\n        // code += `if (isNaN(v) && '${op}' != '&') { console.log('ERROR:${op}', lv, rv) }\\n`\n        code += `sys.__stack.push(v); //op:${op}\\n`;\n        this.addCodeStr(code);\n    }\n    convLet(node) {\n        let code = '';\n        // 値をスタックに載せる\n        if (node.value === null) {\n            // 値が省略されたら「それ」を載せる\n            this.addCodeStr('sys.__stack.push(sys.__vars[\\'それ\\'])');\n        }\n        else {\n            // 値がある場合\n            this._convGen(node.value, true);\n        }\n        // 変数名\n        const name = node.name.value;\n        const res = this.findVar(name);\n        if (res === null) {\n            this.varsSet.names.add(name);\n            code = `${this.varname(name)}=sys.__stack.pop();`;\n        }\n        else {\n            // 定数ならエラーを出す\n            if (this.varslistSet[res.i].readonly.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`定数『${name}』は既に定義済みなので、値を代入することはできません。`, node);\n            }\n            code = `${res.js}=sys.__stack.pop();`;\n        }\n        this.addCodeStr(code + '//let');\n    }\n    convDefLocalVar(node) {\n        if (node.value === null) {\n            this.addCodeStr('sys.__stack.push(null)');\n        }\n        else {\n            this._convGen(node.value, true);\n        }\n        const name = node.name.value;\n        const vtype = node.vartype; // 変数 or 定数\n        // 二重定義？\n        if (this.varsSet.names.has(name)) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n        }\n        this.varsSet.names.add(name);\n        // 定数?\n        if (vtype === '定数') {\n            this.varsSet.readonly.add(name);\n        }\n        this.addCodeStr(`${this.varname(name)}=sys.__stack.pop()`);\n        return '';\n    }\n    // #563 複数変数への代入\n    convDefLocalVarlist(node) {\n        const vtype = node.vartype; // 変数 or 定数\n        if (node.value === null) {\n            this.addCodeStr('sys.__stack.push(null)');\n        }\n        else {\n            this._convGen(node.value, true);\n        }\n        const varI = `sys.__tmp_i${this.loopId}`;\n        this.loopId++;\n        this.addCodeStr(`${varI}=sys.__stack.pop();if (!(${varI} instanceof Array)) { ${varI}=[${varI}] }`);\n        for (const nameObj of node.names) {\n            const name = nameObj.value;\n            // 二重定義？\n            if (this.varsSet.names.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n            }\n            //\n            this.varsSet.names.add(name);\n            if (vtype === '定数') {\n                this.varsSet.readonly.add(name);\n            }\n            const vname = this.varname(name);\n            this.addCodeStr(`${vname}=${varI}.pop()`);\n        }\n        this.addCodeStr(`delete ${varI}//複数代入:掃除`);\n        return '';\n    }\n    convString(node) {\n        let value = '' + node.value;\n        const mode = node.mode;\n        value = value.replace(/\\\\/g, '\\\\\\\\');\n        value = value.replace(/\"/g, '\\\\\"');\n        value = value.replace(/\\r/g, '\\\\r');\n        value = value.replace(/\\n/g, '\\\\n');\n        if (mode === 'ex') {\n            throw new Error('[システムエラー] ジェネレーターでの文字列の展開はサポートしていません');\n        }\n        this.addCodeStr(`sys.__stack.push(\"${value}\")//string`);\n        return '\"' + value + '\"';\n    }\n    convTryExcept(node) {\n        const labelExcept = this.makeLabel('エラー監視:ならば');\n        const labelEnd = this.makeLabel('エラー監視:ここまで');\n        // エラーをひっかけるように設定\n        this.addCode(new NakoCode(NakoCodeTry, labelExcept.value));\n        this._convGen(node.block, false);\n        this.addCode(this.makeJump(labelEnd));\n        this.addCode(labelExcept);\n        this._convGen(node.errBlock, false);\n        this.addCode(labelEnd);\n    }\n}\n// ブラウザに登録する\nif (typeof (navigator) === 'object' && typeof (navigator.nako3) === 'object') {\n    // Webブラウザの場合\n    const nako3 = navigator.nako3;\n    if (nako3.addCodeGenerator) {\n        nako3.addCodeGenerator('非同期モード', NakoGenASync);\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_gen_async.mjs?")},"./core/src/nako_global.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoGlobal\": function() { return /* binding */ NakoGlobal; }\n/* harmony export */ });\n/* harmony import */ var _nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_colors.mjs */ \"./core/src/nako_colors.mjs\");\n\n/**\n * コンパイルされたなでしこのプログラムで、グローバル空間のthisが指すオブジェクト\n */\nclass NakoGlobal {\n    /**\n     * @param compiler\n     * @param gen\n     */\n    constructor(compiler, gen, guid = 0) {\n        this.guid = guid;\n        // ユーザーのプログラムから編集される変数\n        this.__locals = {};\n        this.__varslist = [\n            { ...compiler.__varslist[0] },\n            { ...compiler.__varslist[1] },\n            { ...compiler.__varslist[2] } // local [2][3][4][5] ...\n        ];\n        this.numFailures = 0;\n        this.index = 0;\n        this.nextIndex = -1;\n        this.__code = [];\n        this.__callstack = [];\n        this.__stack = [];\n        this.__labels = [];\n        this.__genMode = gen.genMode;\n        // バージョン情報の引き継ぎ\n        this.version = compiler.version;\n        this.coreVersion = compiler.coreVersion;\n        // PluginSystemとdestroy()から参照するため\n        this.__module = { ...compiler.__module }; // shallow copy\n        this.pluginfiles = { ...compiler.getPluginfiles() };\n        // PluginWorkerでユーザー定義関数のJavaScriptコードをworkerのコンパイラのインスタンスへコピーするため\n        this.gen = gen;\n        // 以下のメソッドで使うため\n        this.logger = compiler.getLogger();\n        this.compiler = compiler;\n    }\n    clearLog() {\n        this.__varslist[0]['表示ログ'] = '';\n    }\n    get log() {\n        let s = this.__varslist[0]['表示ログ'];\n        s = s.replace(/\\s+$/, '');\n        return s;\n    }\n    /**\n     * 「ナデシコ」命令のためのメソッド\n     * @param {string} code\n     * @param {string} fname\n     * @param {CompilerOptions} opts\n     * @param {string} [preCode]\n     */\n    runEx(code, fname, opts, preCode = '') {\n        // スコープを共有して実行\n        opts.preCode = preCode;\n        opts.nakoGlobal = this;\n        return this.compiler.runSync(code, fname, opts);\n    }\n    /**\n     * テスト実行のためのメソッド\n     * @param {{ name: string, f: () => void }[]} tests\n     */\n    _runTests(tests) {\n        let text = `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.bold}テストの実行結果${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.reset}\\n`;\n        let pass = 0;\n        let numFailures = 0;\n        for (const t of tests) {\n            try {\n                t.f();\n                text += `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.green}✔${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.reset} ${t.name}\\n`;\n                pass++;\n            }\n            catch (err) {\n                text += `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.red}☓${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.reset} ${t.name}: ${err.message}\\n`;\n                numFailures++;\n            }\n        }\n        if (numFailures > 0) {\n            text += `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.green}成功 ${pass}件 ${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.red}失敗 ${numFailures}件`;\n        }\n        else {\n            text += `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoColors.color.green}成功 ${pass}件`;\n        }\n        this.numFailures = numFailures;\n        this.logger.stdout(text);\n    }\n    /**\n     * 毎プラグインの「!クリア」関数を実行\n     */\n    clearPlugins() {\n        const clearName = '!クリア';\n        for (const pname in this.pluginfiles) {\n            const po = this.__module[pname];\n            if (po[clearName] && po[clearName].fn) {\n                po[clearName].fn(this);\n            }\n        }\n    }\n    /**\n     * 各種リセット処理\n     */\n    reset() {\n        this.clearPlugins();\n    }\n    destroy() {\n        this.reset();\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_global.mjs?")},"./core/src/nako_indent.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getBlockStructure\": function() { return /* binding */ getBlockStructure; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_prepare.mjs */ \"./core/src/nako_prepare.mjs\");\n\n\n// インデント構文のキーワード\nconst INDENT_MODE_KEYWORDS = ['!インデント構文', '!ここまでだるい'];\n/**\n * インデント構文指定があればコードを変換する\n * @param {string} code\n * @param {string} filename\n */\nfunction convert(code, filename = 'main.nako3') {\n    // インデント構文の適用が必要か？\n    if ((0,_nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_1__.checkNakoMode)(code, INDENT_MODE_KEYWORDS)) {\n        return convertGo(code, filename);\n    }\n    return { code, insertedLines: [], deletedLines: [] };\n}\n/**\n * インデント構文指定があるかチェックする\n * @param {string} code\n * @returns {boolean}\n */\nfunction isIndentSyntaxEnabled(code) {\n    return (0,_nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_1__.checkNakoMode)(code, INDENT_MODE_KEYWORDS);\n}\n// ありえない改行マークを定義\nconst SpecialRetMark = '🌟🌟改行🌟🌟s4j#WjcSb😀/FcX3🌟🌟';\n/**\n * ソースコードのある1行の中のコメントを全て取り除く。\n * 事前にreplaceRetMarkによって文字列や範囲コメント内の改行文字が置換されている必要がある。\n * @param {string} src\n * @return {string}\n */\nfunction removeCommentsFromLine(src) {\n    const prepare = _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoPrepare.getInstance(); // `※`, `／/`, `／＊` といったパターン全てに対応するために必要\n    const len = src.length;\n    let result = '';\n    let eos = '';\n    let i = 0;\n    let isComment = false;\n    while (i < len) {\n        const c = src.charAt(i);\n        const ch2 = src.substring(i, 2);\n        const cPrepared = prepare.convert1ch(c);\n        const ch2Prepared = ch2.split('').map((c) => prepare.convert1ch(c)).join('');\n        // eosか?\n        if (eos !== '') {\n            // srcのi文字目以降がeosで始まるなら文字列を終了、そうでなければ1文字進める\n            if (eos === (eos.length === 1 ? cPrepared : ch2Prepared)) {\n                if (!isComment) {\n                    result += src.substr(i, eos.length);\n                }\n                i += eos.length;\n                isComment = false;\n                eos = '';\n            }\n            else {\n                if (!isComment) {\n                    result += c;\n                }\n                i++;\n            }\n            continue;\n        }\n        // 文字列の改行\bも無視する\n        switch (cPrepared) {\n            case '\"':\n            case '\\'':\n                eos = c;\n                result += c;\n                i++;\n                continue;\n            case '「':\n                eos = '」';\n                result += c;\n                i++;\n                continue;\n            case '『':\n                eos = '』';\n                result += c;\n                i++;\n                continue;\n            case '“':\n                eos = '”';\n                result += c;\n                i++;\n                continue;\n            case '{':\n                eos = '}';\n                result += c;\n                i++;\n                continue;\n            case '[':\n                eos = ']';\n                result += c;\n                i++;\n                continue;\n        }\n        switch (ch2) {\n            case '🌴':\n                eos = '🌴';\n                result += ch2;\n                i += 2;\n                continue;\n            case '🌿':\n                eos = '🌿';\n                result += ch2;\n                i += 2;\n                continue;\n        }\n        // 行コメント\n        if (cPrepared === '#') {\n            eos = '\\n';\n            isComment = true;\n            i++;\n            continue;\n        }\n        if (ch2Prepared === '//') {\n            eos = '\\n';\n            isComment = true;\n            i += 2;\n            continue;\n        }\n        // 範囲コメント\n        if (ch2Prepared === '/*') {\n            eos = '*/';\n            isComment = true;\n            i += 2;\n            continue;\n        }\n        result += c;\n        i++;\n    }\n    return result;\n}\n/**\n * @param {string} code\n * @param {string} filename\n * @returns {{ code: string, insertedLines: number[], deletedLines: { lineNumber: number, len: number }[] }}\n */\nfunction convertGo(code, filename) {\n    const insertedLines = [];\n    const deletedLines = [];\n    const END = 'ここまで‰';\n    const code2 = replaceRetMark(code); // 文字列の中などの改行を置換\n    const lines = code2.split('\\n');\n    const lines2 = [];\n    const indentStack = [];\n    let lastIndent = 0;\n    let lineCount = -1;\n    lines.forEach((line) => {\n        lineCount += line.split(SpecialRetMark).length;\n        // trim line\n        // eslint-disable-next-line no-irregular-whitespace\n        if (/^[ 　・\\t]*$/.test(line)) {\n            deletedLines.push({ lineNumber: lines2.length, len: line.length });\n            return;\n        }\n        // eslint-disable-next-line no-irregular-whitespace\n        const lineTrimed = removeCommentsFromLine(line).replace(/^[ 　・\\t]+/, '').replace(/\\s+$/, '');\n        if (lineTrimed === '') {\n            lines2.push(line);\n            return;\n        }\n        if (lineTrimed === 'ここまで') {\n            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoIndentError('インデント構文が有効化されているときに『ここまで』を使うことはできません。', lineCount, filename);\n        }\n        // check indent\n        const indent = countIndent(line);\n        if (lastIndent === indent) {\n            lines2.push(line);\n            return;\n        }\n        // indent\n        if (lastIndent < indent) {\n            indentStack.push(lastIndent);\n            lastIndent = indent;\n            lines2.push(line);\n            return;\n        }\n        // unindent\n        if (lastIndent > indent) {\n            // 5回\n            //   3回\n            //     1を表示\n            //   |\n            // |\n            lastIndent = indent;\n            while (indentStack.length > 0) {\n                const n = indentStack.pop() || 0;\n                if (n === indent) {\n                    if (lineTrimed.substring(0, 3) !== '違えば') {\n                        insertedLines.push(lines2.length);\n                        lines2.push(makeIndent(n) + END);\n                    }\n                    lines2.push(line);\n                    return;\n                }\n                if (indent < n) {\n                    insertedLines.push(lines2.length);\n                    lines2.push(makeIndent(n) + END);\n                    continue;\n                }\n            }\n        }\n    });\n    // 残りのインデントを処理\n    while (indentStack.length > 0) {\n        const n = indentStack.pop() || 0;\n        insertedLines.push(lines2.length);\n        lines2.push(makeIndent(n) + END);\n    }\n    // 特別マーカーを改行に置換\n    const lines3 = [];\n    for (let i = 0; i < lines2.length; i++) {\n        if (lines2[i].includes(SpecialRetMark)) {\n            const lines4 = lines2[i].split(SpecialRetMark);\n            // 置換されたマーカーの数だけ、それ以降の行数をずらす。\n            // unindentによって挿入された行がSpecialRetMarkを含むことはない。\n            for (let j = 0; j < insertedLines.length; j++) {\n                if (lines3.length < insertedLines[j]) {\n                    insertedLines[j] += lines4.length - 1;\n                }\n            }\n            for (let j = 0; j < deletedLines.length; j++) {\n                if (lines3.length < deletedLines[j].lineNumber) {\n                    deletedLines[j].lineNumber += lines4.length - 1;\n                }\n            }\n            lines3.push(...lines4);\n        }\n        else {\n            lines3.push(lines2[i]);\n        }\n    }\n    return { code: lines3.join('\\n'), insertedLines, deletedLines };\n}\n/**\n * count分だけ字下げする\n * @param {number} count\n */\nfunction makeIndent(count) {\n    let s = '';\n    for (let i = 0; i < count; i++) {\n        s += ' ';\n    }\n    return s;\n}\n/**\n * インデント部分を取り出す\n * @param {string} line\n */\nfunction getIndent(line) {\n    // eslint-disable-next-line no-irregular-whitespace\n    const m = /^([ 　・\\t]*)/.exec(removeCommentsFromLine(line));\n    if (!m) {\n        return '';\n    }\n    return m[1];\n}\n/**\n * インデントの個数を数える\n * @param {string} line\n */\nfunction countIndent(line) {\n    let cnt = 0;\n    for (let i = 0; i < line.length; i++) {\n        const ch = line.charAt(i);\n        if (ch === ' ') {\n            cnt++;\n            continue;\n        }\n        if (ch === '　') {\n            cnt += 2;\n            continue;\n        }\n        if (ch === '・') {\n            cnt += 2;\n            continue;\n        }\n        if (ch === '\\t') {\n            cnt += 4;\n            continue;\n        }\n        break;\n    }\n    return cnt;\n}\n/**\n * @param {string} src\n * @returns {string}\n */\nfunction replaceRetMark(src) {\n    const prepare = _nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoPrepare.getInstance(); // `※`, `／/`, `／＊` といったパターン全てに対応するために必要\n    const len = src.length;\n    let result = '';\n    let eos = '';\n    let i = 0;\n    while (i < len) {\n        const c = src.charAt(i);\n        const ch2 = src.substr(i, 2);\n        const cPrepared = prepare.convert1ch(c);\n        const ch2Prepared = ch2.split('').map((c) => prepare.convert1ch(c)).join('');\n        // eosか?\n        if (eos !== '') {\n            // srcのi文字目以降がeosで始まるなら文字列を終了、そうでなければ1文字進める\n            if (eos === (eos.length === 1 ? cPrepared : ch2Prepared)) {\n                result += src.substr(i, eos.length);\n                i += eos.length;\n                eos = '';\n            }\n            else {\n                if (c === '\\n') {\n                    result += SpecialRetMark;\n                }\n                else {\n                    result += c;\n                }\n                i++;\n            }\n            continue;\n        }\n        // 文字列の改行\bも無視する\n        switch (cPrepared) {\n            case '\"':\n            case '\\'':\n                eos = c;\n                result += c;\n                i++;\n                continue;\n            case '「':\n                eos = '」';\n                result += c;\n                i++;\n                continue;\n            case '『':\n                eos = '』';\n                result += c;\n                i++;\n                continue;\n            case '“':\n                eos = '”';\n                result += c;\n                i++;\n                continue;\n            case '{':\n                eos = '}';\n                result += c;\n                i++;\n                continue;\n            case '[':\n                eos = ']';\n                result += c;\n                i++;\n                continue;\n        }\n        switch (ch2) {\n            case '🌴':\n                eos = '🌴';\n                result += ch2;\n                i += 2;\n                continue;\n            case '🌿':\n                eos = '🌿';\n                result += ch2;\n                i += 2;\n                continue;\n        }\n        // 行コメント\n        if (cPrepared === '#') {\n            eos = '\\n';\n            result += c;\n            i++;\n            continue;\n        }\n        if (ch2Prepared === '//') {\n            eos = '\\n';\n            result += ch2;\n            i += 2;\n            continue;\n        }\n        // 範囲コメント\n        if (ch2Prepared === '/*') {\n            eos = '*/';\n            result += ch2;\n            i += 2;\n            continue;\n        }\n        result += c;\n        i++;\n    }\n    return result;\n}\n/**\n * コードのインデントの構造を取得する。\n * 空白行や複数行にまたがる構文を考慮する。\n * インデント構文が有効化されていない場合にも使われる。\n * @param {string} code\n */\nfunction getBlockStructure(code) {\n    const result = {\n        lines: [],\n        pairs: [],\n        parents: [],\n        spaces: [] // 各行のインデントの文字列\n    };\n    const lines = replaceRetMark(code).split('\\n');\n    const stack = [];\n    let lineCount = 0;\n    let prev = countIndent(lines[0]);\n    for (const line of lines) {\n        const numLines = line.split(SpecialRetMark).length;\n        const line2 = removeCommentsFromLine(line);\n        // eslint-disable-next-line no-irregular-whitespace\n        const current = (line2.replace(/^[ 　・\\t]+/, '') === '')\n            ? prev\n            : countIndent(line2);\n        result.lines.push(...Array(numLines).fill(current));\n        result.spaces.push(...Array(numLines).fill(getIndent(line2)));\n        if (prev < current) {\n            stack.push(lineCount - 1);\n        }\n        else if (prev > current) {\n            const last = stack.pop();\n            if (last !== undefined) {\n                result.pairs.push([last, lineCount]);\n            }\n        }\n        const parent = stack[stack.length - 1] !== undefined ? stack[stack.length - 1] : null;\n        result.parents.push(...Array(numLines).fill(parent));\n        prev = current;\n        lineCount += numLines;\n    }\n    // スタックが余ったらコードの末尾とペアにする。\n    for (const item of stack) {\n        result.pairs.push([item, lineCount]);\n    }\n    return result;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    convert,\n    getBlockStructure,\n    getIndent,\n    countIndent,\n    isIndentSyntaxEnabled\n});\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_indent.mjs?")},"./core/src/nako_josi_list.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"josiList\": function() { return /* binding */ josiList; },\n/* harmony export */   \"josiRE\": function() { return /* binding */ josiRE; },\n/* harmony export */   \"removeJosiList\": function() { return /* binding */ removeJosiList; },\n/* harmony export */   \"removeJosiMap\": function() { return /* binding */ removeJosiMap; },\n/* harmony export */   \"tararebaJosiList\": function() { return /* binding */ tararebaJosiList; },\n/* harmony export */   \"tararebaMap\": function() { return /* binding */ tararebaMap; }\n/* harmony export */ });\n/**\n * 助詞の一覧\n */\nconst josiList = [\n    'について', 'くらい', 'なのか', 'までを', 'までの', 'による',\n    'とは', 'から', 'まで', 'だけ', 'より', 'ほど', 'など',\n    'いて', 'えて', 'きて', 'けて', 'して', 'って', 'にて', 'みて',\n    'めて', 'ねて', 'では', 'には', 'は~', 'んで', 'ずつ',\n    'は', 'を', 'に', 'へ', 'で', 'と', 'が', 'の'\n];\n// 「もし」文で使う助詞\nconst tararebaJosiList = [\n    'でなければ', 'なければ', 'ならば', 'なら', 'たら', 'れば'\n];\n// 意味のない助詞(削除する) #936 #939 #974\nconst removeJosiList = [\n    'こと', 'である', 'です', 'します', 'でした'\n];\n/**\n * 「もし」文で使う「たら」「れば」などの一覧をプログラムで扱いやすいようマップに変換したもの\n */\nconst tararebaMap = {};\ntararebaJosiList.forEach(josi => {\n    josiList.push(josi);\n    tararebaMap[josi] = true;\n});\n/**\n * 意味のない助詞(削除する)をマップに変換したもの\n */\nconst removeJosiMap = {};\nremoveJosiList.forEach(josi => {\n    josiList.push(josi);\n    removeJosiMap[josi] = true;\n});\n// 文字数の長い順に並び替え\njosiList.sort((a, b) => b.length - a.length);\n// 正規表現で助詞をマッチできるようにする\nconst josiRE = new RegExp('^[\\\\t ]*(' + josiList.join('|') + ')');\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_josi_list.mjs?")},"./core/src/nako_lex_rules.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rules\": function() { return /* binding */ rules; },\n/* harmony export */   \"trimOkurigana\": function() { return /* binding */ trimOkurigana; },\n/* harmony export */   \"unitRE\": function() { return /* binding */ unitRE; }\n/* harmony export */ });\n/* harmony import */ var _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_josi_list.mjs */ \"./core/src/nako_josi_list.mjs\");\n/**\n * なでしこ3字句解析のためのルール\n */\n\nconst kanakanji = /^[\\u3005\\u4E00-\\u9FCF_a-zA-Z0-9ァ-ヶー\\u2460-\\u24FF\\u2776-\\u277F\\u3251-\\u32BF]+/;\nconst hira = /^[ぁ-ん]/;\nconst allHiragana = /^[ぁ-ん]+$/;\nconst wordHasIjoIka = /^.+(以上|以下|超|未満)$/;\nconst errorRead = (ch) => {\n    return function () { throw new Error('突然の『' + ch + '』があります。'); };\n};\nconst unitRE = /^(円|ドル|元|歩|㎡|坪|度|℃|°|個|つ|本|冊|才|歳|匹|枚|皿|セット|羽|人|件|行|列|機|品|m|mm|cm|km|g|kg|t|px|dot|pt|em|b|mb|kb|gb)/;\nconst rules = [\n    // 上から順にマッチさせていく\n    { name: 'ここまで', pattern: /^;;;/ },\n    { name: 'eol', pattern: /^\\n/ },\n    { name: 'eol', pattern: /^;/ },\n    // eslint-disable-next-line no-control-regex\n    { name: 'space', pattern: /^(\\x20|\\x09|・)+/ },\n    { name: 'comma', pattern: /^,/ },\n    { name: 'line_comment', pattern: /^#[^\\n]*/ },\n    { name: 'line_comment', pattern: /^\\/\\/[^\\n]*/ },\n    { name: 'range_comment', pattern: /^\\/\\*/, cbParser: cbRangeComment },\n    { name: 'def_test', pattern: /^●テスト:/ },\n    { name: 'def_func', pattern: /^●/ },\n    // 数値の判定 --- この後nako_lexerにて単位を読む処理が入る(#994)\n    { name: 'number', pattern: /^0[xX][0-9a-fA-F]+(_[0-9a-fA-F]+)*/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^0[oO][0-7]+(_[0-7]+)*/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^0[bB][0-1]+(_[0-1]+)*/, readJosi: true, cb: parseNumber },\n    // 下の三つは小数点が挟まっている場合、小数点から始まっている場合、小数点がない場合の十進法の数値にマッチします\n    { name: 'number', pattern: /^\\d+(_\\d+)*\\.(\\d+(_\\d+)*)?([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^\\.\\d+(_\\d+)*([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^\\d+(_\\d+)*([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'ここから', pattern: /^(ここから),?/ },\n    { name: 'ここまで', pattern: /^(ここまで|💧)/ },\n    { name: 'もし', pattern: /^もしも?/ },\n    // 「ならば」は助詞として定義している\n    { name: '違えば', pattern: /^違(えば)?/ },\n    // 「回」「間」「繰返」「反復」「抜」「続」「戻」「代入」「条件分岐」などは NakoLexer._replaceWord で word から変換\n    // @see nako_reserved_words.js\n    { name: 'shift_r0', pattern: /^>>>/ },\n    { name: 'shift_r', pattern: /^>>/ },\n    { name: 'shift_l', pattern: /^<</ },\n    { name: '===', pattern: /^===/ },\n    { name: '!==', pattern: /^!==/ },\n    { name: 'gteq', pattern: /^(≧|>=|=>)/ },\n    { name: 'lteq', pattern: /^(≦|<=|=<)/ },\n    { name: 'noteq', pattern: /^(≠|<>|!=)/ },\n    { name: '←', pattern: /^(←|<--)/ },\n    { name: 'eq', pattern: /^(=|🟰)/ },\n    { name: 'line_comment', pattern: /^(!|💡)(インデント構文|ここまでだるい)[^\\n]*/ },\n    { name: 'not', pattern: /^(!|💡)/ },\n    { name: 'gt', pattern: /^>/ },\n    { name: 'lt', pattern: /^</ },\n    { name: 'and', pattern: /^(かつ|&&)/ },\n    { name: 'or', pattern: /^(または|或いは|あるいは|\\|\\|)/ },\n    { name: '@', pattern: /^@/ },\n    { name: '+', pattern: /^\\+/ },\n    { name: '-', pattern: /^-/ },\n    { name: '*', pattern: /^(×|\\*)/ },\n    { name: '÷÷', pattern: /^÷÷/ },\n    { name: '÷', pattern: /^(÷|\\/)/ },\n    { name: '%', pattern: /^%/ },\n    { name: '^', pattern: /^\\^/ },\n    { name: '&', pattern: /^&/ },\n    { name: '[', pattern: /^\\[/ },\n    { name: ']', pattern: /^]/, readJosi: true },\n    { name: '(', pattern: /^\\(/ },\n    { name: ')', pattern: /^\\)/, readJosi: true },\n    { name: '|', pattern: /^\\|/ },\n    { name: 'string', pattern: /^🌿/, cbParser: src => cbString('🌿', '🌿', src) },\n    { name: 'string_ex', pattern: /^🌴/, cbParser: src => cbString('🌴', '🌴', src) },\n    { name: 'string_ex', pattern: /^「/, cbParser: src => cbString('「', '」', src) },\n    { name: 'string', pattern: /^『/, cbParser: src => cbString('『', '』', src) },\n    { name: 'string_ex', pattern: /^“/, cbParser: src => cbString('“', '”', src) },\n    { name: 'string_ex', pattern: /^\"/, cbParser: src => cbString('\"', '\"', src) },\n    { name: 'string', pattern: /^'/, cbParser: src => cbString('\\'', '\\'', src) },\n    { name: '」', pattern: /^」/, cbParser: errorRead('」') },\n    { name: '』', pattern: /^』/, cbParser: errorRead('』') },\n    { name: 'func', pattern: /^\\{関数\\},?/ },\n    { name: '{', pattern: /^\\{/ },\n    { name: '}', pattern: /^\\}/, readJosi: true },\n    { name: ':', pattern: /^:/ },\n    { name: '_eol', pattern: /^_\\s*\\n/ },\n    { name: 'dec_lineno', pattern: /^‰/ },\n    // 絵文字変数 = (絵文字)英数字*\n    { name: 'word', pattern: /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF][_a-zA-Z0-9]*/, readJosi: true },\n    { name: 'word', pattern: /^[\\u1F60-\\u1F6F][_a-zA-Z0-9]*/, readJosi: true },\n    { name: 'word', pattern: /^《.+?》/, readJosi: true },\n    // 単語句\n    {\n        name: 'word',\n        pattern: /^[_a-zA-Z\\u3005\\u4E00-\\u9FCFぁ-んァ-ヶ\\u2460-\\u24FF\\u2776-\\u277F\\u3251-\\u32BF]/,\n        cbParser: cbWordParser\n    }\n];\nfunction trimOkurigana(s) {\n    // ひらがなから始まらない場合、送り仮名を削除。(例)置換する\n    if (!hira.test(s)) {\n        return s.replace(/[ぁ-ん]+/g, '');\n    }\n    // 全てひらがな？ (例) どうぞ\n    if (allHiragana.test(s)) {\n        return s;\n    }\n    // 末尾のひらがなのみ (例)お願いします →お願\n    return s.replace(/[ぁ-ん]+$/g, '');\n}\n// Utility for Rule\nfunction cbRangeComment(src) {\n    let res = '';\n    const josi = '';\n    let numEOL = 0;\n    src = src.substring(2); // skip /*\n    const i = src.indexOf('*/');\n    if (i < 0) { // not found\n        res = src;\n        src = '';\n    }\n    else {\n        res = src.substring(0, i);\n        src = src.substring(i + 2);\n    }\n    // 改行を数える\n    for (let i = 0; i < res.length; i++) {\n        if (res.charAt(i) === '\\n') {\n            numEOL++;\n        }\n    }\n    res = res.replace(/(^\\s+|\\s+$)/, ''); // trim\n    return { src, res, josi, numEOL };\n}\n/**\n * @param {string} src\n */\nfunction cbWordParser(src, isTrimOkurigana = true) {\n    /*\n      kanji    = [\\u3005\\u4E00-\\u9FCF]\n      hiragana = [ぁ-ん]\n      katakana = [ァ-ヶー]\n      emoji    = [\\u1F60-\\u1F6F]\n      uni_extra = [\\uD800-\\uDBFF] [\\uDC00-\\uDFFF]\n      alphabet = [_a-zA-Z]\n      numchars = [0-9]\n    */\n    let res = '';\n    let josi = '';\n    while (src !== '') {\n        if (res.length > 0) {\n            // 助詞の判定\n            const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.josiRE.exec(src);\n            if (j) {\n                josi = j[0].replace(/^\\s+/, '');\n                src = src.substr(j[0].length);\n                // 助詞の直後にある「,」を飛ばす #877\n                if (src.charAt(0) === ',') {\n                    src = src.substr(1);\n                }\n                break;\n            }\n        }\n        // カタカナ漢字英数字か？\n        const m = kanakanji.exec(src);\n        if (m) {\n            res += m[0];\n            src = src.substr(m[0].length);\n            continue;\n        }\n        // ひらがな？\n        const h = hira.test(src);\n        if (h) {\n            res += src.charAt(0);\n            src = src.substr(1);\n            continue;\n        }\n        break; // other chars\n    }\n    // 「間」の特殊ルール (#831)\n    // 「等しい間」や「一致する間」なら「間」をsrcに戻す。ただし「システム時間」はそのままにする。\n    if (/[ぁ-ん]間$/.test(res)) {\n        src = res.charAt(res.length - 1) + src;\n        res = res.slice(0, -1);\n    }\n    // 「以上」「以下」「超」「未満」 #918\n    const ii = wordHasIjoIka.exec(res);\n    if (ii) {\n        src = ii[1] + josi + src;\n        josi = '';\n        res = res.substr(0, res.length - ii[1].length);\n    }\n    // 助詞「こと」「である」「です」などは「＊＊すること」のように使うので削除 #936 #939 #974\n    if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.removeJosiMap[josi]) {\n        josi = '';\n    }\n    // 漢字カタカナ英語から始まる語句 --- 送り仮名を省略\n    if (isTrimOkurigana) {\n        res = trimOkurigana(res);\n    }\n    // 助詞だけの語句の場合\n    if (res === '' && josi !== '') {\n        res = josi;\n        josi = '';\n    }\n    return { src, res, josi, numEOL: 0 };\n}\nfunction cbString(beginTag, closeTag, src) {\n    let res = '';\n    let josi = '';\n    let numEOL = 0;\n    src = src.substr(beginTag.length); // skip beginTag\n    const i = src.indexOf(closeTag);\n    if (i < 0) { // not found\n        res = src;\n        src = '';\n    }\n    else {\n        res = src.substr(0, i);\n        src = src.substr(i + closeTag.length);\n        // res の中に beginTag があればエラーにする #953\n        if (res.indexOf(beginTag) >= 0) {\n            if (beginTag === '『') {\n                throw new Error('「『」で始めた文字列の中に「『」を含めることはできません。');\n            }\n            else {\n                throw new Error(`『${beginTag}』で始めた文字列の中に『${beginTag}』を含めることはできません。`);\n            }\n        }\n    }\n    // 文字列直後の助詞を取得\n    const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.josiRE.exec(src);\n    if (j) {\n        josi = j[0].replace(/^\\s+/, '');\n        src = src.substr(j[0].length);\n        // 助詞の後のカンマ #877\n        if (src.charAt(0) === ',') {\n            src = src.substr(1);\n        }\n    }\n    // 助詞「こと」「である」「です」などは「＊＊すること」のように使うので削除 #936 #939 #974\n    if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.removeJosiMap[josi]) {\n        josi = '';\n    }\n    // 改行を数える\n    for (let i = 0; i < res.length; i++) {\n        if (res.charAt(i) === '\\n') {\n            numEOL++;\n        }\n    }\n    return { src, res, josi, numEOL };\n}\nfunction parseNumber(n) {\n    return Number(n.replace(/_/g, ''));\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_lex_rules.mjs?")},"./core/src/nako_lexer.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoLexer\": function() { return /* binding */ NakoLexer; }\n/* harmony export */ });\n/* harmony import */ var _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_parser_const.mjs */ \"./core/src/nako_parser_const.mjs\");\n/* harmony import */ var _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_reserved_words.mjs */ \"./core/src/nako_reserved_words.mjs\");\n/* harmony import */ var _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_josi_list.mjs */ \"./core/src/nako_josi_list.mjs\");\n/* harmony import */ var _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nako_lex_rules.mjs */ \"./core/src/nako_lex_rules.mjs\");\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n// なでしこの字句解析を行う\n// 既に全角半角を揃えたコードに対して字句解析を行う\n\n// 予約語句\n// (memo)「回」「間」「繰返」「反復」「抜」「続」「戻」「代入」などは _replaceWord で word から変換\n/** @types {Record<string, string>} */\n\n// 助詞の一覧\n\n// 字句解析ルールの一覧\n\n\nclass NakoLexer {\n    /**\n     * @param logger\n     */\n    constructor(logger) {\n        this.logger = logger; // 字句解析した際,確認された関数の一覧\n        this.funclist = {};\n        this.modList = []; // 字句解析した際,取り込むモジュール一覧 --- nako3::lex で更新される\n        this.result = [];\n        this.modName = 'main.nako3'; // モジュール名\n    }\n    /** 関数一覧をセット */\n    setFuncList(listObj) {\n        this.funclist = listObj;\n    }\n    /**\n     * @param tokens\n     * @param {boolean} isFirst\n     * @param {string} filename\n     */\n    replaceTokens(tokens, isFirst, filename) {\n        this.result = tokens;\n        this.modName = NakoLexer.filenameToModName(filename);\n        // 関数の定義があれば funclist を更新\n        NakoLexer.preDefineFunc(tokens, this.logger, this.funclist);\n        this._replaceWord(this.result);\n        if (isFirst) {\n            if (this.result.length > 0) {\n                const eof = this.result[this.result.length - 1];\n                this.result.push({\n                    type: 'eol',\n                    line: eof.line,\n                    column: 0,\n                    file: eof.file,\n                    josi: '',\n                    value: '---',\n                    startOffset: eof.startOffset,\n                    endOffset: eof.endOffset,\n                    rawJosi: ''\n                }); // 改行\n                this.result.push({\n                    type: 'eof',\n                    line: eof.line,\n                    column: 0,\n                    file: eof.file,\n                    josi: '',\n                    value: '',\n                    startOffset: eof.startOffset,\n                    endOffset: eof.endOffset,\n                    rawJosi: ''\n                }); // ファイル末尾\n            }\n            else {\n                this.result.push({\n                    type: 'eol',\n                    line: 0,\n                    column: 0,\n                    file: '',\n                    josi: '',\n                    value: '---',\n                    startOffset: 0,\n                    endOffset: 0,\n                    rawJosi: ''\n                }); // 改行\n                this.result.push({\n                    type: 'eof',\n                    line: 0,\n                    column: 0,\n                    file: '',\n                    josi: '',\n                    value: '',\n                    startOffset: 0,\n                    endOffset: 0,\n                    rawJosi: ''\n                }); // ファイル末尾\n            }\n        }\n        return this.result;\n    }\n    /**\n     * ファイル内で定義されている関数名を列挙する。結果はfunclistに書き込む。その他のトークンの置換処理も行う。\n     * シンタックスハイライトの処理から呼び出すためにstaticメソッドにしている。\n     * @param {Token[]} tokens\n     * @param {import('./nako_logger.mjs').NakoLogger} logger\n     * @param {FuncList} funclist\n     */\n    static preDefineFunc(tokens, logger, funclist) {\n        // 関数を先読みして定義\n        let i = 0;\n        let isFuncPointer = false;\n        const readArgs = () => {\n            const args = [];\n            const keys = {};\n            if (tokens[i].type !== '(') {\n                return [];\n            }\n            i++;\n            while (tokens[i]) {\n                const t = tokens[i];\n                i++;\n                if (t.type === ')') {\n                    break;\n                }\n                if (t.type === 'func') {\n                    isFuncPointer = true;\n                }\n                else if (t.type !== '|' && t.type !== 'comma') {\n                    if (isFuncPointer) {\n                        t.funcPointer = true;\n                        isFuncPointer = false;\n                    }\n                    args.push(t);\n                    if (!keys[t.value]) {\n                        keys[t.value] = [];\n                    }\n                    keys[t.value].push(t.josi);\n                }\n            }\n            const varnames = [];\n            const funcPointers = [];\n            const result = [];\n            const already = {};\n            for (const arg of args) {\n                if (!already[arg.value]) {\n                    const josi = keys[arg.value];\n                    result.push(josi);\n                    varnames.push(arg.value);\n                    if (arg.funcPointer) {\n                        funcPointers.push(arg.value);\n                    }\n                    else {\n                        funcPointers.push(null);\n                    }\n                    already[arg.value] = true;\n                }\n            }\n            return [result, varnames, funcPointers];\n        };\n        // トークンを一つずつ確認\n        while (i < tokens.length) {\n            // タイプの置換\n            const t = tokens[i];\n            // 無名関数の定義：「xxには**」があった場合 ... 暗黙的な関数定義とする\n            if ((t.type === 'word' && t.josi === 'には') || (t.type === 'word' && t.josi === 'は~')) {\n                t.josi = 'には';\n                tokens.splice(i + 1, 0, { type: 'def_func', value: '関数', line: t.line, column: t.column, file: t.file, josi: '', startOffset: t.endOffset, endOffset: t.endOffset, rawJosi: '', tag: '無名関数' });\n                i++;\n                continue;\n            }\n            // N回をN|回に置換\n            if (t.type === 'word' && t.josi === '' && t.value.length >= 2) {\n                if (t.value.match(/回$/)) {\n                    t.value = t.value.substring(0, t.value.length - 1);\n                    // N回を挿入\n                    if (!t.endOffset) {\n                        t.endOffset = 1;\n                    }\n                    const kai = { type: '回', value: '回', line: t.line, column: t.column, file: t.file, josi: '', startOffset: t.endOffset - 1, endOffset: t.endOffset, rawJosi: '' };\n                    tokens.splice(i + 1, 0, kai);\n                    t.endOffset--;\n                    i++;\n                }\n            }\n            // 予約語の置換\n            if (t.type === 'word' && _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"][t.value]) {\n                t.type = _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"][t.value];\n                if (t.value === 'そう') {\n                    t.value = 'それ';\n                }\n            }\n            // 関数定義の確認\n            if (t.type !== 'def_test' && t.type !== 'def_func') {\n                i++;\n                continue;\n            }\n            // 無名関数か普通関数定義かを判定する (1つ前が改行かどうかで判定)\n            let isMumei = true;\n            let prevToken = { type: 'eol' };\n            if (i >= 1) {\n                prevToken = tokens[i - 1];\n            }\n            if (prevToken.type === 'eol') {\n                isMumei = false;\n            }\n            // 関数名や引数を得る\n            const defToken = t;\n            i++; // skip \"●\" or \"関数\"\n            let josi = [];\n            let varnames = [];\n            let funcPointers = [];\n            let funcName = '';\n            let funcNameToken = null;\n            // 関数名の前に引数定義\n            if (tokens[i] && tokens[i].type === '(') {\n                [josi, varnames, funcPointers] = readArgs();\n            }\n            // 関数名を得る\n            if (!isMumei && tokens[i] && tokens[i].type === 'word') {\n                funcNameToken = tokens[i++];\n                funcName = funcNameToken.value;\n            }\n            // 関数名の後で引数定義\n            if (josi.length === 0 && tokens[i] && tokens[i].type === '(') {\n                [josi, varnames, funcPointers] = readArgs();\n            }\n            // 名前のある関数定義ならば関数テーブルに関数名を登録\n            // 無名関数は登録しないように気をつける\n            if (funcName !== '' && funcNameToken) {\n                const modName = NakoLexer.filenameToModName(t.file);\n                funcName = modName + '__' + funcName;\n                if (funcName in funclist) { // 関数の二重定義を警告\n                    // main__は省略 #1223\n                    const dispName = funcName.replace(/^main__/, '');\n                    logger.warn(`関数『${dispName}』は既に定義されています。`, defToken);\n                }\n                funcNameToken.value = funcName;\n                funclist[funcName] = {\n                    type: 'func',\n                    josi,\n                    fn: null,\n                    asyncFn: false,\n                    varnames,\n                    funcPointers\n                };\n            }\n            // 無名関数のために\n            defToken.meta = {\n                type: 'func',\n                josi,\n                varnames,\n                funcPointers\n            };\n        }\n    }\n    /** 文字列を{と}の部分で分割する。中括弧が対応していない場合nullを返す。 */\n    splitStringEx(code) {\n        /** @type {string[]} */\n        const list = [];\n        // \"A{B}C{D}E\" -> [\"A\", \"B}C\", \"D}E\"] -> [\"A\", \"B\", \"C\", \"D\", \"E\"]\n        // \"A{B}C}D{E}F\" -> [\"A\", \"B}C}D\", \"E}F\"] -> [\"A\", \"B\", \"C}D\", \"E\", \"F\"]\n        const arr = code.split(/[{｛]/);\n        list.push(arr[0]);\n        for (const s of arr.slice(1)) {\n            const end = s.replace('｝', '}').indexOf('}');\n            if (end === -1) {\n                return null;\n            }\n            list.push(s.slice(0, end), s.slice(end + 1));\n        }\n        return list;\n    }\n    _replaceWord(tokens) {\n        let comment = [];\n        let i = 0;\n        const getLastType = () => {\n            if (i <= 0) {\n                return 'eol';\n            }\n            return tokens[i - 1].type;\n        };\n        const modSelf = (tokens.length > 0) ? NakoLexer.filenameToModName(tokens[0].file) : 'main.nako3';\n        while (i < tokens.length) {\n            const t = tokens[i];\n            // 関数を強制的に置換( word => func )\n            if (t.type === 'word' && t.value !== 'それ') {\n                // 関数を変換\n                const funcName = t.value;\n                if (funcName.indexOf('__') < 0) {\n                    // 自身のモジュール名を検索\n                    const gname1 = `${modSelf}__${funcName}`;\n                    const gfo1 = this.funclist[gname1];\n                    if (gfo1 && gfo1.type === 'func') {\n                        t.type = 'func';\n                        t.meta = gfo1;\n                        t.value = gname1;\n                        continue;\n                    }\n                    // モジュール関数を置換\n                    for (const mod of this.modList) {\n                        const gname = `${mod}__${funcName}`;\n                        const gfo = this.funclist[gname];\n                        if (gfo && gfo.type === 'func') {\n                            t.type = 'func';\n                            t.meta = gfo;\n                            t.value = gname;\n                            break;\n                        }\n                    }\n                    if (t.type === 'func') {\n                        continue;\n                    }\n                }\n                const fo = this.funclist[funcName];\n                if (fo && fo.type === 'func') {\n                    t.type = 'func';\n                    t.meta = fo;\n                }\n            }\n            // 数字につくマイナス記号を判定\n            // (ng) 5 - 3 || word - 3\n            // (ok) (行頭)-3 || 1 * -3 || Aに -3を 足す\n            if (t.type === '-' && tokens[i + 1] && tokens[i + 1].type === 'number') {\n                // 一つ前の語句が、(行頭|演算子|助詞付きの語句)なら 負数である\n                const ltype = getLastType();\n                if (ltype === 'eol' || _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[ltype] || tokens[i - 1].josi !== '') {\n                    tokens.splice(i, 1); // remove '-'\n                    tokens[i].value *= -1;\n                }\n            }\n            // 助詞の「は」を = に展開\n            if (t.josi === undefined) {\n                t.josi = '';\n            }\n            if (t.josi === 'は') {\n                if (!t.rawJosi) {\n                    t.rawJosi = t.josi;\n                }\n                const startOffset = (t.endOffset === undefined) ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: 'eq',\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: '',\n                    value: undefined\n                });\n                i += 2;\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                continue;\n            }\n            // 「とは」を一つの単語にする\n            if (t.josi === 'とは') {\n                if (!t.rawJosi) {\n                    t.rawJosi = t.josi;\n                }\n                const startOffset = t.endOffset === undefined ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: t.josi,\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: '',\n                    value: undefined\n                });\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                i += 2;\n                continue;\n            }\n            // 助詞のならばをトークンとする\n            if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.tararebaMap[t.josi]) {\n                const josi = (t.josi === 'でなければ' || t.josi === 'なければ') ? 'でなければ' : 'ならば';\n                if (!t.rawJosi) {\n                    t.rawJosi = josi;\n                }\n                const startOffset = t.endOffset === undefined ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: 'ならば',\n                    value: josi,\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: ''\n                });\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                i += 2;\n                continue;\n            }\n            // '_' + 改行 を飛ばす (演算子直後に改行を入れたい場合に使う)\n            if (t.type === '_eol') {\n                tokens.splice(i, 1);\n                continue;\n            }\n            // コメントを飛ばす\n            if (t.type === 'line_comment' || t.type === 'range_comment') {\n                comment.push(t.value);\n                tokens.splice(i, 1);\n                continue;\n            }\n            // 改行にコメントを埋め込む\n            if (t.type === 'eol') {\n                t.value = comment.join('/');\n                comment = [];\n            }\n            i++;\n        }\n    }\n    /**\n     * @param {string} src\n     * @param {number} line\n     * @param {string} filename\n     * @returns {Token[]}\n     */\n    tokenize(src, line, filename) {\n        const srcLength = src.length;\n        const result = [];\n        let columnCurrent;\n        let lineCurrent;\n        let column = 1;\n        let isDefTest = false;\n        while (src !== '') {\n            let ok = false;\n            // 各ルールについて\n            for (const rule of _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__.rules) {\n                // 正規表現でマッチ\n                const m = rule.pattern.exec(src);\n                if (!m) {\n                    continue;\n                }\n                ok = true;\n                // 空白ならスキップ\n                if (rule.name === 'space') {\n                    column += m[0].length;\n                    src = src.substring(m[0].length);\n                    continue;\n                }\n                // マッチしたルールがコールバックを持つなら\n                if (rule.cbParser) {\n                    // コールバックを呼ぶ\n                    /** @type {{ src: string, res: string, josi: string, numEOL: number }} */\n                    let rp;\n                    if (isDefTest && rule.name === 'word') {\n                        rp = rule.cbParser(src, false);\n                    }\n                    else {\n                        try {\n                            rp = rule.cbParser(src);\n                        }\n                        catch (e) {\n                            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.NakoLexerError(e.message, srcLength - src.length, srcLength - src.length + 1, line, filename);\n                        }\n                    }\n                    if (rule.name === 'string_ex') {\n                        // 展開あり文字列 → aaa{x}bbb{x}cccc\n                        const list = this.splitStringEx(rp.res);\n                        if (list === null) {\n                            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.InternalLexerError('展開あり文字列で値の埋め込み{...}が対応していません。', srcLength - src.length, srcLength - rp.src.length, line, filename);\n                        }\n                        let offset = 0;\n                        for (let i = 0; i < list.length; i++) {\n                            const josi = (i === list.length - 1) ? rp.josi : '';\n                            if (i % 2 === 0) {\n                                result.push({\n                                    type: 'string',\n                                    value: list[i],\n                                    file: filename,\n                                    josi,\n                                    line,\n                                    column,\n                                    preprocessedCodeOffset: srcLength - src.length + offset,\n                                    preprocessedCodeLength: list[i].length + 2 + josi.length\n                                });\n                                // 先頭なら'\"...{'、それ以外なら'}...{'、最後は何でも良い\n                                offset += list[i].length + 2;\n                            }\n                            else {\n                                result.push({ type: '&', value: '&', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: 0 });\n                                result.push({ type: '(', value: '(', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: 0 });\n                                result.push({ type: 'code', value: list[i], josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: list[i].length });\n                                result.push({ type: ')', value: ')', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset + list[i].length, preprocessedCodeLength: 0 });\n                                result.push({ type: '&', value: '&', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset + list[i].length, preprocessedCodeLength: 0 });\n                                offset += list[i].length;\n                            }\n                        }\n                        line += rp.numEOL;\n                        column += src.length - rp.src.length;\n                        src = rp.src;\n                        if (rp.numEOL > 0) {\n                            column = 1;\n                        }\n                        break;\n                    }\n                    columnCurrent = column;\n                    column += src.length - rp.src.length;\n                    result.push({ type: rule.name, value: rp.res, josi: rp.josi, line, column: columnCurrent, file: filename, preprocessedCodeOffset: srcLength - src.length, preprocessedCodeLength: src.length - rp.src.length });\n                    src = rp.src;\n                    line += rp.numEOL;\n                    if (rp.numEOL > 0) {\n                        column = 1;\n                    }\n                    break;\n                }\n                // ソースを進める前に位置を計算\n                const srcOffset = srcLength - src.length;\n                // 値を変換する必要があるか？\n                let value = m[0];\n                if (rule.cb) {\n                    value = rule.cb(value);\n                }\n                // ソースを進める\n                columnCurrent = column;\n                lineCurrent = line;\n                column += m[0].length;\n                src = src.substring(m[0].length);\n                if ((rule.name === 'eol' && value === '\\n') || rule.name === '_eol') {\n                    value = line++;\n                    column = 1;\n                }\n                // 数値なら単位を持つか？ --- #994\n                if (rule.name === 'number') {\n                    // 単位があれば読み飛ばす\n                    const um = _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__.unitRE.exec(src);\n                    if (um) {\n                        src = src.substring(um[0].length);\n                        column += m[0].length;\n                    }\n                }\n                let josi = '';\n                if (rule.readJosi) {\n                    const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.josiRE.exec(src);\n                    if (j) {\n                        josi = j[0].replace(/^\\s+/, '');\n                        column += j[0].length;\n                        src = src.substring(j[0].length);\n                        // 助詞の直後にあるカンマを無視 #877\n                        if (src.charAt(0) === ',') {\n                            src = src.substring(1);\n                        }\n                        // 「＊＊である」なら削除 #939 #974\n                        if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.removeJosiMap[josi]) {\n                            josi = '';\n                        }\n                    }\n                }\n                switch (rule.name) {\n                    case 'def_test': {\n                        isDefTest = true;\n                        break;\n                    }\n                    case 'eol': {\n                        isDefTest = false;\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n                // ここまで‰(#682) を処理\n                if (rule.name === 'dec_lineno') {\n                    line--;\n                    continue;\n                }\n                result.push({\n                    type: rule.name,\n                    value,\n                    line: lineCurrent,\n                    column: columnCurrent,\n                    file: filename,\n                    josi,\n                    preprocessedCodeOffset: srcOffset,\n                    preprocessedCodeLength: (srcLength - src.length) - srcOffset\n                });\n                break;\n            }\n            if (!ok) {\n                throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.InternalLexerError('未知の語句: ' + src.substring(0, 3) + '...', srcLength - src.length, srcLength - srcLength + 3, line, filename);\n            }\n        }\n        return result;\n    }\n    // トークン配列をtype文字列に変換\n    static tokensToTypeStr(tokens, sep) {\n        const a = tokens.map((v) => {\n            return v.type;\n        });\n        return a.join(sep);\n    }\n    /**\n     * ファイル名からモジュール名へ変換\n     * @param {string} filename\n     * @returns {string}\n     */\n    static filenameToModName(filename) {\n        if (!filename) {\n            return 'main';\n        }\n        // パスがあればパスを削除\n        filename = filename.replace(/[\\\\:]/g, '/'); // Windowsのpath記号を/に置換\n        if (filename.indexOf('/') >= 0) {\n            const a = filename.split('/');\n            filename = a[a.length - 1];\n        }\n        filename = filename.replace(/\\.nako3?$/, '');\n        return filename;\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_lexer.mjs?")},"./core/src/nako_logger.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogLevel\": function() { return /* binding */ LogLevel; },\n/* harmony export */   \"NakoLogger\": function() { return /* binding */ NakoLogger; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_colors.mjs */ \"./core/src/nako_colors.mjs\");\n/** NakoLogger */\n\n\n/** ログレベル - 数字が高いほど優先度が高い。 */\nclass LogLevel {\n    // string to level no\n    static fromS(levelStr) {\n        let level = LogLevel.trace;\n        switch (levelStr) {\n            case 'all':\n                level = LogLevel.all;\n                break;\n            case 'trace':\n                level = LogLevel.trace;\n                break;\n            case 'debug':\n                level = LogLevel.debug;\n                break;\n            case 'info':\n                level = LogLevel.info;\n                break;\n            case 'warn':\n                level = LogLevel.warn;\n                break;\n            case 'error':\n                level = LogLevel.error;\n                break;\n            case 'stdout':\n                level = LogLevel.stdout;\n                break;\n            default:\n                throw new Error('[NakoLogger] unknown logger level:' + levelStr);\n        }\n        return level;\n    }\n    static toString(level) {\n        const levels = ['all', 'trace', 'debug', 'info', 'warn', 'error', 'stdout'];\n        return levels[level];\n    }\n}\n// level no\nLogLevel.all = 0;\nLogLevel.trace = 1;\nLogLevel.debug = 2;\nLogLevel.info = 3;\nLogLevel.warn = 4;\nLogLevel.error = 5;\nLogLevel.stdout = 6;\n/**\n * エラー位置を日本語で表示する。\n * たとえば `stringifyPosition({ file: \"foo.txt\", line: 5 })` は `\"foo.txt(6行目):\"` を出力する。\n */\nfunction stringifyPosition(p) {\n    if (!p) {\n        return '';\n    }\n    return `${p.file || ''}${p.line === undefined ? '' : `(${p.line + 1}行目): `}`;\n}\n/**\n * コンパイラのログ情報を出力するためのクラス。\n * trace(), debug(), info(), warn(), error() はそれぞれメッセージに `[警告]` などのタグとエラー位置の日本語表現を付けて表示する。\n * error() は引数にエラーオブジェクトを受け取ることもでき、その場合エラーオブジェクトからエラーメッセージとエラー位置が取り出される。\n */\nclass NakoLogger {\n    constructor() {\n        this.listeners = [];\n        this.logs = '';\n        this.position = '';\n    }\n    getErrorLogs() {\n        return [this.logs.replace(/\\s+$/, ''), this.position];\n    }\n    clear() {\n        this.logs = '';\n        this.position = '';\n    }\n    /**\n     * sendメソッドで送られた情報を受け取るコールバックを設定する。\n     * @param levelStr\n     * @param callback\n     */\n    addListener(levelStr, callback) {\n        const level = LogLevel.fromS(levelStr);\n        this.listeners.push({ level, callback });\n    }\n    /**\n     * addListenerメソッドで設定したコールバックを取り外す。\n     * @param {LogListener} callback\n     */\n    removeListener(callback) {\n        this.listeners = this.listeners.filter((l) => l.callback !== callback);\n    }\n    /** 本体開発時のデバッグ情報（debugより更に詳細な情報）\n     * @param {string} message\n     * @param {Position | null} position\n     */\n    trace(message, position = null) {\n        this.sendI(LogLevel.trace, `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.bold}[デバッグ情報（詳細）]${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.reset}${stringifyPosition(position)}${message}`, position);\n    }\n    /** 本体開発時のデバッグ情報\n     * @param {string} message\n     * @param {Position | null} position\n     */\n    debug(message, position = null) {\n        this.sendI(LogLevel.debug, `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.bold}[デバッグ情報]${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.reset}${stringifyPosition(position)}${message}`, position);\n    }\n    /** ユーザープログラムのデバッグ情報（あまり重要ではないもの）\n     * @param {string} message\n     * @param {Position | null} position\n     */\n    info(message, position = null) {\n        this.sendI(LogLevel.info, `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.bold}${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.blue}[情報]${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.reset}${stringifyPosition(position)}${message}`, position);\n    }\n    /** ユーザープログラムのデバッグ情報（重要なもの）\n     * @param {string} message\n     * @param {Position | null} position\n     */\n    warn(message, position = null) {\n        this.sendI(LogLevel.warn, `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.bold}${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.green}[警告]${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.reset}${stringifyPosition(position)}${message}`, position);\n    }\n    /** エラーメッセージ\n     * @param {string | Error} message\n     * @param {Position | null} position\n     */\n    error(message, position = null) {\n        // NakoErrorか判定 (`message instanceof NakoError`では判定できない場合がある)\n        if (message instanceof Error && typeof message.type === 'string') {\n            // NakoErrorか\n            const etype = message.type;\n            switch (etype) {\n                case 'NakoRuntimeError':\n                case 'NakoError':\n                    if (message instanceof _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoError) {\n                        const e = message;\n                        let pos = position;\n                        if (pos === null || pos === undefined) {\n                            pos = { file: e.file, line: e.line || 0, startOffset: 0, endOffset: 0 };\n                        }\n                        this.sendI(LogLevel.error, e.message, pos);\n                        return;\n                    }\n            }\n        }\n        if (message instanceof Error) {\n            // 一般のエラーの場合は、messageのみ取得できる。\n            message = message.message;\n        }\n        this.sendI(LogLevel.error, `${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.bold}${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.red}[エラー]${_nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.color.reset}${stringifyPosition(position)}${message}`, position);\n    }\n    /** ユーザープログラムのデバッグ情報（すべて)\n     * @param {string} message\n     * @param {Position | null} position\n     */\n    stdout(message, position = null) {\n        this.sendI(LogLevel.stdout, `${message}`, position);\n    }\n    /** 指定したlevelのlistenerにメッセージを送る。htmlやbrowserConsoleは無ければnodeConsoleから生成する。 */\n    send(levelStr, nodeConsole, position, html = null, browserConsole = null) {\n        const i = LogLevel.fromS(levelStr);\n        this.sendI(i, nodeConsole, position, html, browserConsole);\n    }\n    /** 指定したlevelのlistenerにメッセージを送る。htmlやbrowserConsoleは無ければnodeConsoleから生成する。 */\n    sendI(level, nodeConsole, position, html = null, browserConsole = null) {\n        const makeData = () => {\n            // nodeConsoleからnoColor, nodeCondoleなどの形式を生成する。\n            const formats = _nako_colors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoColors.convertColorTextFormat(nodeConsole);\n            // ログが複数行から構成される場合は、htmlでの表現にborderを設定する。\n            let style = '';\n            if (nodeConsole.includes('\\n')) {\n                style += 'border-top: 1px solid #8080806b; border-bottom: 1px solid #8080806b;';\n            }\n            // 各イベントリスナーが受け取るデータ\n            const data = {\n                noColor: formats.noColor,\n                nodeConsole: formats.nodeConsole,\n                browserConsole: browserConsole || formats.browserConsole,\n                html: `<div style=\"${style}\">` + (html || formats.html) + '</div>',\n                level: LogLevel.toString(level),\n                position\n            };\n            return data;\n        };\n        // エラーならログに追加\n        if (level === LogLevel.error) {\n            const data = makeData();\n            this.logs += data.noColor + '\\n';\n            if (position && this.position !== null) {\n                this.position = `l${position.line}:${position.file}`;\n            }\n        }\n        // 登録したリスナーに通知する\n        for (const l of this.listeners) {\n            if (l.level <= level) {\n                const data = makeData();\n                l.callback(data);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_logger.mjs?")},"./core/src/nako_parser3.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoParser\": function() { return /* binding */ NakoParser; }\n/* harmony export */ });\n/* harmony import */ var _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_parser_const.mjs */ \"./core/src/nako_parser_const.mjs\");\n/* harmony import */ var _nako_parser_base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_parser_base.mjs */ \"./core/src/nako_parser_base.mjs\");\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nako_lexer.mjs */ \"./core/src/nako_lexer.mjs\");\n/* harmony import */ var _nako_types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nako_types.mjs */ \"./core/src/nako_types.mjs\");\n/**\n * nadesiko v3 parser\n */\n\n\n\n\n\n/**\n * 構文解析を行うクラス\n */\nclass NakoParser extends _nako_parser_base_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoParserBase {\n    /**\n     * 構文解析を実行する\n     */\n    parse(tokens, filename) {\n        this.reset();\n        this.tokens = tokens;\n        this.modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoLexer.filenameToModName(filename);\n        this.modList.push(this.modName);\n        // 解析開始\n        return this.startParser();\n    }\n    /** パーサーの一番最初に呼び出す構文規則 */\n    startParser() {\n        const b = this.ySentenceList();\n        const c = this.get();\n        if (c && c.type !== 'eof') {\n            this.logger.debug(`構文解析でエラー。${this.nodeToStr(c, { depth: 1 }, true)}の使い方が間違っています。`, c);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`構文解析でエラー。${this.nodeToStr(c, { depth: 1 }, false)}の使い方が間違っています。`, c);\n        }\n        return b;\n    }\n    /** 複数文を返す */\n    ySentenceList() {\n        const blocks = [];\n        let line = -1;\n        const map = this.peekSourceMap();\n        while (!this.isEOF()) {\n            const n = this.ySentence();\n            if (!n) {\n                break;\n            }\n            blocks.push(n);\n            if (line < 0) {\n                line = n.line;\n            }\n        }\n        if (blocks.length === 0) {\n            const token = this.peek() || this.tokens[0];\n            this.logger.debug('構文解析に失敗:' + this.nodeToStr(this.peek(), { depth: 1 }, true), token);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('構文解析に失敗:' + this.nodeToStr(this.peek(), { depth: 1 }, false), token);\n        }\n        return { type: 'block', block: blocks, ...map, end: this.peekSourceMap(), genMode: this.genMode };\n    }\n    yEOL() {\n        // 行末のチェック #1009\n        const eol = this.get();\n        if (!eol) {\n            return null;\n        }\n        // 余剰スタックの確認\n        if (this.stack.length > 0) {\n            /** 余剰スタックのレポートを作る */\n            const words = [];\n            this.stack.forEach((t) => {\n                let w = this.nodeToStr(t, { depth: 1 }, false);\n                if (t.josi) {\n                    w += t.josi;\n                }\n                words.push(w);\n            });\n            const desc = words.join(',');\n            // 最近使った関数の使い方レポートを作る #1093\n            let descFunc = '';\n            const chA = 'A'.charCodeAt(0);\n            for (const f of this.recentlyCalledFunc) {\n                descFunc += ' - ';\n                let no = 0;\n                const josiA = f.josi;\n                if (josiA) {\n                    for (const arg of josiA) {\n                        const ch = String.fromCharCode(chA + no);\n                        descFunc += ch;\n                        if (arg.length === 1) {\n                            descFunc += arg[0];\n                        }\n                        else {\n                            descFunc += `(${arg.join('|')})`;\n                        }\n                        no++;\n                    }\n                }\n                descFunc += f.name + '\\n';\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`未解決の単語があります: [${desc}]\\n次の命令の可能性があります:\\n${descFunc}`, eol);\n        }\n        this.recentlyCalledFunc = [];\n        return eol;\n    }\n    /** @returns {Ast | null} */\n    ySentence() {\n        const map = this.peekSourceMap();\n        // 最初の語句が決まっている構文\n        if (this.check('eol')) {\n            return this.yEOL();\n        }\n        if (this.check('もし')) {\n            return this.yIF();\n        }\n        if (this.check('後判定')) {\n            return this.yAtohantei();\n        }\n        if (this.check('エラー監視')) {\n            return this.yTryExcept();\n        }\n        if (this.check('逐次実行')) {\n            return this.yTikuji();\n        }\n        if (this.accept(['抜ける'])) {\n            return { type: 'break', josi: '', ...map, end: this.peekSourceMap() };\n        }\n        if (this.accept(['続ける'])) {\n            return { type: 'continue', josi: '', ...map, end: this.peekSourceMap() };\n        }\n        if (this.accept(['require', 'string', '取込'])) {\n            return this.yRequire();\n        }\n        if (this.accept(['not', '非同期モード'])) {\n            return this.yASyncMode();\n        }\n        if (this.accept(['not', 'DNCLモード'])) {\n            return this.yDNCLMode();\n        }\n        if (this.accept(['not', 'string', 'モード設定'])) {\n            return this.ySetGenMode(this.y[1].value);\n        }\n        // 関数呼び出し演算子\n        if (this.check2(['func', '←'])) {\n            return this.yCallOp();\n        }\n        if (this.check2(['func', 'eq'])) {\n            const word = this.get() || (0,_nako_types_mjs__WEBPACK_IMPORTED_MODULE_4__.NewEmptyToken)('?', '?', map.line, map.file || '');\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`関数『${word.value}』に代入できません。『←』を使ってください。`, word);\n        }\n        // 先読みして初めて確定する構文\n        if (this.accept([this.ySpeedMode])) {\n            return this.y[0];\n        }\n        if (this.accept([this.yPerformanceMonitor])) {\n            return this.y[0];\n        }\n        if (this.accept([this.yLet])) {\n            return this.y[0];\n        }\n        if (this.accept([this.yDefTest])) {\n            return this.y[0];\n        }\n        if (this.accept([this.yDefFunc])) {\n            return this.y[0];\n        }\n        // 関数呼び出しの他、各種構文の実装\n        if (this.accept([this.yCall])) {\n            const c1 = this.y[0];\n            if (c1.josi === 'して') { // 連文をblockとして接続する(もし構文、逐次実行構文などのため)\n                const c2 = this.ySentence();\n                if (c2 !== null) {\n                    return {\n                        type: 'block',\n                        block: [c1, c2],\n                        josi: c2.josi,\n                        ...map,\n                        end: this.peekSourceMap()\n                    };\n                }\n            }\n            return c1;\n        }\n        return null;\n    }\n    /** @returns {Ast} */\n    yASyncMode() {\n        const map = this.peekSourceMap();\n        this.genMode = '非同期モード';\n        return { type: 'eol', ...map, end: this.peekSourceMap() };\n    }\n    /** @returns {Ast} */\n    yDNCLMode() {\n        const map = this.peekSourceMap();\n        // 配列インデックスは1から\n        this.arrayIndexFrom = 1;\n        // 配列アクセスをJSと逆順で指定する\n        this.flagReverseArrayIndex = true;\n        // 配列代入時自動で初期化チェックする\n        this.flagCheckArrayInit = true;\n        return { type: 'eol', ...map, end: this.peekSourceMap() };\n    }\n    /** @returns {Ast} */\n    ySetGenMode(mode) {\n        const map = this.peekSourceMap();\n        this.genMode = mode;\n        return { type: 'eol', ...map, end: this.peekSourceMap() };\n    }\n    /** @returns {Ast} */\n    yRequire() {\n        const nameToken = this.y[1];\n        const filename = nameToken.value;\n        const modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoLexer.filenameToModName(filename);\n        if (this.modList.indexOf(modName) < 0) {\n            // 優先度が最も高いのは modList[0]\n            // [memo] モジュールの検索優先度は、下に書くほど高くなる\n            const modSelf = this.modList.shift();\n            if (modSelf) {\n                this.modList.unshift(modName);\n                this.modList.unshift(modSelf);\n            }\n        }\n        return {\n            type: 'require',\n            value: filename,\n            josi: '',\n            ...this.peekSourceMap(),\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast} */\n    yBlock() {\n        const map = this.peekSourceMap();\n        const blocks = [];\n        if (this.check('ここから')) {\n            this.get();\n        }\n        while (!this.isEOF()) {\n            if (this.checkTypes(['違えば', 'ここまで', 'エラー'])) {\n                break;\n            }\n            if (!this.accept([this.ySentence])) {\n                break;\n            }\n            blocks.push(this.y[0]);\n        }\n        return { type: 'block', block: blocks, ...map, end: this.peekSourceMap() };\n    }\n    yDefFuncReadArgs() {\n        if (!this.check('(')) {\n            return null;\n        }\n        const a = [];\n        this.get(); // skip '('\n        while (!this.isEOF()) {\n            if (this.check(')')) {\n                this.get(); // skip ''\n                break;\n            }\n            const t = this.get();\n            if (t) {\n                a.push(t);\n            }\n            if (this.check('comma')) {\n                this.get();\n            }\n        }\n        return a;\n    }\n    /** @returns {Ast | null} */\n    yDefTest() {\n        return this.yDef('def_test');\n    }\n    /** @returns {Ast | null} */\n    yDefFunc() {\n        return this.yDef('def_func');\n    }\n    /**\n     * @param {string} type\n     * @returns {Ast | null}\n     */\n    yDef(type) {\n        if (!this.check(type)) {\n            return null;\n        }\n        const map = this.peekSourceMap();\n        const def = this.get(); // ●\n        if (!def) {\n            return null;\n        }\n        let defArgs = [];\n        if (this.check('(')) {\n            defArgs = this.yDefFuncReadArgs() || [];\n        } // // lexerでも解析しているが再度詳しく\n        const funcName = this.get();\n        if (!funcName || funcName.type !== 'func') {\n            this.logger.debug(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, true) + 'の宣言でエラー。', funcName);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, false) + 'の宣言でエラー。', def);\n        }\n        if (this.check('(')) {\n            // 関数引数の二重定義\n            if (defArgs.length > 0) {\n                this.logger.debug(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, true) + 'の宣言で、引数定義は名前の前か後に一度だけ可能です。', funcName);\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, false) + 'の宣言で、引数定義は名前の前か後に一度だけ可能です。', funcName);\n            }\n            defArgs = this.yDefFuncReadArgs() || [];\n        }\n        if (this.check('とは')) {\n            this.get();\n        }\n        let block = null;\n        let multiline = false;\n        let asyncFn = false;\n        if (this.check('ここから')) {\n            multiline = true;\n        }\n        if (this.check('eol')) {\n            multiline = true;\n        }\n        try {\n            this.funcLevel++;\n            this.usedAsyncFn = false;\n            // ローカル変数を生成\n            const backupLocalvars = this.localvars;\n            this.localvars = { 'それ': { type: 'var', value: '' } };\n            if (multiline) {\n                this.saveStack();\n                // 関数の引数をローカル変数として登録する\n                for (const arg of defArgs) {\n                    const fnName = (arg.value) ? arg.value + '' : '';\n                    this.localvars[fnName] = { 'type': 'var', 'value': '' };\n                }\n                block = this.yBlock();\n                if (this.check('ここまで')) {\n                    this.get();\n                }\n                else {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『ここまで』がありません。関数定義の末尾に必要です。', def);\n                }\n                this.loadStack();\n            }\n            else {\n                this.saveStack();\n                block = this.ySentence();\n                this.loadStack();\n            }\n            this.funcLevel--;\n            asyncFn = this.usedAsyncFn;\n            this.localvars = backupLocalvars;\n        }\n        catch (err) {\n            this.logger.debug(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, true) +\n                'の定義で以下のエラーがありました。\\n' + err.message, def);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(this.nodeToStr(funcName, { depth: 0, typeName: '関数' }, false) +\n                'の定義で以下のエラーがありました。\\n' + err.message, def);\n        }\n        return {\n            type,\n            name: funcName,\n            args: defArgs,\n            block: block || [],\n            asyncFn,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yIFCond() {\n        const map = this.peekSourceMap();\n        let a = this.yGetArg();\n        if (!a) {\n            return null;\n        }\n        // console.log('yIFCond=', a, this.peek())\n        // チェック : AがBならば\n        if (a.josi === 'が') {\n            const tmpI = this.index;\n            const b = this.yGetArg();\n            const naraba = this.get();\n            if ((b && b.type !== 'func') && (naraba && naraba.type === 'ならば')) {\n                return {\n                    type: 'op',\n                    operator: (naraba.value === 'でなければ') ? 'noteq' : 'eq',\n                    left: a,\n                    right: b,\n                    josi: '',\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n            this.index = tmpI;\n        }\n        if (a.josi !== '') {\n            // もし文で関数呼び出しがある場合\n            this.stack.push(a);\n            a = this.yCall();\n        }\n        // (ならば|でなければ)を確認\n        if (!this.check('ならば')) {\n            const smap = a || { type: '?', ...map };\n            this.logger.debug('もし文で『ならば』がないか、条件が複雑過ぎます。' + this.nodeToStr(this.peek(), { depth: 1 }, false) + 'の直前に『ならば』を書いてください。', smap);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('もし文で『ならば』がないか、条件が複雑過ぎます。' + this.nodeToStr(this.peek(), { depth: 1 }, false) + 'の直前に『ならば』を書いてください。', smap);\n        }\n        const naraba = this.get();\n        if (naraba && naraba.value === 'でなければ') {\n            a = {\n                type: 'not',\n                value: a,\n                josi: '',\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        return a;\n    }\n    /** @returns {Ast | null} */\n    yIF() {\n        const map = this.peekSourceMap();\n        if (!this.check('もし')) {\n            return null;\n        }\n        const mosi = this.get(); // skip もし\n        if (mosi == null) {\n            return null;\n        }\n        while (this.check('comma')) {\n            this.get();\n        } // skip comma\n        let cond = null;\n        try {\n            cond = this.yIFCond();\n        }\n        catch (err) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『もし』文の条件で次のエラーがあります。\\n' + err.message, mosi);\n        }\n        if (cond === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『もし』文で条件の指定が空です。', mosi);\n        }\n        let trueBlock = null;\n        let falseBlock = null;\n        let tanbun = false;\n        // True Block\n        if (this.check('eol')) {\n            trueBlock = this.yBlock();\n        }\n        else {\n            trueBlock = this.ySentence();\n            tanbun = true;\n        }\n        // skip EOL\n        while (this.check('eol')) {\n            this.get();\n        }\n        // Flase Block\n        if (this.check('違えば')) {\n            this.get(); // skip 違えば\n            while (this.check('comma')) {\n                this.get();\n            }\n            if (this.check('eol')) {\n                falseBlock = this.yBlock();\n            }\n            else {\n                falseBlock = this.ySentence();\n                tanbun = true;\n            }\n        }\n        if (tanbun === false) {\n            if (this.check('ここまで')) {\n                this.get();\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『もし』文で『ここまで』がありません。', mosi);\n            }\n        }\n        return {\n            type: 'if',\n            expr: cond || [],\n            block: trueBlock || [],\n            false_block: falseBlock || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    ySpeedMode() {\n        const map = this.peekSourceMap();\n        if (!this.check2(['string', '実行速度優先'])) {\n            return null;\n        }\n        const optionNode = this.get();\n        this.get();\n        let val = '';\n        if (optionNode && optionNode.value) {\n            val = optionNode.value;\n        }\n        else {\n            return null;\n        }\n        const options = { 行番号無し: false, 暗黙の型変換無し: false, 強制ピュア: false, それ無効: false };\n        for (const name of val.split('/')) {\n            // 全て有効化\n            if (name === '全て') {\n                for (const k of Object.keys(options)) {\n                    options[k] = true;\n                }\n                break;\n            }\n            // 個別に有効化\n            if (Object.keys(options).includes(name)) {\n                options[name] = true;\n            }\n            else {\n                // 互換性を考えて、警告に留める。\n                this.logger.warn(`実行速度優先文のオプション『${name}』は存在しません。`, optionNode);\n            }\n        }\n        let multiline = false;\n        if (this.check('ここから')) {\n            this.get();\n            multiline = true;\n        }\n        else if (this.check('eol')) {\n            multiline = true;\n        }\n        let block = null;\n        if (multiline) {\n            block = this.yBlock();\n            if (this.check('ここまで')) {\n                this.get();\n            }\n        }\n        else {\n            block = this.ySentence();\n        }\n        return {\n            type: 'speed_mode',\n            options,\n            block: block || [],\n            josi: '',\n            ...map\n        };\n    }\n    yPerformanceMonitor() {\n        const map = this.peekSourceMap();\n        if (!this.check2(['string', 'パフォーマンスモニタ適用'])) {\n            return null;\n        }\n        const optionNode = this.get();\n        if (!optionNode) {\n            return null;\n        }\n        this.get();\n        const options = { ユーザ関数: false, システム関数本体: false, システム関数: false };\n        for (const name of optionNode.value.split('/')) {\n            // 全て有効化\n            if (name === '全て') {\n                for (const k of Object.keys(options)) {\n                    options[k] = true;\n                }\n                break;\n            }\n            // 個別に有効化\n            if (Object.keys(options).includes(name)) {\n                options[name] = true;\n            }\n            else {\n                // 互換性を考えて、警告に留める。\n                this.logger.warn(`パフォーマンスモニタ適用文のオプション『${name}』は存在しません。`, optionNode);\n            }\n        }\n        let multiline = false;\n        if (this.check('ここから')) {\n            this.get();\n            multiline = true;\n        }\n        else if (this.check('eol')) {\n            multiline = true;\n        }\n        let block = null;\n        if (multiline) {\n            block = this.yBlock();\n            if (this.check('ここまで')) {\n                this.get();\n            }\n        }\n        else {\n            block = this.ySentence();\n        }\n        return {\n            type: 'performance_monitor',\n            options,\n            block: block || [],\n            josi: '',\n            ...map\n        };\n    }\n    /** (非推奨) 「逐次実行」構文 @returns {Ast | null} */\n    yTikuji() {\n        const map = this.peekSourceMap();\n        if (!this.check('逐次実行')) {\n            return null;\n        }\n        const tikuji = this.getCur(); // skip 逐次実行\n        this.logger.warn('『逐次実行』構文の使用は非推奨になりました(https://nadesi.com/v3/doc/go.php?944)。', tikuji);\n        const blocks = [];\n        let errorBlock = null;\n        if (!tikuji || !this.check('eol')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『逐次実行』の直後は改行が必要です。', tikuji);\n        }\n        // ブロックを読む\n        for (;;) {\n            if (this.check('ここまで')) {\n                break;\n            }\n            if (this.check('eol')) {\n                this.get(); // skip EOL\n                continue;\n            }\n            if (this.check2(['エラー', 'ならば'])) {\n                this.get(); // skip エラー\n                this.get(); // skip ならば\n                errorBlock = this.yBlock();\n                break;\n            }\n            let block = null;\n            // 「先に」「次に」句はブロック宣言 #717 (ただしブロック以外も可能)\n            if (this.check('先に') || this.check('次に')) {\n                const tugini = this.get(); // skip 先に | 次に\n                if (this.check('comma')) {\n                    this.get();\n                }\n                if (this.check('eol')) { // block\n                    block = this.yBlock();\n                    if (!this.check('ここまで')) {\n                        let tuginiType = '次に';\n                        if (tugini != null) {\n                            tuginiType = tugini.type;\n                        }\n                        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`『${tuginiType}』...『ここまで』を対応させてください。`, map);\n                    }\n                    this.get(); // skip 'ここまで'\n                }\n                else { // line\n                    block = this.ySentence();\n                }\n            }\n            else {\n                block = this.ySentence();\n            }\n            // add block\n            if (block != null) {\n                blocks.push(block);\n            }\n        }\n        if (!this.check('ここまで')) {\n            console.log(blocks, this.peek());\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『逐次実行』...『ここまで』を対応させてください。', tikuji);\n        }\n        this.get(); // skip 'ここまで'\n        return {\n            type: 'tikuji',\n            blocks: blocks || [],\n            errorBlock: errorBlock || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /**\n     * 1つ目の値を与え、その後に続く計算式を取得し、優先規則に沿って並び替えして戻す\n     * @param {Ast} firstValue\n     */\n    yGetArgOperator(firstValue) {\n        const args = [firstValue];\n        while (!this.isEOF()) {\n            // 演算子がある？\n            let op = this.peek();\n            if (op && _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[op.type]) {\n                op = this.getCur();\n                args.push(op);\n                // 演算子後の値を取得\n                const v = this.yValue();\n                if (v === null) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`計算式で演算子『${op.value}』後に値がありません`, firstValue);\n                }\n                args.push(v);\n                continue;\n            }\n            break;\n        }\n        if (args.length === 0) {\n            return null;\n        }\n        if (args.length === 1) {\n            return args[0];\n        }\n        return this.infixToAST(args);\n    }\n    yGetArg() {\n        // 値を一つ読む\n        const value1 = this.yValue();\n        if (value1 === null) {\n            return null;\n        }\n        // 計算式がある場合を考慮\n        return this.yGetArgOperator(value1);\n    }\n    infixToPolish(list) {\n        // 中間記法から逆ポーランドに変換\n        const priority = (t) => {\n            if (_nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[t.type]) {\n                return _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[t.type];\n            }\n            return 10;\n        };\n        const stack = [];\n        const polish = [];\n        while (list.length > 0) {\n            const t = list.shift();\n            if (!t) {\n                break;\n            }\n            while (stack.length > 0) { // 優先順位を見て移動する\n                const sTop = stack[stack.length - 1];\n                if (priority(t) > priority(sTop)) {\n                    break;\n                }\n                const tpop = stack.pop();\n                if (!tpop) {\n                    this.logger.error('計算式に間違いがあります。', t);\n                    break;\n                }\n                polish.push(tpop);\n            }\n            stack.push(t);\n        }\n        // 残った要素を積み替える\n        while (stack.length > 0) {\n            const t = stack.pop();\n            if (t) {\n                polish.push(t);\n            }\n        }\n        return polish;\n    }\n    /** @returns {Ast | null} */\n    infixToAST(list) {\n        if (list.length === 0) {\n            return null;\n        }\n        // 逆ポーランドを構文木に\n        const josi = list[list.length - 1].josi;\n        const node = list[list.length - 1];\n        const polish = this.infixToPolish(list);\n        /** @type {Ast[]} */\n        const stack = [];\n        for (const t of polish) {\n            if (!_nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[t.type]) { // 演算子ではない\n                stack.push(t);\n                continue;\n            }\n            const b = stack.pop();\n            const a = stack.pop();\n            if (a === undefined || b === undefined) {\n                this.logger.debug('--- 計算式(逆ポーランド) ---\\n' + JSON.stringify(polish));\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('計算式でエラー', node);\n            }\n            /** @type {Ast} */\n            const op = {\n                type: 'op',\n                operator: t.type,\n                left: a,\n                right: b,\n                josi,\n                startOffset: a.startOffset,\n                endOffset: a.endOffset,\n                line: a.line,\n                column: a.column,\n                file: a.file\n            };\n            stack.push(op);\n        }\n        const ans = stack.pop();\n        if (!ans) {\n            return null;\n        }\n        return ans;\n    }\n    yGetArgParen(y) {\n        let isClose = false;\n        const si = this.stack.length;\n        while (!this.isEOF()) {\n            if (this.check(')')) {\n                isClose = true;\n                break;\n            }\n            const v = this.yGetArg();\n            if (v) {\n                this.pushStack(v);\n                if (this.check('comma')) {\n                    this.get();\n                }\n                continue;\n            }\n            break;\n        }\n        if (!isClose) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`C風関数『${y[0].value}』でカッコが閉じていません`, y[0]);\n        }\n        const a = [];\n        while (si < this.stack.length) {\n            const v = this.popStack();\n            if (v) {\n                a.unshift(v);\n            }\n        }\n        return a;\n    }\n    /** @returns {Ast | null} */\n    yRepeatTime() {\n        const map = this.peekSourceMap();\n        if (!this.check('回')) {\n            return null;\n        }\n        this.get(); // skip '回'\n        if (this.check('comma')) {\n            this.get();\n        } // skip comma\n        if (this.check('繰返')) {\n            this.get();\n        } // skip 'N回、繰り返す' (#924)\n        let num = this.popStack([]);\n        let multiline = false;\n        let block = null;\n        if (num === null) {\n            num = { type: 'word', value: 'それ', josi: '', ...map, end: this.peekSourceMap() };\n        }\n        if (this.check('comma')) {\n            this.get();\n        }\n        if (this.check('ここから')) {\n            this.get();\n            multiline = true;\n        }\n        else if (this.check('eol')) {\n            multiline = true;\n        }\n        if (multiline) { // multiline\n            block = this.yBlock();\n            if (this.check('ここまで')) {\n                this.get();\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『ここまで』がありません。『回』...『ここまで』を対応させてください。', map);\n            }\n        }\n        else {\n            // singleline\n            block = this.ySentence();\n        }\n        return {\n            type: 'repeat_times',\n            value: num,\n            block: block || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yWhile() {\n        const map = this.peekSourceMap();\n        if (!this.check('間')) {\n            return null;\n        }\n        this.get(); // skip '間'\n        while (this.check('comma')) {\n            this.get();\n        } // skip ','\n        if (this.check('繰返')) {\n            this.get();\n        } // skip '繰り返す' #927\n        const cond = this.popStack();\n        if (cond === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『間』で条件がありません。', map);\n        }\n        if (this.check('comma')) {\n            this.get();\n        }\n        if (!this.checkTypes(['ここから', 'eol'])) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『間』の直後は改行が必要です', map);\n        }\n        const block = this.yBlock();\n        if (this.check('ここまで')) {\n            this.get();\n        }\n        return {\n            type: 'while',\n            cond,\n            block,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yAtohantei() {\n        const map = this.peekSourceMap();\n        if (this.check('後判定')) {\n            this.get();\n        } // skip 後判定\n        if (this.check('繰返')) {\n            this.get();\n        } // skip 繰り返す\n        if (this.check('ここから')) {\n            this.get();\n        }\n        const block = this.yBlock();\n        if (this.check('ここまで')) {\n            this.get();\n        }\n        if (this.check('comma')) {\n            this.get();\n        }\n        let cond = this.yGetArg(); // 条件\n        let bUntil = false;\n        const t = this.peek();\n        if (t && t.value === 'なる' && (t.josi === 'まで' || t.josi === 'までの')) {\n            this.get(); // skip なるまで\n            bUntil = true;\n        }\n        if (this.check('間')) {\n            this.get();\n        } // skip 間\n        if (bUntil) { // 条件を反転する\n            cond = {\n                type: 'not',\n                value: cond,\n                josi: '',\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        return {\n            type: 'atohantei',\n            cond: cond || [],\n            block,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yFor() {\n        const map = this.peekSourceMap();\n        if (this.check('繰返') || this.check('増繰返') || this.check('減繰返')) {\n            // pass\n        }\n        else {\n            return null;\n        }\n        const kurikaesu = this.getCur(); // skip 繰り返す\n        // スタックに(増や|減ら)してがある？\n        const incdec = this.stack.pop();\n        if (incdec) {\n            if (incdec.type === 'word' && (incdec.value === '増' || incdec.value === '減')) {\n                kurikaesu.type = incdec.value + kurikaesu.type;\n                // ↑ typeを増繰返 | 減繰返 に変換\n            }\n            else {\n                // 普通の繰り返しの場合\n                this.stack.push(incdec); // 違ったので改めて追加\n            }\n        }\n        let vInc = null;\n        if (kurikaesu.type === '増繰返' || kurikaesu.type === '減繰返') {\n            vInc = this.popStack(['ずつ']);\n        }\n        const vTo = this.popStack(['まで']);\n        const vFrom = this.popStack(['から']);\n        const word = this.popStack(['を', 'で']);\n        if (vFrom === null || vTo === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『繰り返す』文でAからBまでの指定がありません。', kurikaesu);\n        }\n        if (this.check('comma')) {\n            this.get();\n        } // skip comma\n        let multiline = false;\n        if (this.check('ここから')) {\n            multiline = true;\n            this.get();\n        }\n        else if (this.check('eol')) {\n            multiline = true;\n            this.get();\n        }\n        let block = null;\n        if (multiline) {\n            block = this.yBlock();\n            if (this.check('ここまで')) {\n                this.get();\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『ここまで』がありません。『繰り返す』...『ここまで』を対応させてください。', map);\n            }\n        }\n        else {\n            block = this.ySentence();\n        }\n        return {\n            type: 'for',\n            from: vFrom,\n            to: vTo,\n            inc: vInc,\n            word,\n            block: block || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yReturn() {\n        const map = this.peekSourceMap();\n        if (!this.check('戻る')) {\n            return null;\n        }\n        this.get(); // skip '戻る'\n        const v = this.popStack(['で', 'を']);\n        if (this.stack.length > 0) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『戻』文の直前に未解決の引数があります。『(式)を戻す』のように式をカッコで括ってください。', map);\n        }\n        return {\n            type: 'return',\n            value: v,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yForEach() {\n        const map = this.peekSourceMap();\n        if (!this.check('反復')) {\n            return null;\n        }\n        this.get(); // skip '反復'\n        while (this.check('comma')) {\n            this.get();\n        } // skip ','\n        const target = this.popStack(['を']);\n        const name = this.popStack(['で']);\n        let block = null;\n        let multiline = false;\n        if (this.check('ここから')) {\n            multiline = true;\n            this.get();\n        }\n        else if (this.check('eol')) {\n            multiline = true;\n        }\n        if (multiline) {\n            block = this.yBlock();\n            if (this.check('ここまで')) {\n                this.get();\n            }\n        }\n        else {\n            block = this.ySentence();\n        }\n        return {\n            type: 'foreach',\n            name,\n            target,\n            block: block || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** 条件分岐構文 */\n    ySwitch() {\n        const map = this.peekSourceMap();\n        if (!this.check('条件分岐')) {\n            return null;\n        }\n        const joukenbunki = this.get(); // skip '条件分岐'\n        if (!joukenbunki) {\n            return null;\n        }\n        const eol = this.get(); // skip 'eol'\n        if (!eol) {\n            return null;\n        }\n        const value = this.popStack(['で']);\n        if (!value) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『(値)で条件分岐』のように記述してください。', joukenbunki);\n        }\n        if (eol.type !== 'eol') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』の直後は改行してください。', joukenbunki);\n        }\n        let isDefaultClause = false; // 「違えば」内かどうか\n        let skippedKokomade = false;\n        const cases = [];\n        while (!this.isEOF()) {\n            if (this.check('ここまで')) {\n                if (skippedKokomade) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』は『(条件)ならば〜ここまで』と記述してください。', joukenbunki);\n                }\n                this.get(); // skip ここまで\n                break;\n            }\n            if (this.check('eol')) {\n                this.get();\n                continue;\n            }\n            if (isDefaultClause) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』で『違えば〜ここまで』の後に処理を続けることは出来ません。', joukenbunki);\n            }\n            // 違えば？\n            let cond = null;\n            const condToken = this.peek();\n            if (condToken && condToken.type === '違えば') {\n                // 違えば\n                skippedKokomade = false;\n                isDefaultClause = true;\n                cond = this.get(); // skip 違えば\n                if (this.check('comma')) {\n                    this.get();\n                } // skip ','\n            }\n            else {\n                // ＊＊＊ならば\n                if (skippedKokomade) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』は『(条件)ならば〜ここまで』と記述してください。', joukenbunki);\n                }\n                // 「＊＊ならば」を得る\n                cond = this.yValue();\n                if (!cond) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』は『(条件)ならば〜ここまで』と記述してください。', joukenbunki);\n                }\n                const naraba = this.get(); // skip ならば\n                if (!naraba || naraba.type !== 'ならば') {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』で条件は＊＊ならばと記述してください。', joukenbunki);\n                }\n                if (this.check('comma')) {\n                    this.get();\n                } // skip ','\n            }\n            // 条件にあったときに実行すること\n            const condBlock = this.yBlock();\n            const kokomade = this.peek();\n            if (kokomade && kokomade.type === 'ここまで') {\n                this.get(); // skip ここまで\n            }\n            else {\n                if (isDefaultClause) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『条件分岐』は『違えば〜ここまで』と記述してください。', joukenbunki);\n                }\n                // 次が「違えば」の場合に限り、「もし〜ここまで」の「ここまで」を省略できる\n                skippedKokomade = true;\n            }\n            cases.push([cond, condBlock]);\n        }\n        return {\n            type: 'switch',\n            value,\n            cases: cases || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** 無名関数 */\n    yMumeiFunc() {\n        const map = this.peekSourceMap();\n        if (!this.check('def_func')) {\n            return null;\n        }\n        const def = this.get();\n        if (!def) {\n            return null;\n        }\n        let args = [];\n        // 「,」を飛ばす\n        if (this.check('comma')) {\n            this.get();\n        }\n        // 関数の引数定義は省略できる\n        if (this.check('(')) {\n            args = this.yDefFuncReadArgs() || [];\n        }\n        // 「,」を飛ばす\n        if (this.check('comma')) {\n            this.get();\n        }\n        // ブロックを読む\n        this.funcLevel++;\n        this.saveStack();\n        const block = this.yBlock();\n        // 末尾の「ここまで」をチェック - もしなければエラーにする #1045\n        if (!this.check('ここまで')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『ここまで』がありません。『には』構文か無名関数の末尾に『ここまで』が必要です。', map);\n        }\n        this.get(); // skip ここまで\n        this.loadStack();\n        this.funcLevel--;\n        return {\n            type: 'func_obj',\n            args,\n            block,\n            meta: def.meta,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** 代入構文 */\n    yDainyu() {\n        const map = this.peekSourceMap();\n        const dainyu = this.get(); // 代入\n        if (dainyu === null) {\n            return null;\n        }\n        const value = this.popStack(['を']);\n        const word = this.popStack(['へ', 'に']);\n        if (!word || (word.type !== 'word' && word.type !== 'func' && word.type !== '配列参照')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('代入文で代入先の変数が見当たりません。『(変数名)に(値)を代入』のように使います。', dainyu);\n        }\n        // 配列への代入\n        if (word.type === '配列参照') {\n            return {\n                type: 'let_array',\n                name: word.name,\n                index: word.index,\n                value,\n                josi: '',\n                checkInit: this.flagCheckArrayInit,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 一般的な変数への代入\n        const word2 = this.getVarName(word);\n        return {\n            type: 'let',\n            name: word2,\n            value,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** 定める構文 */\n    ySadameru() {\n        const map = this.peekSourceMap();\n        const sadameru = this.get(); // 定める\n        if (sadameru === null) {\n            return null;\n        }\n        const word = this.popStack(['を']);\n        const value = this.popStack(['へ', 'に']);\n        if (!word || (word.type !== 'word' && word.type !== 'func' && word.type !== '配列参照')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『定める』文で定数が見当たりません。『(定数名)を(値)に定める』のように使います。', sadameru);\n        }\n        // 変数を生成する\n        const nameToken = this.getVarName(word);\n        return {\n            type: 'def_local_var',\n            name: nameToken,\n            vartype: '定数',\n            value,\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    yIncDec() {\n        const map = this.peekSourceMap();\n        const action = this.get(); // (増やす|減らす)\n        if (action === null) {\n            return null;\n        }\n        // 『Nずつ増やして繰り返す』文か？\n        if (this.check('繰返')) {\n            this.pushStack({ type: 'word', value: action.value, josi: action.josi, ...map, end: this.peekSourceMap() });\n            return this.yFor();\n        }\n        // スタックから引数をポップ\n        let value = this.popStack(['だけ', '']);\n        if (!value) {\n            value = { type: 'number', value: 1, josi: 'だけ', ...map, end: this.peekSourceMap() };\n        }\n        const word = this.popStack(['を']);\n        if (!word || (word.type !== 'word' && word.type !== '配列参照')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`『${action.type}』文で定数が見当たりません。『(変数名)を(値)だけ${action.type}』のように使います。`, action);\n        }\n        // 減らすなら-1かける\n        if (action.value === '減') {\n            value = { type: 'op', operator: '*', left: value, right: { type: 'number', value: -1, line: action.line }, josi: '', ...map };\n        }\n        return {\n            type: 'inc',\n            name: word,\n            value,\n            josi: action.josi,\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    yCall() {\n        if (this.isEOF()) {\n            return null;\n        }\n        // スタックに積んでいく\n        while (!this.isEOF()) {\n            if (this.check('ここから')) {\n                this.get();\n            }\n            // 代入\n            if (this.check('代入')) {\n                return this.yDainyu();\n            }\n            if (this.check('定める')) {\n                return this.ySadameru();\n            }\n            // 制御構文\n            if (this.check('回')) {\n                return this.yRepeatTime();\n            }\n            if (this.check('間')) {\n                return this.yWhile();\n            }\n            if (this.check('繰返') || this.check('増繰返') || this.check('減繰返')) {\n                return this.yFor();\n            }\n            if (this.check('反復')) {\n                return this.yForEach();\n            }\n            if (this.check('条件分岐')) {\n                return this.ySwitch();\n            }\n            if (this.check('戻る')) {\n                return this.yReturn();\n            }\n            if (this.check('増') || this.check('減')) {\n                return this.yIncDec();\n            }\n            // C言語風関数\n            if (this.check2([['func', 'word'], '('])) { // C言語風\n                const cur = this.peek();\n                if (cur && cur.josi === '') {\n                    const t = this.yValue();\n                    if (t) {\n                        const josi = t.josi || '';\n                        if (t.type === 'func' && (t.josi === '' || _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.keizokuJosi.indexOf(josi) >= 0)) {\n                            t.josi = '';\n                            return t; // 関数なら値とする\n                        }\n                        this.pushStack(t);\n                    }\n                    if (this.check('comma')) {\n                        this.get();\n                    }\n                    continue;\n                }\n            }\n            // なでしこ式関数\n            if (this.check('func')) {\n                const r = this.yCallFunc();\n                if (r === null) {\n                    continue;\n                }\n                // 「〜する間」の形ならスタックに積む。\n                if (this.check('間')) {\n                    this.pushStack(r);\n                    continue;\n                }\n                // 関数呼び出しの直後に、四則演算があるか?\n                if (!this.checkTypes(_nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.operatorList)) {\n                    return r;\n                } // なければ関数呼び出しを戻す\n                // 四則演算があった場合、計算してスタックに載せる\n                this.pushStack(this.yGetArgOperator(r));\n                continue;\n            }\n            // 値のとき → スタックに載せる\n            const t = this.yGetArg();\n            if (t) {\n                this.pushStack(t);\n                continue;\n            }\n            break;\n        } // end of while\n        // 助詞が余ってしまった場合\n        if (this.stack.length > 0) {\n            this.logger.debug('--- stack dump ---\\n' + JSON.stringify(this.stack, null, 2) + '\\npeek: ' + JSON.stringify(this.peek(), null, 2));\n            let msgDebug = `不完全な文です。${this.stack.map((n) => this.nodeToStr(n, { depth: 0 }, true)).join('、')}が解決していません。`;\n            let msg = `不完全な文です。${this.stack.map((n) => this.nodeToStr(n, { depth: 0 }, false)).join('、')}が解決していません。`;\n            // 各ノードについて、更に詳細な情報があるなら表示\n            for (const n of this.stack) {\n                const d0 = this.nodeToStr(n, { depth: 0 }, false);\n                const d1 = this.nodeToStr(n, { depth: 1 }, false);\n                if (d0 !== d1) {\n                    msgDebug += `${this.nodeToStr(n, { depth: 0 }, true)}は${this.nodeToStr(n, { depth: 1 }, true)}として使われています。`;\n                    msg += `${d0}は${d1}として使われています。`;\n                }\n            }\n            const first = this.stack[0];\n            const last = this.stack[this.stack.length - 1];\n            this.logger.debug(msgDebug, first);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(msg, first, last);\n        }\n        return this.popStack([]);\n    }\n    /** @returns {Ast | null} */\n    yCallFunc() {\n        const map = this.peekSourceMap();\n        const t = this.get();\n        if (!t) {\n            return null;\n        }\n        const f = t.meta;\n        const funcName = t.value;\n        // (関数)には ... 構文 ... https://github.com/kujirahand/nadesiko3/issues/66\n        let funcObj = null;\n        if (t.josi === 'には') {\n            try {\n                funcObj = this.yMumeiFunc();\n            }\n            catch (err) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`『${t.value}には...』で無名関数の定義で以下の間違いがあります。\\n${err.message}`, t);\n            }\n            if (funcObj === null) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『Fには』構文がありましたが、関数定義が見当たりません。', t);\n            }\n        }\n        if (!f || typeof f.josi === 'undefined') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('関数の定義でエラー。', t);\n        }\n        // 最近使った関数を記録\n        this.recentlyCalledFunc.push({ name: funcName, ...f });\n        // 呼び出す関数が非同期呼び出しが必要(asyncFn)ならマーク\n        if (f && f.asyncFn) {\n            this.usedAsyncFn = true;\n        }\n        // 関数の引数を取り出す処理\n        const args = [];\n        let nullCount = 0;\n        let valueCount = 0;\n        for (let i = 0; i < f.josi.length; i++) {\n            while (true) {\n                // スタックから任意の助詞を持つ値を一つ取り出す、助詞がなければ末尾から得る\n                let popArg = this.popStack(f.josi[i]);\n                if (popArg !== null) {\n                    valueCount++;\n                }\n                else if (i < f.josi.length - 1 || !f.isVariableJosi) {\n                    nullCount++;\n                    popArg = funcObj;\n                }\n                else {\n                    break;\n                }\n                if (popArg !== null && f.funcPointers !== undefined && f.funcPointers[i] !== null) {\n                    if (popArg.type === 'func') { // 引数が関数の参照渡しに該当する場合、typeを『func_pointer』に変更\n                        popArg.type = 'func_pointer';\n                    }\n                    else {\n                        const varname = (f.varnames) ? f.varnames[i] : `${i + 1}番目の引数`;\n                        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`関数『${t.value}』の引数『${varname}』には関数オブジェクトが必要です。`, t);\n                    }\n                }\n                args.push(popArg);\n                if (i < f.josi.length - 1 || !f.isVariableJosi) {\n                    break;\n                }\n            }\n        }\n        // 1つだけなら、変数「それ」で補完される\n        if (nullCount >= 2 && (valueCount > 0 || t.josi === '' || _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.keizokuJosi.indexOf(t.josi) >= 0)) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`関数『${t.value}』の引数が不足しています。`, t);\n        }\n        this.usedFuncs.add(t.value);\n        // 関数呼び出しのAstを構築\n        const funcNode = {\n            type: 'func',\n            name: t.value,\n            args,\n            josi: t.josi,\n            ...map,\n            end: this.peekSourceMap()\n        };\n        // 「プラグイン名設定」ならば、そこでスコープを変更することを意味する\n        if (funcNode.name === 'プラグイン名設定') {\n            if (args.length > 0 && args[0]) {\n                let fname = '' + args[0].value;\n                if (fname === 'メイン') {\n                    fname = '' + args[0].file;\n                }\n                this.modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoLexer.filenameToModName(fname);\n            }\n        }\n        // 言い切りならそこで一度切る\n        if (t.josi === '') {\n            return funcNode;\n        }\n        // 「**して、**」の場合も一度切る\n        if (_nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.keizokuJosi.indexOf(t.josi) >= 0) {\n            funcNode.josi = 'して';\n            return funcNode;\n        }\n        // 続き\n        funcNode.meta = f;\n        this.pushStack(funcNode);\n        return null;\n    }\n    /** 関数呼び出し演算子 #891\n     * @returns {Ast | null} */\n    yCallOp() {\n        if (!this.check2(['func', '←'])) {\n            return null;\n        }\n        const map = this.peekSourceMap();\n        // 関数名を得る\n        const word = this.get();\n        if (word == null) {\n            throw new Error('関数が取得できません。');\n        }\n        try {\n            const op = this.get();\n            if (op == null) {\n                throw new Error('関数呼び出し演算子が取得できません。');\n            }\n            const funcName = word.value;\n            // 関数の引数なしをチェック\n            if (!word.meta) {\n                throw new Error('関数本体を取得できません。');\n            }\n            if (!word.meta.josi) {\n                throw new Error('関数の引数情報を取得できません。');\n            }\n            const argCount = word.meta.josi.length;\n            if (argCount === 0) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`引数がない関数『${funcName}』を関数呼び出し演算子で呼び出すことはできません。`, word);\n            }\n            // 引数を順に取得\n            const curStackPos = this.stack.length;\n            while (!this.isEOF()) {\n                const t = this.yGetArg();\n                if (t) {\n                    this.pushStack(t);\n                    if ((this.stack.length - curStackPos) === argCount) {\n                        break;\n                    }\n                    continue;\n                }\n                break;\n            }\n            // この場合第一引数の省略は認めない\n            const realArgCount = this.stack.length - curStackPos;\n            if (realArgCount !== argCount) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`関数『${funcName}』呼び出しで引数の数(${realArgCount})が定義(${argCount})と違います。`, word);\n            }\n            // 引数を取り出す\n            const tmpList = this.stack.splice(curStackPos, argCount);\n            // 引数が1つなら助詞は省略が可能。ただし、引数が2つ以上の時、正しく助詞の順序を入れ替える\n            let argList = tmpList;\n            if (argCount >= 2) {\n                argList = [];\n                const defList = word.meta.josi;\n                defList.forEach((josiList, i) => {\n                    for (let j = 0; j < tmpList.length; j++) {\n                        const t = tmpList[j];\n                        if (josiList.indexOf(t.josi) >= 0) {\n                            argList[i] = t;\n                            return;\n                        }\n                    }\n                    const josiStr = josiList.join(',');\n                    throw new Error(`助詞『${josiStr}』が見当たりません。`);\n                });\n            }\n            this.usedFuncs.add(funcName);\n            // funcノードを返す\n            return {\n                type: 'func',\n                name: funcName,\n                args: argList,\n                setter: true,\n                josi: '',\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        catch (err) {\n            this.logger.debug(`${this.nodeToStr(word, { depth: 0 }, true)}の関数呼び出しで引数(『←』以降)が読み取れません。`, word);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`${this.nodeToStr(word, { depth: 0 }, false)}の関数呼び出しでエラーがあります。\\n${err.message}`, word);\n        }\n    }\n    /** @returns {Ast | null} */\n    yLet() {\n        const map = this.peekSourceMap();\n        // 通常の変数\n        if (this.check2(['word', 'eq'])) {\n            const word = this.peek();\n            let threw = false;\n            try {\n                if (this.accept(['word', 'eq', this.yCalc]) || this.accept(['word', 'eq', this.ySentence])) {\n                    if (this.y[2].type === 'eol') {\n                        throw new Error('値が空です。');\n                    }\n                    if (this.check('comma')) {\n                        this.get();\n                    } // skip comma (ex) name1=val1, name2=val2\n                    const nameToken = this.getVarName(this.y[0]);\n                    const valueToken = this.y[2];\n                    return {\n                        type: 'let',\n                        name: nameToken,\n                        value: valueToken,\n                        ...map,\n                        end: this.peekSourceMap()\n                    };\n                }\n                else {\n                    threw = true;\n                    this.logger.debug(`${this.nodeToStr(word, { depth: 1 }, true)}への代入文で計算式に書き間違いがあります。`, word);\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`${this.nodeToStr(word, { depth: 1 }, false)}への代入文で計算式に書き間違いがあります。`, map);\n                }\n            }\n            catch (err) {\n                if (threw) {\n                    throw err;\n                }\n                this.logger.debug(`${this.nodeToStr(word, { depth: 1 }, true)}への代入文で計算式に以下の書き間違いがあります。\\n${err.message}`, word);\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`${this.nodeToStr(word, { depth: 1 }, false)}への代入文で計算式に以下の書き間違いがあります。\\n${err.message}`, map);\n            }\n        }\n        // let_array ?\n        if (this.check2(['word', '@'])) {\n            const la = this.yLetArrayAt(map);\n            if (this.check('comma')) {\n                this.get();\n            } // skip comma (ex) name1=val1, name2=val2\n            if (la) {\n                la.checkInit = this.flagCheckArrayInit;\n                return la;\n            }\n        }\n        if (this.check2(['word', '['])) {\n            const lb = this.yLetArrayBracket(map);\n            if (this.check('comma')) {\n                this.get();\n            } // skip comma (ex) name1=val1, name2=val2\n            if (lb) {\n                lb.checkInit = this.flagCheckArrayInit;\n                return lb;\n            }\n        }\n        // ローカル変数定義\n        if (this.accept(['word', 'とは'])) {\n            const word = this.getVarName(this.y[0]);\n            if (!this.checkTypes(['変数', '定数'])) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('ローカル変数『' + word.value + '』の定義エラー', word);\n            }\n            const vtype = this.getCur(); // 変数\n            // 初期値がある？\n            let value = null;\n            if (this.check('eq')) {\n                this.get();\n                value = this.yCalc();\n            }\n            if (this.check('comma')) {\n                this.get();\n            } // skip comma (ex) name1=val1, name2=val2\n            return {\n                type: 'def_local_var',\n                name: word,\n                vartype: vtype.type,\n                value,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // ローカル変数定義（その２）\n        if (this.accept(['変数', 'word', 'eq', this.yCalc])) {\n            const word = this.getVarName(this.y[1]);\n            return {\n                type: 'def_local_var',\n                name: word,\n                vartype: '変数',\n                value: this.y[3],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        if (this.accept(['定数', 'word', 'eq', this.yCalc])) {\n            const word = this.getVarName(this.y[1]);\n            return {\n                type: 'def_local_var',\n                name: word,\n                vartype: '定数',\n                value: this.y[3],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 複数定数への代入 #563\n        if (this.accept(['定数', this.yJSONArray, 'eq', this.yCalc])) {\n            const names = this.y[1];\n            // check array\n            if (names && names.value instanceof Array) {\n                for (const i in names.value) {\n                    if (names.value[i].type !== 'word') {\n                        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`複数定数の代入文${i + 1}番目でエラー。『定数[A,B,C]=[1,2,3]』の書式で記述してください。`, this.y[0]);\n                    }\n                }\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('複数定数の代入文でエラー。『定数[A,B,C]=[1,2,3]』の書式で記述してください。', this.y[0]);\n            }\n            names.value = this.getVarNameList(names.value);\n            return {\n                type: 'def_local_varlist',\n                names: names.value,\n                vartype: '定数',\n                value: this.y[3],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 複数変数への代入 #563\n        if (this.accept(['変数', this.yJSONArray, 'eq', this.yCalc])) {\n            const names = this.y[1];\n            // check array\n            if (names && names.value instanceof Array) {\n                for (const i in names.value) {\n                    if (names.value[i].type !== 'word') {\n                        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`複数変数の代入文${i + 1}番目でエラー。『変数[A,B,C]=[1,2,3]』の書式で記述してください。`, this.y[0]);\n                    }\n                }\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('複数変数の代入文でエラー。『変数[A,B,C]=[1,2,3]』の書式で記述してください。', this.y[0]);\n            }\n            names.value = this.getVarNameList(names.value);\n            return {\n                type: 'def_local_varlist',\n                names: names.value,\n                vartype: '変数',\n                value: this.y[3],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 複数変数への代入 #563\n        if (this.check2(['word', 'comma', 'word'])) {\n            // 2 word\n            if (this.accept(['word', 'comma', 'word', 'eq', this.yCalc])) {\n                let names = [this.y[0], this.y[2]];\n                names = this.getVarNameList(names);\n                return {\n                    type: 'def_local_varlist',\n                    names,\n                    vartype: '変数',\n                    value: this.y[4],\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n            // 3 word\n            if (this.accept(['word', 'comma', 'word', 'comma', 'word', 'eq', this.yCalc])) {\n                let names = [this.y[0], this.y[2], this.y[4]];\n                names = this.getVarNameList(names);\n                return {\n                    type: 'def_local_varlist',\n                    names,\n                    vartype: '変数',\n                    value: this.y[6],\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n            // 4 word\n            if (this.accept(['word', 'comma', 'word', 'comma', 'word', 'comma', 'word', 'eq', this.yCalc])) {\n                let names = [this.y[0], this.y[2], this.y[4], this.y[6]];\n                names = this.getVarNameList(names);\n                return {\n                    type: 'def_local_varlist',\n                    names,\n                    vartype: '変数',\n                    value: this.y[8],\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n            // 5 word\n            if (this.accept(['word', 'comma', 'word', 'comma', 'word', 'comma', 'word', 'comma', 'word', 'eq', this.yCalc])) {\n                let names = [this.y[0], this.y[2], this.y[4], this.y[6], this.y[8]];\n                names = this.getVarNameList(names);\n                return {\n                    type: 'def_local_varlist',\n                    names,\n                    vartype: '変数',\n                    value: this.y[10],\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * 配列のインデックスが1から始まる場合を考慮するか\n     * @param {Ast} node\n     * @returns\n     */\n    checkArrayIndex(node) {\n        // 配列が0から始まるのであればそのまま返す\n        if (this.arrayIndexFrom === 0) {\n            return node;\n        }\n        // 配列が1から始まるのであれば演算を加えて返す\n        return {\n            ...node,\n            'type': 'op',\n            'operator': '-',\n            'left': node,\n            'right': {\n                ...node,\n                'type': 'number',\n                'value': this.arrayIndexFrom\n            }\n        };\n    }\n    /**\n     * 配列のインデックスを逆順にするのを考慮するか\n     * @param {Ast[]| null} ary\n     */\n    checkArrayReverse(ary) {\n        if (!ary) {\n            return [];\n        }\n        if (!this.flagReverseArrayIndex) {\n            return ary;\n        }\n        // 二次元以上の配列変数のアクセスを[y][x]ではなく[x][y]と順序を変更する\n        if (ary.length <= 1) {\n            return ary;\n        }\n        return ary.reverse();\n    }\n    /** @returns {Ast | null} */\n    yLetArrayAt(map) {\n        // 一次元配列\n        if (this.accept(['word', '@', this.yValue, 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: [this.checkArrayIndex(this.y[2])],\n                value: this.y[4],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 二次元配列\n        if (this.accept(['word', '@', this.yValue, '@', this.yValue, 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4])]),\n                value: this.y[6],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 三次元配列\n        if (this.accept(['word', '@', this.yValue, '@', this.yValue, '@', this.yValue, 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4]), this.checkArrayIndex(this.y[6])]),\n                value: this.y[8],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 二次元配列(カンマ指定)\n        if (this.accept(['word', '@', this.yValue, 'comma', this.yValue, 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4])]),\n                value: this.y[6],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 三次元配列(カンマ指定)\n        if (this.accept(['word', '@', this.yValue, 'comma', this.yValue, 'comma', this.yValue, 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4]), this.checkArrayIndex(this.y[6])]),\n                value: this.y[8],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        return null;\n    }\n    /** @returns {Ast | null} */\n    yLetArrayBracket(map) {\n        // 一次元配列\n        if (this.accept(['word', '[', this.yCalc, ']', 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: [this.checkArrayIndex(this.y[2])],\n                value: this.y[5],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 二次元配列\n        if (this.accept(['word', '[', this.yCalc, ']', '[', this.yCalc, ']', 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[5])]),\n                value: this.y[8],\n                tag: '2',\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        if (this.accept(['word', '[', this.yCalc, 'comma', this.yCalc, ']', 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4])]),\n                value: this.y[7],\n                tag: '2',\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 三次元配列\n        if (this.accept(['word', '[', this.yCalc, ']', '[', this.yCalc, ']', '[', this.yCalc, ']', 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[5]), this.checkArrayIndex(this.y[8])]),\n                value: this.y[11],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        if (this.accept(['word', '[', this.yCalc, 'comma', this.yCalc, 'comma', this.yCalc, ']', 'eq', this.yCalc])) {\n            return {\n                type: 'let_array',\n                name: this.getVarName(this.y[0]),\n                index: this.checkArrayReverse([this.checkArrayIndex(this.y[2]), this.checkArrayIndex(this.y[4]), this.checkArrayIndex(this.y[6])]),\n                value: this.y[9],\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        return null;\n    }\n    /** @returns {Ast | null} */\n    yCalc() {\n        const map = this.peekSourceMap();\n        if (this.check('eol')) {\n            return null;\n        }\n        // 値を一つ読む\n        const t = this.yGetArg();\n        if (!t) {\n            return null;\n        }\n        // 助詞がある？ つまり、関数呼び出しがある？\n        if (t.josi === '') {\n            return t;\n        } // 値だけの場合\n        // 関数の呼び出しがあるなら、スタックに載せて関数読み出しを呼ぶ\n        this.pushStack(t);\n        const t1 = this.yCall();\n        if (!t1) {\n            return this.popStack();\n        }\n        // それが連文か確認\n        if (t1.josi !== 'して') {\n            return t1;\n        } // 連文ではない\n        // 連文なら右側を読んで左側とくっつける\n        const t2 = this.yCalc();\n        if (!t2) {\n            return t1;\n        }\n        return {\n            type: 'renbun',\n            left: t1,\n            right: t2,\n            josi: t2.josi,\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n    /** @returns {Ast | null} */\n    yValueKakko() {\n        if (!this.check('(')) {\n            return null;\n        }\n        const t = this.get(); // skip '('\n        if (!t) {\n            throw new Error('[System Error] check したのに get できない');\n        }\n        this.saveStack();\n        const v = this.yCalc() || this.ySentence();\n        if (v === null) {\n            const v2 = this.get();\n            this.logger.debug('(...)の解析エラー。' + this.nodeToStr(v2, { depth: 1 }, true) + 'の近く', t);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('(...)の解析エラー。' + this.nodeToStr(v2, { depth: 1 }, false) + 'の近く', t);\n        }\n        if (!this.check(')')) {\n            this.logger.debug('(...)の解析エラー。' + this.nodeToStr(v, { depth: 1 }, true) + 'の近く', t);\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('(...)の解析エラー。' + this.nodeToStr(v, { depth: 1 }, false) + 'の近く', t);\n        }\n        const closeParent = this.get(); // skip ')'\n        this.loadStack();\n        if (closeParent) {\n            v.josi = closeParent.josi;\n        }\n        return v;\n    }\n    /** @returns {Ast | null} */\n    yValue() {\n        const map = this.peekSourceMap();\n        // カンマなら飛ばす #877\n        if (this.check('comma')) {\n            this.get();\n        }\n        // プリミティブな値\n        if (this.checkTypes(['number', 'string'])) {\n            return this.getCur();\n        }\n        // 丸括弧\n        if (this.check('(')) {\n            return this.yValueKakko();\n        }\n        // マイナス記号\n        if (this.check2(['-', 'number']) || this.check2(['-', 'word']) || this.check2(['-', 'func'])) {\n            const m = this.get(); // skip '-'\n            const v = this.yValue();\n            const josi = (v && v.josi) ? v.josi : '';\n            const line = (m && m.line) ? m.line : 0;\n            return {\n                type: 'op',\n                operator: '*',\n                left: { type: 'number', value: -1, line },\n                right: v || [],\n                josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // NOT\n        if (this.check('not')) {\n            this.get(); // skip '!'\n            const v = this.yValue();\n            const josi = (v && v.josi) ? v.josi : '';\n            return {\n                type: 'not',\n                value: v,\n                josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // JSON object\n        const a = this.yJSONArray();\n        if (a) {\n            return a;\n        }\n        const o = this.yJSONObject();\n        if (o) {\n            return o;\n        }\n        // 一語関数\n        const splitType = _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.operatorList.concat(['eol', ')', ']', 'ならば', '回', '間', '反復', '条件分岐']);\n        if (this.check2(['func', splitType])) {\n            const tt = this.get();\n            if (!tt) {\n                throw new Error('[System Error] 正しく値が取れませんでした。');\n            }\n            const f = this.getVarNameRef(tt);\n            this.usedFuncs.add(f.value);\n            return {\n                type: 'func',\n                name: f.value,\n                args: [],\n                josi: f.josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // C風関数呼び出し FUNC(...)\n        if (this.check2([['func', 'word'], '(']) && this.peekDef().josi === '') {\n            const f = this.peek();\n            if (this.accept([['func', 'word'], '(', this.yGetArgParen, ')'])) {\n                const funcName = this.getVarNameRef(this.y[0]).value;\n                this.usedFuncs.add(funcName);\n                return {\n                    type: 'func',\n                    name: funcName,\n                    args: this.y[2],\n                    josi: this.y[3].josi,\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('C風関数呼び出しのエラー', f || (0,_nako_types_mjs__WEBPACK_IMPORTED_MODULE_4__.NewEmptyToken)());\n            }\n        }\n        // 関数呼び出し演算子\n        if (this.check2(['func', '←'])) {\n            return this.yCallOp();\n        }\n        // 無名関数(関数オブジェクト)\n        if (this.check('def_func')) {\n            return this.yMumeiFunc();\n        }\n        // 変数\n        const word = this.yValueWord();\n        if (word) {\n            return word;\n        }\n        // その他\n        return null;\n    }\n    yValueWordGetIndex(ast) {\n        if (!ast.index) {\n            ast.index = [];\n        }\n        // word @ a, b, c\n        if (this.check('@')) {\n            if (this.accept(['@', this.yValue, 'comma', this.yValue, 'comma', this.yValue])) {\n                ast.index.push(this.checkArrayIndex(this.y[1]));\n                ast.index.push(this.checkArrayIndex(this.y[3]));\n                ast.index.push(this.checkArrayIndex(this.y[5]));\n                ast.index = this.checkArrayReverse(ast.index);\n                ast.josi = this.y[5].josi;\n                return true;\n            }\n            if (this.accept(['@', this.yValue, 'comma', this.yValue])) {\n                ast.index.push(this.checkArrayIndex(this.y[1]));\n                ast.index.push(this.checkArrayIndex(this.y[3]));\n                ast.index = this.checkArrayReverse(ast.index);\n                ast.josi = this.y[3].josi;\n                return true;\n            }\n            if (this.accept(['@', this.yValue])) {\n                ast.index.push(this.checkArrayIndex(this.y[1]));\n                ast.josi = this.y[1].josi;\n                return true;\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('変数の後ろの『@要素』の指定が不正です。', ast);\n        }\n        if (this.check('[')) {\n            if (this.accept(['[', this.yCalc, ']'])) {\n                ast.index.push(this.checkArrayIndex(this.y[1]));\n                ast.josi = this.y[2].josi;\n                return true;\n            }\n        }\n        if (this.check('[')) {\n            if (this.accept(['[', this.yCalc, 'comma', this.yCalc, ']'])) {\n                const index = [\n                    this.checkArrayIndex(this.y[1]),\n                    this.checkArrayIndex(this.y[3])\n                ];\n                ast.index = this.checkArrayReverse(index);\n                ast.josi = this.y[4].josi;\n                return true;\n            }\n        }\n        if (this.check('[')) {\n            if (this.accept(['[', this.yCalc, 'comma', this.yCalc, 'comma', this.yCalc, ']'])) {\n                const index = [\n                    this.checkArrayIndex(this.y[1]),\n                    this.checkArrayIndex(this.y[3]),\n                    this.checkArrayIndex(this.y[5])\n                ];\n                ast.index = this.checkArrayReverse(index);\n                ast.josi = this.y[6].josi;\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @returns {Ast | null} */\n    yValueWord() {\n        const map = this.peekSourceMap();\n        if (this.check('word')) {\n            const t = this.getCur();\n            const word = this.getVarNameRef(t);\n            // word[n] || word@n\n            if (word.josi === '' && this.checkTypes(['[', '@'])) {\n                const ast = {\n                    type: '配列参照',\n                    name: word,\n                    index: [],\n                    josi: '',\n                    ...map,\n                    end: this.peekSourceMap()\n                };\n                while (!this.isEOF()) {\n                    if (!this.yValueWordGetIndex(ast)) {\n                        break;\n                    }\n                }\n                if (ast.index && ast.index.length === 0) {\n                    throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode(`配列『${word.value}』アクセスで指定ミス`, word);\n                }\n                return ast;\n            }\n            return word;\n        }\n        return null;\n    }\n    /** 変数名を検索して解決する\n     * @param {Ast|Token} word\n     * @return {Ast|Token}\n     */\n    getVarName(word) {\n        // check word name\n        const f = this.findVar(word.value);\n        if (!f) { // 変数が見つからない\n            if (this.funcLevel === 0) { // global\n                let gname = word.value;\n                if (gname.indexOf('__') < 0) {\n                    gname = this.modName + '__' + word.value;\n                }\n                this.funclist[gname] = { type: 'var', value: '' };\n                word.value = gname;\n            }\n            else { // local\n                this.localvars[word.value] = { type: 'var', value: '' };\n            }\n        }\n        else if (f && f.scope === 'global') {\n            word.value = f.name;\n        }\n        return word;\n    }\n    /** 変数名を検索して解決する */\n    getVarNameRef(word) {\n        // check word name\n        const f = this.findVar(word.value);\n        if (!f) { // 変数が見つからない\n            if (this.funcLevel === 0 && word.value.indexOf('__') < 0) {\n                word.value = this.modName + '__' + word.value;\n            }\n        }\n        else if (f && f.scope === 'global') {\n            word.value = f.name;\n        }\n        return word;\n    }\n    /** 複数の変数名を検索して解決する */\n    getVarNameList(words) {\n        for (let i = 0; i < words.length; i++) {\n            words[i] = this.getVarName(words[i]);\n        }\n        return words;\n    }\n    yJSONObjectValue() {\n        const a = [];\n        const firstToken = this.peek();\n        if (!firstToken) {\n            return null;\n        }\n        while (!this.isEOF()) {\n            while (this.check('eol')) {\n                this.get();\n            }\n            if (this.check('}')) {\n                break;\n            }\n            if (this.accept(['word', ':', this.yCalc])) {\n                this.y[0].type = 'string'; // キー名の文字列記号省略の場合\n                a.push({\n                    key: this.y[0],\n                    value: this.y[2]\n                });\n            }\n            else if (this.accept(['string', ':', this.yCalc])) {\n                a.push({\n                    key: this.y[0],\n                    value: this.y[2]\n                });\n            }\n            else if (this.check('word')) {\n                const w = this.getCur();\n                w.type = 'string';\n                a.push({\n                    key: w,\n                    value: w\n                });\n            }\n            else if (this.checkTypes(['string', 'number'])) {\n                const w = this.getCur();\n                a.push({\n                    key: w,\n                    value: w\n                });\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('辞書オブジェクトの宣言で末尾の『}』がありません。', firstToken);\n            }\n            if (this.check('comma')) {\n                this.get();\n            }\n        }\n        return a;\n    }\n    /** @returns {Ast | null} */\n    yJSONObject() {\n        const map = this.peekSourceMap();\n        if (this.accept(['{', '}'])) {\n            return {\n                type: 'json_obj',\n                value: [],\n                josi: this.y[1].josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        if (this.accept(['{', this.yJSONObjectValue, '}'])) {\n            return {\n                type: 'json_obj',\n                value: this.y[1],\n                josi: this.y[2].josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 辞書初期化に終わりがなかった場合 (エラーチェックのため) #958\n        if (this.accept(['{', this.yJSONObjectValue])) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('辞書型変数の初期化が『}』で閉じられていません。', this.y[1]);\n        }\n        return null;\n    }\n    yJSONArrayValue() {\n        if (this.check('eol')) {\n            this.get();\n        }\n        const v1 = this.yCalc();\n        if (v1 === null) {\n            return null;\n        }\n        if (this.check('comma')) {\n            this.get();\n        }\n        const a = [v1];\n        while (!this.isEOF()) {\n            if (this.check('eol')) {\n                this.get();\n            }\n            if (this.check(']')) {\n                break;\n            }\n            const v2 = this.yCalc();\n            if (v2 === null) {\n                break;\n            }\n            if (this.check('comma')) {\n                this.get();\n            }\n            a.push(v2);\n        }\n        return a;\n    }\n    /** @returns {Ast | null} */\n    yJSONArray() {\n        const map = this.peekSourceMap();\n        if (this.accept(['[', ']'])) {\n            return {\n                type: 'json_array',\n                value: [],\n                josi: this.y[1].josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        if (this.accept(['[', this.yJSONArrayValue, ']'])) {\n            return {\n                type: 'json_array',\n                value: this.y[1],\n                josi: this.y[2].josi,\n                ...map,\n                end: this.peekSourceMap()\n            };\n        }\n        // 配列に終わりがなかった場合 (エラーチェックのため) #958\n        if (this.accept(['[', this.yJSONArrayValue])) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('配列変数の初期化が『]』で閉じられていません。', this.y[1]);\n        }\n        return null;\n    }\n    /** エラー監視構文 */\n    yTryExcept() {\n        const map = this.peekSourceMap();\n        if (!this.check('エラー監視')) {\n            return null;\n        }\n        const kansi = this.getCur(); // skip エラー監視\n        const block = this.yBlock();\n        if (!this.check2(['エラー', 'ならば'])) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('エラー構文で『エラーならば』がありません。' +\n                '『エラー監視..エラーならば..ここまで』を対で記述します。', kansi);\n        }\n        this.get(); // skip エラー\n        this.get(); // skip ならば\n        const errBlock = this.yBlock();\n        if (this.check('ここまで')) {\n            this.get();\n        }\n        else {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoSyntaxError.fromNode('『ここまで』がありません。『エラー監視』...『エラーならば』...『ここまで』を対応させてください。', map);\n        }\n        return {\n            type: 'try_except',\n            block,\n            errBlock: errBlock || [],\n            josi: '',\n            ...map,\n            end: this.peekSourceMap()\n        };\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_parser3.mjs?")},"./core/src/nako_parser_base.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoParserBase\": function() { return /* binding */ NakoParserBase; }\n/* harmony export */ });\n/* harmony import */ var _nako_types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_types.mjs */ \"./core/src/nako_types.mjs\");\n\n/**\n * なでしこの構文解析のためのユーティリティクラス\n */\nclass NakoParserBase {\n    constructor(logger) {\n        this.logger = logger;\n        this.stackList = []; // 関数定義の際にスタックが混乱しないように整理する\n        this.tokens = [];\n        this.usedFuncs = new Set();\n        /** @type {import('./nako3.mjs').Ast[]} */\n        this.stack = [];\n        this.index = 0;\n        /** トークン出現チェック(accept関数)に利用する\n         * @type {import('./nako3.mjs').Ast[]}\n         */\n        this.y = [];\n        /** モジュル名 @type {string} */\n        this.modName = 'inline';\n        /**\n         * 利用するモジュールの名前一覧\n         * @type {Array<string>}\n         */\n        this.modList = [];\n        /** グローバル変数・関数の確認用 */\n        this.funclist = {};\n        this.funcLevel = 0;\n        this.usedAsyncFn = false; // asyncFnの呼び出しがあるかどうか\n        /**\n         * ローカル変数の確認用\n         * @type {Object.<string,Object>}\n         */\n        this.localvars = { 'それ': { type: 'var', value: '' } };\n        /** コード生成器の名前 @type {string} */\n        this.genMode = 'sync'; // #637\n        /** 配列のインデックスが先頭要素(#1140) @type {int} */\n        this.arrayIndexFrom = 0;\n        /** 配列のインデックス順序を反対にするか(#1140) @type {boolean} */\n        this.flagReverseArrayIndex = false;\n        /** 配列を自動的に初期化するか(#1140) @type {boolean} */\n        this.flagCheckArrayInit = false;\n        /** 最近呼び出した関数(余剰エラーの報告に使う) */\n        this.recentlyCalledFunc = [];\n        this.init();\n    }\n    init() {\n        this.funclist = {}; // 関数の一覧\n        this.reset();\n    }\n    reset() {\n        this.tokens = []; // 字句解析済みのトークンの一覧を保存\n        this.index = 0; // tokens[] のどこまで読んだかを管理する\n        this.stack = []; // 計算用のスタック ... 直接は操作せず、pushStack() popStack() を介して使う\n        this.y = []; // accept()で解析済みのトークンを配列で得るときに使う\n        this.genMode = 'sync'; // #637, #1056\n    }\n    setFuncList(funclist) {\n        this.funclist = funclist;\n    }\n    /**\n     * 特定の助詞を持つ要素をスタックから一つ下ろす、指定がなければ末尾を下ろす\n     * @param {string[]} josiList 下ろしたい助詞の配列\n     */\n    popStack(josiList = undefined) {\n        if (!josiList) {\n            const t = this.stack.pop();\n            if (t) {\n                return t;\n            }\n            return null;\n        }\n        // josiList にマッチする助詞を探す\n        for (let i = 0; i < this.stack.length; i++) {\n            const t = this.stack[i];\n            if (josiList.length === 0 || josiList.indexOf(t.josi) >= 0) {\n                this.stack.splice(i, 1); // remove stack\n                this.logger.trace('POP :' + JSON.stringify(t));\n                return t;\n            }\n        }\n        // 該当する助詞が見つからなかった場合\n        return null;\n    }\n    /**\n     * saveStack と loadStack は対で使う。\n     * 関数定義などでスタックが混乱しないように配慮するためのもの\n     */\n    saveStack() {\n        this.stackList.push(this.stack);\n        this.stack = [];\n    }\n    loadStack() {\n        this.stack = this.stackList.pop();\n    }\n    /** 変数名を探す\n     * @param {string} name\n     * @returns {any}変数名の情報\n     */\n    findVar(name) {\n        // ローカル変数？\n        if (this.localvars[name]) {\n            return {\n                name,\n                scope: 'local',\n                info: this.localvars[name]\n            };\n        }\n        // モジュール名を含んでいる?\n        if (name.indexOf('__') >= 0) {\n            if (this.funclist[name]) {\n                return {\n                    name,\n                    scope: 'global',\n                    info: this.funclist[name]\n                };\n            }\n            else {\n                return undefined;\n            }\n        }\n        // グローバル変数（自身）？\n        const gnameSelf = `${this.modName}__${name}`;\n        if (this.funclist[gnameSelf]) {\n            return {\n                name: gnameSelf,\n                scope: 'global',\n                info: this.funclist[gnameSelf]\n            };\n        }\n        // グローバル変数（モジュールを検索）？\n        for (const mod of this.modList) {\n            const gname = `${mod}__${name}`;\n            if (this.funclist[gname]) {\n                return {\n                    name: gname,\n                    scope: 'global',\n                    info: this.funclist[gname]\n                };\n            }\n        }\n        // システム変数 (funclistを普通に検索)\n        if (this.funclist[name]) {\n            return {\n                name,\n                scope: 'system',\n                info: this.funclist[name]\n            };\n        }\n        return undefined;\n    }\n    /**\n     * 計算用に要素をスタックに積む\n     */\n    pushStack(item) {\n        this.logger.debug('PUSH:' + JSON.stringify(item));\n        this.stack.push(item);\n    }\n    /**\n     * トークンの末尾に達したか\n     */\n    isEOF() {\n        return (this.index >= this.tokens.length);\n    }\n    getIndex() {\n        return this.index;\n    }\n    /**\n     * カーソル位置にある単語の型を確かめる\n     */\n    check(ttype) {\n        return (this.tokens[this.index].type === ttype);\n    }\n    /**\n     * カーソル位置以降にある単語の型を確かめる 2単語以上に対応\n     * @param a [単語1の型, 単語2の型, ... ]\n     */\n    check2(a) {\n        for (let i = 0; i < a.length; i++) {\n            const idx = i + this.index;\n            if (this.tokens.length <= idx) {\n                return false;\n            }\n            if (a[i] === '*') {\n                continue;\n            } // ワイルドカード(どんなタイプも許容)\n            const t = this.tokens[idx];\n            if (a[i] instanceof Array) {\n                if (a[i].indexOf(t.type) < 0) {\n                    return false;\n                }\n                continue;\n            }\n            if (t.type !== a[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * カーソル位置の型を確認するが、複数の種類を確かめられる\n     */\n    checkTypes(a) {\n        const type = this.tokens[this.index].type;\n        return (a.indexOf(type) >= 0);\n    }\n    /**\n     * check2の高度なやつ、型名の他にコールバック関数を指定できる\n     * 型にマッチしなければ false を返し、カーソルを巻き戻す\n     */\n    accept(types) {\n        const y = [];\n        const tmpIndex = this.index;\n        const rollback = () => {\n            this.index = tmpIndex;\n            return false;\n        };\n        for (let i = 0; i < types.length; i++) {\n            if (this.isEOF()) {\n                return rollback();\n            }\n            const type = types[i];\n            if (type == null) {\n                return rollback();\n            }\n            if (typeof type === 'string') {\n                const token = this.get();\n                if (token && token.type !== type) {\n                    return rollback();\n                }\n                y[i] = token;\n                continue;\n            }\n            if (typeof type === 'function') {\n                const f = type.bind(this);\n                const r = f(y);\n                if (r === null) {\n                    return rollback();\n                }\n                y[i] = r;\n                continue;\n            }\n            if (type instanceof Array) {\n                if (!this.checkTypes(type)) {\n                    return rollback();\n                }\n                y[i] = this.get();\n                continue;\n            }\n            throw new Error('System Error : accept broken : ' + typeof type);\n        }\n        this.y = y;\n        return true;\n    }\n    /**\n     * カーソル語句を取得して、カーソルを後ろに移動する\n     */\n    get() {\n        if (this.isEOF()) {\n            return null;\n        }\n        return this.tokens[this.index++];\n    }\n    /** カーソル語句を取得してカーソルを進める、取得できなければエラーを出す */\n    getCur() {\n        if (this.isEOF()) {\n            throw new Error('トークンが取得できません。');\n        }\n        const t = this.tokens[this.index++];\n        if (!t) {\n            throw new Error('トークンが取得できません。');\n        }\n        return t;\n    }\n    unget() {\n        if (this.index > 0) {\n            this.index--;\n        }\n    }\n    /** 解析中のトークンを返す */\n    peek(i = 0) {\n        if (this.isEOF()) {\n            return null;\n        }\n        return this.tokens[this.index + i];\n    }\n    /** 解析中のトークンを返す、無理なら def を返す */\n    peekDef(def = null) {\n        if (this.isEOF()) {\n            if (!def) {\n                def = (0,_nako_types_mjs__WEBPACK_IMPORTED_MODULE_0__.NewEmptyToken)();\n            }\n            return def;\n        }\n        return this.tokens[this.index];\n    }\n    /**\n     * 現在のカーソル語句のソースコード上の位置を取得する。\n     */\n    peekSourceMap() {\n        const token = this.peek();\n        if (token === null) {\n            return { startOffset: undefined, endOffset: undefined, file: undefined, line: 0, column: 0 };\n        }\n        return { startOffset: token.startOffset, endOffset: token.endOffset, file: token.file, line: token.line, column: token.column };\n    }\n    /**\n     * depth: 表示する深さ\n     * typeName: 先頭のtypeの表示を上書きする場合に設定する\n     * @param {{ depth: number, typeName?: string }} opts\n     * @param {boolean} debugMode\n     */\n    nodeToStr(node, opts, debugMode) {\n        const depth = opts.depth - 1;\n        const typeName = (name) => (opts.typeName !== undefined) ? opts.typeName : name;\n        const debug = debugMode ? (' debug: ' + JSON.stringify(node, null, 2)) : '';\n        if (!node) {\n            return '(NULL)';\n        }\n        switch (node.type) {\n            case 'not':\n                if (depth >= 0) {\n                    const subNode = node.value;\n                    return `${typeName('')}『${this.nodeToStr(subNode, { depth }, debugMode)}に演算子『not』を適用した式${debug}』`;\n                }\n                else {\n                    return `${typeName('演算子')}『not』`;\n                }\n            case 'op': {\n                const node2 = node;\n                let operator = node2.operator || '';\n                const table = { eq: '＝', not: '!', gt: '>', lt: '<', and: 'かつ', or: 'または' };\n                if (operator in table) {\n                    operator = table[operator];\n                }\n                if (depth >= 0) {\n                    const left = this.nodeToStr(node2.left, { depth }, debugMode);\n                    const right = this.nodeToStr(node2.right, { depth }, debugMode);\n                    if (node2.operator === 'eq') {\n                        return `${typeName('')}『${left}と${right}が等しいかどうかの比較${debug}』`;\n                    }\n                    return `${typeName('')}『${left}と${right}に演算子『${operator}』を適用した式${debug}』`;\n                }\n                else {\n                    return `${typeName('演算子')}『${operator}${debug}』`;\n                }\n            }\n            case 'number':\n                return `${typeName('数値')}${node.value}`;\n            case 'string':\n                return `${typeName('文字列')}『${node.value}${debug}』`;\n            case 'word':\n                return `${typeName('単語')}『${node.value}${debug}』`;\n            case 'func':\n                return `${typeName('関数')}『${node.name || node.value}${debug}』`;\n            case 'eol':\n                return '行の末尾';\n            case 'eof':\n                return 'ファイルの末尾';\n            default: {\n                let name = node.name;\n                if (name) {\n                    name = node.value;\n                }\n                if (typeof name !== 'string') {\n                    name = node.type;\n                }\n                return `${typeName('')}『${name}${debug}』`;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_parser_base.mjs?")},"./core/src/nako_parser_const.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"keizokuJosi\": function() { return /* binding */ keizokuJosi; },\n/* harmony export */   \"opPriority\": function() { return /* binding */ opPriority; },\n/* harmony export */   \"operatorList\": function() { return /* binding */ operatorList; }\n/* harmony export */ });\n/* eslint-disable quote-props */\nconst opPriority = {\n    // and or\n    'and': 1,\n    'or': 1,\n    // compare\n    'eq': 2,\n    'noteq': 2,\n    '===': 2,\n    '!==': 2,\n    'gt': 2,\n    'gteq': 2,\n    'lt': 2,\n    'lteq': 2,\n    '&': 3,\n    // + - << >> >>>\n    '+': 4,\n    '-': 4,\n    'shift_l': 4,\n    'shift_r': 4,\n    'shift_r0': 4,\n    // * /\n    '*': 5,\n    '/': 5,\n    '÷': 5,\n    '÷÷': 5,\n    '%': 5,\n    // ^\n    '^': 6\n};\nconst keizokuJosi = [\n    'いて', 'えて', 'きて', 'けて', 'して', 'って', 'にて', 'みて', 'めて', 'ねて', 'には', 'んで'\n];\nconst operatorList = [];\nfor (const key in opPriority) {\n    operatorList.push(key);\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_parser_const.mjs?")},"./core/src/nako_prepare.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoPrepare\": function() { return /* binding */ NakoPrepare; },\n/* harmony export */   \"Replace\": function() { return /* binding */ Replace; },\n/* harmony export */   \"checkNakoMode\": function() { return /* binding */ checkNakoMode; }\n/* harmony export */ });\n/**\n * nako_prepare.js\n * 字句解析の前の前処理。全角文字を半角文字に変換するのが主な処理。\n * ただし、コメントや文字列の中は変換しないように考慮して変換する。\n */\nclass ReplaceHistory {\n    constructor(from, to, index) {\n        this.from = from;\n        this.to = to;\n        this.index = index;\n    }\n}\nclass ConvertResult {\n    constructor(text, sourcePosition) {\n        this.text = text;\n        this.sourcePosition = sourcePosition;\n    }\n}\n/**\n * 置換後の位置から置換前の位置へマッピングできる文字列\n */\nclass Replace {\n    constructor(code) {\n        this.history = [];\n        this.code = code;\n    }\n    getText() {\n        return this.code;\n    }\n    replaceAll(from, to) {\n        while (true) {\n            const index = this.getText().indexOf(from);\n            if (index === -1) {\n                break;\n            }\n            if (from.length !== to.length) {\n                this.history.unshift(new ReplaceHistory(from.length, to.length, index));\n            }\n            this.code = this.code.replace(from, to);\n        }\n    }\n    getSourcePosition(i) {\n        // 少し遅い。パース時間1.4秒に対して0.15秒かかる。iが単調増加することを利用して高速化できるはず。\n        for (const item of this.history) {\n            if (i >= item.index + item.to) { // 置換範囲より後ろ\n                i += item.from - item.to;\n            }\n            else if (item.index <= i && i < item.index + item.to) { // 置換範囲\n                // 置換文字列が2文字以上のとき、最後の文字は最後の文字へマップする。それ以外は最初の文字へマップする。\n                if (item.to >= 2 && i === item.index + item.to - 1) {\n                    i = item.index + item.from - 1;\n                }\n                else {\n                    i = item.index;\n                }\n            }\n        }\n        return i;\n    }\n}\n/**\n * 字句解析を行う前に全角文字を半角に揃える\n *    [memo]\n *    ただし、文字列部分だけは、そのまま全角で出力するようにする\n *    for https://github.com/kujirahand/nadesiko3/issues/94\n */\nclass NakoPrepare {\n    constructor() {\n        // 単純な変換テーブル\n        this.convertTable = new Map([\n            // ハイフンへの変換\n            // 参考) https://hydrocul.github.io/wiki/blog/2014/1101-hyphen-minus-wave-tilde\n            // 0x2d: true, // ASCIIのハイフン\n            [0x2010, '-'],\n            [0x2011, '-'],\n            [0x2013, '-'],\n            [0x2014, '-'],\n            [0x2015, '-'],\n            [0x2212, '-'],\n            // チルダの変換\n            // 0x7e: true,\n            [0x02dc, '~'],\n            [0x02F7, '~'],\n            [0x2053, '~'],\n            [0x223c, '~'],\n            [0x301c, '~'],\n            [0xFF5E, '~'],\n            // スペースの変換\n            // 参考) http://anti.rosx.net/etc/memo/002_space.html\n            // 0x20: true,\n            [0x2000, ' '],\n            [0x2002, ' '],\n            [0x2003, ' '],\n            [0x2004, ' '],\n            [0x2005, ' '],\n            [0x2006, ' '],\n            [0x2007, ' '],\n            [0x2009, ' '],\n            [0x200A, ' '],\n            [0x200B, ' '],\n            [0x202F, ' '],\n            [0x205F, ' '],\n            [0x3000, ' '],\n            [0x3164, ' '],\n            // その他の変換\n            [0x09, ' '],\n            [0x203B, '#'],\n            [0x3002, ';'],\n            [0x3010, '['],\n            [0x3011, ']'],\n            // 読点は「,」に変換する (#877)\n            [0x3001, ','],\n            [0xFF0C, ','],\n            [0x2716, '*'],\n            [0x2795, '+'],\n            [0x2796, '-'],\n            [0x2797, '÷'] // ÷の絵文字 (#1183)\n        ]);\n    }\n    /** 唯一のインスタンスを返す */\n    static getInstance() {\n        if (!NakoPrepare._instance) {\n            NakoPrepare._instance = new NakoPrepare();\n        }\n        return NakoPrepare._instance;\n    }\n    // 一文字だけ変換\n    /**\n     * @param {string} ch\n     */\n    convert1ch(ch) {\n        if (!ch) {\n            return '';\n        }\n        const c = ch.codePointAt(0) || 0;\n        // テーブルによる変換\n        const c2 = this.convertTable.get(c) || '';\n        if (c2) {\n            return c2;\n        }\n        // ASCIIエリア\n        if (c < 0x7F) {\n            return ch;\n        }\n        // 全角半角単純変換可能 --- '！' - '～'\n        if (c >= 0xFF01 && c <= 0xFF5E) {\n            const c2 = c - 0xFEE0;\n            return String.fromCodePoint(c2);\n        }\n        return ch;\n    }\n    /** convert code */\n    convert(code) {\n        if (!code) {\n            return [];\n        }\n        const src = new Replace(code);\n        // 改行コードを統一\n        src.replaceAll('\\r\\n', '\\n');\n        src.replaceAll('\\r', '\\n');\n        let flagStr = false; // 文字列リテラル内かどうか\n        let flagStr2 = false; // 絵文字による文字列リテラル内かどうか\n        let endOfStr = ''; // 文字列リテラルを終了させる記号\n        const res = [];\n        let left = 0; // 現在処理中の部分文字列の左端の位置\n        let str = ''; // 文字列リテラルの値\n        // 一文字ずつ全角を半角に置換する\n        let i = 0;\n        while (i < src.getText().length) {\n            const c = src.getText().charAt(i);\n            const ch2 = src.getText().substr(i, 2);\n            // 文字列のとき\n            if (flagStr) {\n                if (c === endOfStr) {\n                    flagStr = false;\n                    res.push(new ConvertResult(str + endOfStr, src.getSourcePosition(left)));\n                    i++;\n                    left = i;\n                    continue;\n                }\n                str += c;\n                i++;\n                continue;\n            }\n            // 絵文字制御による文字列のとき\n            if (flagStr2) {\n                if (ch2 === endOfStr) {\n                    flagStr2 = false;\n                    res.push(new ConvertResult(str + endOfStr, src.getSourcePosition(left)));\n                    i += 2;\n                    left = i;\n                    continue;\n                }\n                str += c;\n                i++;\n                continue;\n            }\n            // 文字列判定\n            if (c === '「') {\n                res.push(new ConvertResult(c, src.getSourcePosition(left)));\n                i++;\n                left = i;\n                flagStr = true;\n                endOfStr = '」';\n                str = '';\n                continue;\n            }\n            if (c === '『') {\n                res.push(new ConvertResult(c, src.getSourcePosition(left)));\n                i++;\n                left = i;\n                flagStr = true;\n                endOfStr = '』';\n                str = '';\n                continue;\n            }\n            if (c === '“') {\n                res.push(new ConvertResult(c, src.getSourcePosition(left)));\n                i++;\n                left = i;\n                flagStr = true;\n                endOfStr = '”';\n                str = '';\n                continue;\n            }\n            // JavaScriptの内部的には文字列はUTF-16で扱われてるので charAt を使う場合 絵文字が2文字扱いになる --- #726\n            if (ch2 === '🌴' || ch2 === '🌿') {\n                res.push(new ConvertResult(ch2, src.getSourcePosition(left)));\n                i += 2;\n                left = i;\n                flagStr2 = true;\n                endOfStr = ch2;\n                str = '';\n                continue;\n            }\n            const c1 = this.convert1ch(c);\n            if (c1 === '\"' || c1 === '\\'') {\n                res.push(new ConvertResult(c1, src.getSourcePosition(left)));\n                i++;\n                left = i;\n                flagStr = true;\n                endOfStr = c;\n                str = '';\n                continue;\n            }\n            // ラインコメントを飛ばす (#725)\n            if (c1 === '#') {\n                res.push(new ConvertResult(c1, src.getSourcePosition(left)));\n                i++;\n                left = i;\n                flagStr = true; // 本当はコメントだけど便宜上\n                endOfStr = '\\n';\n                str = '';\n                continue;\n            }\n            // ラインコメントを飛ばす\n            if (ch2 === '//' || ch2 === '／／') {\n                res.push(new ConvertResult('//', src.getSourcePosition(left))); // 強制的に'//'とする\n                i += 2;\n                left = i;\n                flagStr = true;\n                endOfStr = '\\n';\n                str = '';\n                continue;\n            }\n            // 複数行コメント内を飛ばす (#731)\n            if (ch2 === '/*') {\n                res.push(new ConvertResult(ch2, src.getSourcePosition(left)));\n                i += 2;\n                left = i;\n                flagStr2 = true;\n                endOfStr = '*/';\n                str = '';\n                continue;\n            }\n            // 変換したものを追加\n            res.push(new ConvertResult(c1, src.getSourcePosition(left)));\n            i++;\n            left = i;\n        }\n        if (flagStr || flagStr2) {\n            res.push(new ConvertResult(str + endOfStr, src.getSourcePosition(left)));\n        }\n        return res;\n    }\n}\n/** なでしこのソースコードのモード(!インデント構文など)が設定されているか調べる */\nfunction checkNakoMode(code, modeNames) {\n    // 先頭の256文字について調べる\n    code = code.substring(0, 256);\n    // 全角半角の揺れを吸収\n    code = code.replace(/(！|💡)/, '!');\n    // 範囲コメントを削除\n    code = code.replace(/\\/\\*.*?\\*\\//g, '');\n    // 毎文調べる\n    const lines = code.split(/[;。\\n]/, 30);\n    for (let line of lines) {\n        line = line.replace(/^\\s+/, '').replace(/\\s+$/, ''); // trim\n        if (modeNames.indexOf(line) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_prepare.mjs?")},"./core/src/nako_reserved_words.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/** 予約語 */\nconst reserved = {\n    '回': '回',\n    '回繰返': '回',\n    '間': '間',\n    '間繰返': '間',\n    '繰返': '繰返',\n    '増繰返': '増繰返',\n    '減繰返': '減繰返',\n    '後判定': '後判定',\n    '反復': '反復',\n    '抜': '抜ける',\n    '続': '続ける',\n    '戻': '戻る',\n    '先': '先に',\n    '次': '次に',\n    '代入': '代入',\n    '実行速度優先': '実行速度優先',\n    'パフォーマンスモニタ適用': 'パフォーマンスモニタ適用',\n    '定': '定める',\n    '逐次実行': '逐次実行',\n    '条件分岐': '条件分岐',\n    '増': '増',\n    '減': '減',\n    '変数': '変数',\n    '定数': '定数',\n    'エラー監視': 'エラー監視',\n    'エラー': 'エラー',\n    'それ': 'word',\n    'そう': 'word',\n    '関数': 'def_func',\n    'インデント構文': 'インデント構文',\n    '非同期モード': '非同期モード',\n    'DNCLモード': 'DNCLモード',\n    'モード設定': 'モード設定',\n    '取込': '取込'\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (reserved);\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_reserved_words.mjs?")},"./core/src/nako_source_mapping.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OffsetToLineColumn\": function() { return /* binding */ OffsetToLineColumn; },\n/* harmony export */   \"SourceMappingOfIndentSyntax\": function() { return /* binding */ SourceMappingOfIndentSyntax; },\n/* harmony export */   \"SourceMappingOfTokenization\": function() { return /* binding */ SourceMappingOfTokenization; },\n/* harmony export */   \"subtractSourceMapByPreCodeLength\": function() { return /* binding */ subtractSourceMapByPreCodeLength; }\n/* harmony export */ });\n/** prepareとtokenizeのソースマッピング */\nclass SourceMappingOfTokenization {\n    /**\n       * @param {number} sourceCodeLength\n       * @param {PreprocessItem[]} preprocessed\n       */\n    constructor(sourceCodeLength, preprocessed) {\n        /** @private @readonly */\n        this.sourceCodeLength = sourceCodeLength;\n        /** @private @readonly */\n        this.preprocessed = preprocessed;\n        let i = 0;\n        /** @private @readonly @type {number[]} */\n        this.cumulativeSum = [];\n        for (const el of preprocessed) {\n            this.cumulativeSum.push(i);\n            i += el.text.length;\n        }\n        /** @private */\n        this.lastIndex = 0;\n        /** @private */\n        this.lastPreprocessedCodePosition = 0;\n    }\n    /**\n       * preprocess後の文字列上のoffsetからソースコード上のoffsetへ変換\n       * @param {number} preprocessedCodePosition\n       * @returns {number}\n       */\n    map(preprocessedCodePosition) {\n        const i = this.findIndex(preprocessedCodePosition);\n        return Math.min(this.preprocessed[i].sourcePosition + (preprocessedCodePosition - this.cumulativeSum[i]), i === this.preprocessed.length - 1 ? this.sourceCodeLength : this.preprocessed[i + 1].sourcePosition - 1);\n    }\n    /**\n       * @param {number} preprocessedCodePosition\n       * @returns {number}\n       */\n    findIndex(preprocessedCodePosition) {\n        // 連続アクセスに対する高速化\n        if (preprocessedCodePosition < this.lastPreprocessedCodePosition) {\n            this.lastIndex = 0;\n        }\n        this.lastPreprocessedCodePosition = preprocessedCodePosition;\n        for (let i = this.lastIndex; i < this.preprocessed.length - 1; i++) {\n            if (preprocessedCodePosition < this.cumulativeSum[i + 1]) {\n                this.lastIndex = i;\n                return i;\n            }\n        }\n        this.lastIndex = this.preprocessed.length - 1;\n        return this.preprocessed.length - 1;\n    }\n}\nclass SourceMappingOfIndentSyntax {\n    /**\n       * @param {string} codeAfterProcessingIndentationSyntax\n       * @param {readonly number[]} linesInsertedByIndentationSyntax\n       * @param {readonly { lineNumber: number, len: number }[]} linesDeletedByIndentationSyntax\n       */\n    constructor(codeAfterProcessingIndentationSyntax, linesInsertedByIndentationSyntax, linesDeletedByIndentationSyntax) {\n        /** @private @type {{ offset: number, len: number }[]} */\n        this.lines = [];\n        /** @private @readonly */\n        this.linesInsertedByIndentationSyntax = linesInsertedByIndentationSyntax;\n        /** @private @readonly */\n        this.linesDeletedByIndentationSyntax = linesDeletedByIndentationSyntax;\n        let offset = 0;\n        for (const line of codeAfterProcessingIndentationSyntax.split('\\n')) {\n            this.lines.push({ offset, len: line.length });\n            offset += line.length + 1;\n        }\n        /** @private */\n        this.lastLineNumber = 0;\n        /** @private */\n        this.lastOffset = 0;\n    }\n    /**\n       * @param {number | null} startOffset\n       * @param {number | null} endOffset\n       * @returns {{ startOffset: number | null, endOffset: number | null }}\n       */\n    map(startOffset, endOffset) {\n        if (startOffset === null) {\n            return { startOffset, endOffset };\n        }\n        // 何行目かを判定\n        const tokenLine = this.getLineNumber(startOffset);\n        for (const insertedLine of this.linesInsertedByIndentationSyntax) {\n            // インデント構文の処理後のソースコードの `insertedLine` 行目にあるトークンのソースマップ情報を削除する。\n            if (tokenLine === insertedLine) {\n                startOffset = null;\n                endOffset = null;\n                break;\n            }\n            // インデント構文の処理後のソースコードの `insertedLine` 行目以降にあるトークンのoffsetから\n            // `linesInsertedByIndentationSyntax[i]` 行目の文字数（\\rを含む） を引く。\n            if (tokenLine > insertedLine) {\n                // \"\\n\"の分1足す\n                startOffset -= this.lines[insertedLine].len + 1;\n                if (endOffset !== null) {\n                    endOffset -= this.lines[insertedLine].len + 1;\n                }\n            }\n        }\n        for (const deletedLine of this.linesDeletedByIndentationSyntax) {\n            if (tokenLine >= deletedLine.lineNumber) {\n                // \"\\n\"の分1足す\n                if (startOffset !== null) {\n                    startOffset += deletedLine.len + 1;\n                }\n                if (endOffset !== null) {\n                    endOffset += deletedLine.len + 1;\n                }\n            }\n        }\n        return { startOffset, endOffset };\n    }\n    /**\n       * @param {number} offset\n       * @returns {number}\n       * @private\n       */\n    getLineNumber(offset) {\n        // 連続アクセスに対する高速化\n        if (offset < this.lastOffset) {\n            this.lastLineNumber = 0;\n        }\n        this.lastOffset = offset;\n        for (let i = this.lastLineNumber; i < this.lines.length - 1; i++) {\n            if (offset < this.lines[i + 1].offset) {\n                this.lastLineNumber = i;\n                return i;\n            }\n        }\n        this.lastLineNumber = this.lines.length - 1;\n        return this.lines.length - 1;\n    }\n}\n/** offsetから (line, column) へ変換する。 */\nclass OffsetToLineColumn {\n    /**\n       * @param {string} code\n       */\n    constructor(code) {\n        /** @private @type {number[]} */\n        this.lineOffsets = [];\n        // 各行の先頭位置を先に計算しておく\n        let offset = 0;\n        for (const line of code.split('\\n')) {\n            this.lineOffsets.push(offset);\n            offset += line.length + 1;\n        }\n        /** @private */\n        this.lastLineNumber = 0;\n        /** @private */\n        this.lastOffset = 0;\n    }\n    /**\n       * @param {number} offset\n       * @param {boolean} oneBasedLineNumber trueのときlineを1から始める\n       * @returns {{ line: number, column: number }}\n       */\n    map(offset, oneBasedLineNumber) {\n        // 連続アクセスに対する高速化\n        if (offset < this.lastOffset) {\n            this.lastLineNumber = 0;\n        }\n        this.lastOffset = offset;\n        for (let i = this.lastLineNumber; i < this.lineOffsets.length - 1; i++) {\n            if (offset < this.lineOffsets[i + 1]) {\n                this.lastLineNumber = i;\n                return {\n                    line: i + (oneBasedLineNumber ? 1 : 0),\n                    column: offset - this.lineOffsets[i]\n                };\n            }\n        }\n        this.lastLineNumber = this.lineOffsets.length - 1;\n        return {\n            line: this.lineOffsets.length - 1 + (oneBasedLineNumber ? 1 : 0),\n            column: offset - this.lineOffsets[this.lineOffsets.length - 1]\n        };\n    }\n}\n/**\n * preCodeの分、ソースマップのoffset、行数、列数を減らす。\n * @type {<T extends {line?: number, column?: number, startOffset: number | null, endOffset: number | null }>(sourceMap: T, preCode: string) => T}\n */\nfunction subtractSourceMapByPreCodeLength(sourceMap, preCode) {\n    // offsetは単純に引くだけでよい\n    if (typeof sourceMap.startOffset === 'number') {\n        sourceMap.startOffset -= preCode.length;\n    }\n    if (typeof sourceMap.endOffset === 'number') {\n        sourceMap.endOffset -= preCode.length;\n    }\n    // たとえば preCode = 'abc\\ndef\\nghi' のとき、line -= 2 して、先頭行なら column -= 3 もする。\n    if (preCode !== '') {\n        const lines = preCode.split('\\n');\n        if (typeof sourceMap.line === 'number') {\n            sourceMap.line -= lines.length - 1;\n        }\n        if (sourceMap.line === 0 && typeof sourceMap.column === 'number') {\n            sourceMap.column -= lines[lines.length - 1].length;\n        }\n    }\n    return sourceMap;\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_source_mapping.mjs?")},"./core/src/nako_types.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NewEmptyToken\": function() { return /* binding */ NewEmptyToken; }\n/* harmony export */ });\n/**\n * なでしこ3 の TypeScript のための型定義\n */\nfunction NewEmptyToken(type = '?', value = {}, line = 0, file = 'main.nako3') {\n    return {\n        type,\n        value,\n        line,\n        column: 0,\n        file,\n        josi: ''\n    };\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_types.mjs?")},"./core/src/plugin_csv.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_csv.mjs */ \"./core/src/nako_csv.mjs\");\n\nconst PluginCSV = {\n    '初期化': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            // 基本的に初期化不要\n        }\n    },\n    // @CSV操作\n    'CSV取得': {\n        type: 'func',\n        josi: [['を', 'の', 'で']],\n        pure: true,\n        fn: function (str) {\n            _nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.options.delimiter = ',';\n            return (0,_nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.parse)(str);\n        }\n    },\n    'TSV取得': {\n        type: 'func',\n        josi: [['を', 'の', 'で']],\n        pure: true,\n        fn: function (str) {\n            _nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.options.delimiter = '\\t';\n            return (0,_nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.parse)(str);\n        }\n    },\n    '表CSV変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (a) {\n            _nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.options.delimiter = ',';\n            return (0,_nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(a);\n        }\n    },\n    '表TSV変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (a) {\n            _nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.options.delimiter = '\\t';\n            return (0,_nako_csv_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(a);\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (PluginCSV);\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/plugin_csv.mjs?")},"./core/src/plugin_math.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/** plugin_math */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    '初期化': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            // 初期化不要\n        }\n    },\n    // @三角関数\n    'SIN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.sin(v);\n        }\n    },\n    'COS': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.cos(v);\n        }\n    },\n    'TAN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.tan(v);\n        }\n    },\n    'ARCSIN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.asin(v);\n        }\n    },\n    'ARCCOS': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.acos(v);\n        }\n    },\n    'ARCTAN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return Math.atan(v);\n        }\n    },\n    'ATAN2': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (y, x) {\n            return Math.atan2(y, x);\n        }\n    },\n    '座標角度計算': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (XY) {\n            return Math.atan2(XY[1], XY[0]) * 180 / Math.PI;\n        }\n    },\n    'RAD2DEG': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return v / Math.PI * 180;\n        }\n    },\n    'DEG2RAD': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return (v / 180) * Math.PI;\n        }\n    },\n    '度変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return v / Math.PI * 180;\n        }\n    },\n    'ラジアン変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return (v / 180) * Math.PI;\n        }\n    },\n    // @算術関数\n    'SIGN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return (parseFloat(v) === 0) ? 0 : (v > 0) ? 1 : -1;\n        }\n    },\n    '符号': {\n        type: 'func',\n        josi: [['の']],\n        pure: false,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        fn: function (v, sys) {\n            return sys.__exec('SIGN', [v]);\n        }\n    },\n    'ABS': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.abs(a);\n        }\n    },\n    '絶対値': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.abs(a);\n        }\n    },\n    'EXP': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.exp(a);\n        }\n    },\n    'HYPOT': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return Math.hypot(a, b);\n        }\n    },\n    '斜辺': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return Math.hypot(a, b);\n        }\n    },\n    'LN': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.log(a);\n        }\n    },\n    'LOG': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.log(a);\n        }\n    },\n    'LOGN': {\n        type: 'func',\n        josi: [['で'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            if (a === 2) {\n                return Math.LOG2E * Math.log(b);\n            }\n            if (a === 10) {\n                return Math.LOG10E * Math.log(b);\n            }\n            return Math.log(b) / Math.log(a);\n        }\n    },\n    'FRAC': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return a % 1;\n        }\n    },\n    '小数部分': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return a % 1;\n        }\n    },\n    '整数部分': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.trunc(a);\n        }\n    },\n    '乱数': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.floor(Math.random() * a);\n        }\n    },\n    '乱数範囲': {\n        type: 'func',\n        josi: [['から'], ['までの', 'の']],\n        pure: true,\n        fn: function (a, b) {\n            return (Math.floor(Math.random() * (b - a + 1)) + a);\n        }\n    },\n    'SQRT': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.sqrt(a);\n        }\n    },\n    '平方根': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return Math.sqrt(a);\n        }\n    },\n    // @数値切上切捨丸め\n    'ROUND': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return Math.round(v);\n        }\n    },\n    '四捨五入': {\n        type: 'func',\n        josi: [['を', 'の']],\n        pure: true,\n        fn: function (v) {\n            return Math.round(v);\n        }\n    },\n    '小数点切上': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            const base = Math.pow(10, b);\n            return Math.ceil(a * base) / base;\n        }\n    },\n    '小数点切下': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            const base = Math.pow(10, b);\n            return Math.floor(a * base) / base;\n        }\n    },\n    '小数点四捨五入': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            const base = Math.pow(10, b);\n            return Math.round(a * base) / base;\n        }\n    },\n    'CEIL': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return Math.ceil(v);\n        }\n    },\n    '切上': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return Math.ceil(v);\n        }\n    },\n    'FLOOR': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return Math.floor(v);\n        }\n    },\n    '切捨': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return Math.floor(v);\n        }\n    }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/plugin_math.mjs?")},"./core/src/plugin_promise.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    '初期化': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            if (sys.__promise == null) {\n                sys.__promise = {\n                    setLastPromise: function (promise) {\n                        sys.__v0['そ'] = promise;\n                        return promise;\n                    }\n                };\n            }\n        }\n    },\n    // @非同期処理の保証の定数\n    'そ': { type: 'const', value: '' },\n    // @非同期処理の保証\n    '動時': {\n        type: 'func',\n        josi: [['を', 'で']],\n        pure: true,\n        fn: function (callback, sys) {\n            return sys.__promise.setLastPromise(new Promise((resolve, reject) => {\n                return callback(resolve, reject);\n            }));\n        },\n        return_none: false\n    },\n    '成功時': {\n        type: 'func',\n        josi: [['を'], ['の', 'が', 'に']],\n        pure: true,\n        fn: function (callback, promise, sys) {\n            return sys.__promise.setLastPromise(promise.then((result) => {\n                sys.__v0['対象'] = result;\n                return callback(result);\n            }));\n        },\n        return_none: false\n    },\n    '処理時': {\n        type: 'func',\n        josi: [['を'], ['の', 'が', 'に']],\n        pure: true,\n        fn: function (cbFunc, promise, sys) {\n            return sys.__promise.setLastPromise(promise.then((result) => {\n                sys.__v0['対象'] = result;\n                return cbFunc(true, result, sys);\n            }, (reason) => {\n                sys.__v0['対象'] = reason;\n                return cbFunc(false, reason, sys);\n            }));\n        },\n        return_none: false\n    },\n    '失敗時': {\n        type: 'func',\n        josi: [['を'], ['の', 'が', 'に']],\n        pure: true,\n        fn: function (callback, promise, sys) {\n            return sys.__promise.setLastPromise(promise.catch((err) => {\n                sys.__v0['対象'] = err;\n                return callback(err);\n            }));\n        },\n        return_none: false\n    },\n    '終了時': {\n        type: 'func',\n        josi: [['を'], ['の', 'が', 'に']],\n        pure: true,\n        fn: function (callback, promise, sys) {\n            return sys.__promise.setLastPromise(promise.finally(() => {\n                return callback();\n            }));\n        },\n        return_none: false\n    },\n    '束': {\n        type: 'func',\n        josi: [['と', 'を']],\n        pure: true,\n        fn: function (...args) {\n            const sys = args.pop();\n            return sys.__promise.setLastPromise(Promise.all(args));\n        },\n        return_none: false\n    }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/plugin_promise.mjs?")},"./core/src/plugin_system.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    'meta': {\n        type: 'const',\n        value: {\n            pluginName: 'plugin_system',\n            pluginVersion: '3.3.38',\n            nakoRuntime: ['wnako', 'cnako', 'phpnako'],\n            nakoVersion: '^3.3.38' // 要求なでしこバージョン\n        }\n    },\n    '初期化': {\n        type: 'func',\n        josi: [],\n        pure: false,\n        fn: function (sys) {\n            // 言語バージョンを設定\n            sys.__v0['ナデシコバージョン'] = sys.version;\n            sys.__v0['ナデシコ言語バージョン'] = sys.coreVersion;\n            // なでしこの関数や変数を探して返す\n            sys.__findVar = function (nameStr, def) {\n                if (typeof nameStr === 'function') {\n                    return nameStr;\n                }\n                if (sys.__locals[nameStr]) {\n                    return sys.__locals[nameStr];\n                }\n                const modName = ((typeof sys.__modName) !== 'undefined') ? sys.__modName : 'inline';\n                const gname = (nameStr.indexOf('__') >= 0) ? nameStr : modName + '__' + nameStr;\n                for (let i = 2; i >= 0; i--) {\n                    const scope = sys.__varslist[i];\n                    if (scope[gname]) {\n                        return scope[gname];\n                    }\n                }\n                return def;\n            };\n            // 文字列から関数を探す\n            sys.__findFunc = function (nameStr, parentFunc) {\n                const f = sys.__findVar(nameStr);\n                if (typeof f === 'function') {\n                    return f;\n                }\n                throw new Error(`『${parentFunc}』に実行できない関数が指定されました。`);\n            };\n            // システム関数を実行\n            sys.__exec = function (func, params) {\n                // システム命令を優先\n                const f0 = sys.__v0[func];\n                if (f0) {\n                    return f0.apply(this, params);\n                }\n                // グローバル・ローカルを探す\n                const f = sys.__findVar(func);\n                if (!f) {\n                    throw new Error('システム関数でエイリアスの指定ミス:' + func);\n                }\n                return f.apply(this, params);\n            };\n            // タイマーに関する処理(タイマーは「!クリア」で全部停止する)\n            sys.__timeout = [];\n            sys.__interval = [];\n            // 日付処理などに使う\n            const z2 = sys.__zero2 = (s) => {\n                s = '00' + s;\n                return s.substring(s.length - 2);\n            };\n            sys.__zero = (s, keta) => {\n                let zeroS = '';\n                for (let i = 0; i < keta; i++) {\n                    zeroS += '0';\n                }\n                s = zeroS + s;\n                return s.substring(s.length - keta);\n            };\n            sys.__formatDate = (t) => {\n                return t.getFullYear() + '/' + z2(t.getMonth() + 1) + '/' + z2(t.getDate());\n            };\n            sys.__formatTime = (t) => {\n                return z2(t.getHours()) + ':' + z2(t.getSeconds()) + ':' + z2(t.getMinutes());\n            };\n            sys.__formatDateTime = (t, fmt) => {\n                const dateStr = t.getFullYear() + '/' + z2(t.getMonth() + 1) + '/' + z2(t.getDate());\n                const timeStr = z2(t.getHours()) + ':' + z2(t.getMinutes()) + ':' + z2(t.getSeconds());\n                if (fmt.match(/^\\d+\\/\\d+\\/\\d+\\s+\\d+:\\d+:\\d+$/)) {\n                    return dateStr + ' ' + timeStr;\n                }\n                if (fmt.match(/^\\d+\\/\\d+\\/\\d+$/)) {\n                    return dateStr;\n                }\n                if (fmt.match(/^\\d+:\\d+:\\d+$/)) {\n                    return timeStr;\n                }\n                return dateStr + ' ' + timeStr;\n            };\n            sys.__str2date = (s) => {\n                // trim\n                s = ('' + s).replace(/(^\\s+|\\s+$)/, '');\n                // is unix time\n                if (s.match(/^(\\d+|\\d+\\.\\d+)$/)) {\n                    return new Date(parseFloat(s) * 1000);\n                }\n                // is time ?\n                if (s.match(/^\\d+:\\d+(:\\d+)?$/)) {\n                    const t = new Date();\n                    const a = (s + ':0').split(':');\n                    return new Date(t.getFullYear(), t.getMonth(), t.getDate(), parseInt(a[0]), parseInt(a[1]), parseInt(a[2]));\n                }\n                // replace splitter to '/'\n                s = s.replace(/[\\s:-]/g, '/');\n                s += '/0/0/0'; // 日付だけのときのために時間分を足す\n                const a = s.split('/');\n                return new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]), parseInt(a[5]));\n            };\n            // 『継続表示』のための一時変数(『表示』実行で初期化)\n            sys.__printPool = '';\n        }\n    },\n    '!クリア': {\n        type: 'func',\n        josi: [],\n        pure: false,\n        fn: function (sys) {\n            sys.__exec('全タイマー停止', [sys]);\n            if (sys.__genMode === '非同期モード') {\n                sys.__stopAsync(sys);\n            }\n            sys.__v0['表示ログ'] = '';\n        }\n    },\n    // @システム定数\n    'ナデシコバージョン': { type: 'const', value: '?' },\n    'ナデシコ言語バージョン': { type: 'const', value: '?' },\n    'ナデシコエンジン': { type: 'const', value: 'nadesi.com/v3' },\n    'ナデシコ種類': { type: 'const', value: '?' },\n    'はい': { type: 'const', value: 1 },\n    'いいえ': { type: 'const', value: 0 },\n    '真': { type: 'const', value: 1 },\n    '偽': { type: 'const', value: 0 },\n    '永遠': { type: 'const', value: 1 },\n    'オン': { type: 'const', value: 1 },\n    'オフ': { type: 'const', value: 0 },\n    '改行': { type: 'const', value: '\\n' },\n    'タブ': { type: 'const', value: '\\t' },\n    'カッコ': { type: 'const', value: '「' },\n    'カッコ閉': { type: 'const', value: '」' },\n    '波カッコ': { type: 'const', value: '{' },\n    '波カッコ閉': { type: 'const', value: '}' },\n    'OK': { type: 'const', value: true },\n    'NG': { type: 'const', value: false },\n    'キャンセル': { type: 'const', value: 0 },\n    'PI': { type: 'const', value: Math.PI },\n    '空': { type: 'const', value: '' },\n    'NULL': { type: 'const', value: null },\n    'undefined': { type: 'const', value: undefined },\n    '未定義': { type: 'const', value: undefined },\n    'エラーメッセージ': { type: 'const', value: '' },\n    '対象': { type: 'const', value: '' },\n    '対象キー': { type: 'const', value: '' },\n    '回数': { type: 'const', value: '' },\n    'CR': { type: 'const', value: '\\r' },\n    'LF': { type: 'const', value: '\\n' },\n    '非数': { type: 'const', value: NaN },\n    '無限大': { type: 'const', value: Infinity },\n    '空配列': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return [];\n        }\n    },\n    '空辞書': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return {};\n        }\n    },\n    '空ハッシュ': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return {};\n        }\n    },\n    '空オブジェクト': {\n        type: 'func',\n        josi: [],\n        pure: false,\n        fn: function (sys) {\n            return sys.__exec('空ハッシュ', [sys]);\n        }\n    },\n    // @標準出力\n    '表示': {\n        type: 'func',\n        josi: [['を', 'と']],\n        pure: true,\n        fn: function (s, sys) {\n            // 継続表示の一時プールを出力\n            s = sys.__printPool + s;\n            sys.__printPool = '';\n            //\n            sys.__varslist[0]['表示ログ'] += (s + '\\n');\n            sys.logger.send('stdout', s + '');\n        },\n        return_none: true\n    },\n    '継続表示': {\n        type: 'func',\n        josi: [['を', 'と']],\n        pure: true,\n        fn: function (s, sys) {\n            sys.__printPool += s;\n        },\n        return_none: true\n    },\n    '連続表示': {\n        type: 'func',\n        josi: [['と', 'を']],\n        isVariableJosi: true,\n        pure: true,\n        fn: function (...a) {\n            const sys = a.pop();\n            const v = a.join('');\n            sys.__exec('表示', [v, sys]);\n        },\n        return_none: true\n    },\n    '連続無改行表示': {\n        type: 'func',\n        josi: [['と', 'を']],\n        isVariableJosi: true,\n        pure: true,\n        fn: function (...a) {\n            const sys = a.pop();\n            const v = a.join('');\n            sys.__exec('継続表示', [v, sys]);\n        },\n        return_none: true\n    },\n    '表示ログ': { type: 'const', value: '' },\n    '表示ログクリア': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            sys.__varslist[0]['表示ログ'] = '';\n        },\n        return_none: true\n    },\n    '言': {\n        type: 'func',\n        josi: [['を', 'と']],\n        pure: true,\n        fn: function (s, sys) {\n            sys.logger.send('stdout', s + '');\n        },\n        return_none: true\n    },\n    'コンソール表示': {\n        type: 'func',\n        josi: [['を', 'と']],\n        pure: true,\n        fn: function (s) {\n            console.log(s);\n        },\n        return_none: true\n    },\n    // @四則演算\n    '足': {\n        type: 'func',\n        josi: [['に', 'と'], ['を']],\n        isVariableJosi: false,\n        pure: true,\n        fn: function (a, b) {\n            return a + b;\n        }\n    },\n    '引': {\n        type: 'func',\n        josi: [['から'], ['を']],\n        pure: true,\n        fn: function (a, b) {\n            return a - b;\n        }\n    },\n    '掛': {\n        type: 'func',\n        josi: [['に', 'と'], ['を']],\n        pure: true,\n        fn: function (a, b) {\n            return a * b;\n        }\n    },\n    '倍': {\n        type: 'func',\n        josi: [['の'], ['']],\n        pure: true,\n        fn: function (a, b) {\n            return a * b;\n        }\n    },\n    '割': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            return a / b;\n        }\n    },\n    '割余': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            return a % b;\n        }\n    },\n    '偶数': {\n        type: 'func',\n        josi: [['が']],\n        pure: true,\n        fn: function (a) {\n            return (parseInt(a) % 2 === 0);\n        }\n    },\n    '奇数': {\n        type: 'func',\n        josi: [['が']],\n        pure: true,\n        fn: function (a) {\n            return (parseInt(a) % 2 === 1);\n        }\n    },\n    '二乗': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (a) {\n            return a * a;\n        }\n    },\n    'べき乗': {\n        type: 'func',\n        josi: [['の'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return Math.pow(a, b);\n        }\n    },\n    '以上': {\n        type: 'func',\n        josi: [['が'], ['']],\n        pure: true,\n        fn: function (a, b) {\n            return a >= b;\n        }\n    },\n    '以下': {\n        type: 'func',\n        josi: [['が'], ['']],\n        pure: true,\n        fn: function (a, b) {\n            return a <= b;\n        }\n    },\n    '未満': {\n        type: 'func',\n        josi: [['が'], ['']],\n        pure: true,\n        fn: function (a, b) {\n            return a < b;\n        }\n    },\n    '超': {\n        type: 'func',\n        josi: [['が'], ['']],\n        pure: true,\n        fn: function (a, b) {\n            return a > b;\n        }\n    },\n    '等': {\n        type: 'func',\n        josi: [['が'], ['と']],\n        pure: true,\n        fn: function (a, b) {\n            return a === b;\n        }\n    },\n    '等無': {\n        type: 'func',\n        josi: [['が'], ['と']],\n        pure: true,\n        fn: function (a, b) {\n            return a !== b;\n        }\n    },\n    '一致': {\n        type: 'func',\n        josi: [['が'], ['と']],\n        pure: true,\n        fn: function (a, b) {\n            // オブジェクトの場合、JSONに変換して比較\n            if (typeof (a) === 'object') {\n                const jsonA = JSON.stringify(a);\n                const jsonB = JSON.stringify(b);\n                return jsonA === jsonB;\n            }\n            return a === b;\n        }\n    },\n    '不一致': {\n        type: 'func',\n        josi: [['が'], ['と']],\n        pure: true,\n        fn: function (a, b) {\n            // オブジェクトの場合、JSONに変換して比較\n            if (typeof (a) === 'object') {\n                const jsonA = JSON.stringify(a);\n                const jsonB = JSON.stringify(b);\n                return jsonA !== jsonB;\n            }\n            return a !== b;\n        }\n    },\n    '範囲内': {\n        type: 'func',\n        josi: [['が'], ['から'], ['の']],\n        pure: true,\n        fn: function (v, a, b) {\n            return (a <= v) && (v <= b);\n        }\n    },\n    '連続加算': {\n        type: 'func',\n        josi: [['を'], ['に', 'と']],\n        isVariableJosi: true,\n        pure: true,\n        fn: function (b, ...a) {\n            a.pop(); // 必ず末尾に sys があるので、末尾のシステム変数を除外\n            a.push(b);\n            return a.reduce((p, c) => p + c);\n        }\n    },\n    // @敬語\n    'ください': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            if (!sys.__reisetu) {\n                sys.__reisetu = 0;\n            }\n            sys.__reisetu++;\n        },\n        return_none: true\n    },\n    'お願': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            if (!sys.__reisetu) {\n                sys.__reisetu = 0;\n            }\n            sys.__reisetu++;\n        },\n        return_none: true\n    },\n    'です': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            if (!sys.__reisetu) {\n                sys.__reisetu = 0;\n            }\n            sys.__reisetu++;\n        },\n        return_none: true\n    },\n    '拝啓': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            sys.__reisetu = 0;\n        },\n        return_none: true\n    },\n    '敬具': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            sys.__reisetu += 100; // bonus point\n        },\n        return_none: true\n    },\n    '礼節レベル取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            if (!sys.__reisetu) {\n                sys.__reisetu = 0;\n            }\n            return sys.__reisetu;\n        }\n    },\n    // @特殊命令\n    'JS実行': {\n        type: 'func',\n        josi: [['を', 'で']],\n        pure: true,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        fn: function (src, sys) {\n            // [メモ] ↑のsys は eval の中でも有効なので消さない!!\n            // https://github.com/kujirahand/nadesiko3/issues/1237\n            return eval(src); // eslint-disable-line\n        }\n    },\n    'JSオブジェクト取得': {\n        type: 'func',\n        josi: [['の']],\n        pure: false,\n        fn: function (name, sys) {\n            return sys.__findVar(name, null);\n        }\n    },\n    'JS関数実行': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        fn: function (name, args) {\n            // nameが文字列ならevalして関数を得る\n            // eslint-disable-next-line no-eval\n            if (typeof name === 'string') {\n                name = eval(name);\n            }\n            if (typeof name !== 'function') {\n                throw new Error('JS関数取得で実行できません。');\n            }\n            // argsがArrayでなければArrayに変換する\n            if (!(args instanceof Array)) {\n                args = [args];\n            }\n            // 実行\n            return name.apply(null, args);\n        }\n    },\n    'JSメソッド実行': {\n        type: 'func',\n        josi: [['の'], ['を'], ['で']],\n        fn: function (obj, m, args) {\n            // objが文字列ならevalして関数を得る\n            // eslint-disable-next-line no-eval\n            if (typeof obj === 'string') {\n                obj = eval(obj);\n            }\n            if (typeof obj !== 'object') {\n                throw new Error('JSオブジェクトを取得できませんでした。');\n            }\n            // method を求める\n            if (typeof m !== 'function') {\n                m = obj[m];\n            }\n            // argsがArrayでなければArrayに変換する\n            if (!(args instanceof Array)) {\n                args = [args];\n            }\n            // 実行\n            return m.apply(obj, args);\n        }\n    },\n    'ナデシコ': {\n        type: 'func',\n        josi: [['を', 'で']],\n        pure: false,\n        fn: function (code, sys) {\n            if (sys.__genMode === '非同期モード') {\n                throw new Error('非同期モードでは「ナデシコ」は利用できません。');\n            }\n            sys.__varslist[0]['表示ログ'] = '';\n            sys.__self.runEx(code, sys.__modName, { resetEnv: false, resetLog: true });\n            const out = sys.__varslist[0]['表示ログ'] + '';\n            if (out) {\n                sys.logger.trace(out);\n            }\n            return out;\n        }\n    },\n    'ナデシコ続': {\n        type: 'func',\n        josi: [['を', 'で']],\n        fn: function (code, sys) {\n            if (sys.__genMode === '非同期モード') {\n                throw new Error('非同期モードでは「ナデシコ続」は利用できません。');\n            }\n            sys.__self.runEx(code, sys.__modName, { resetEnv: false, resetAll: false });\n            const out = sys.__varslist[0]['表示ログ'] + '';\n            if (out) {\n                sys.logger.trace(out);\n            }\n            return out;\n        }\n    },\n    '実行': {\n        type: 'func',\n        josi: [['を', 'に', 'で']],\n        pure: false,\n        fn: function (f, sys) {\n            // #938 の規則に従って処理\n            // 引数が関数なら実行\n            if (typeof f === 'function') {\n                return f(sys);\n            }\n            // 文字列なら関数に変換できるか判定して実行\n            if (typeof f === 'string') {\n                const tf = sys.__findFunc(f, '実行');\n                if (typeof tf === 'function') {\n                    return tf(sys);\n                }\n            }\n            // それ以外ならそのまま値を返す\n            return f;\n        }\n    },\n    '実行時間計測': {\n        type: 'func',\n        josi: [['の']],\n        pure: false,\n        fn: function (f, sys) {\n            if (typeof f === 'string') {\n                f = sys.__findFunc(f, '実行時間計測');\n            }\n            //\n            if (performance && performance.now) {\n                const t1 = performance.now();\n                f(sys);\n                const t2 = performance.now();\n                return (t2 - t1);\n            }\n            else {\n                const t1 = Date.now();\n                f(sys);\n                const t2 = Date.now();\n                return (t2 - t1);\n            }\n        }\n    },\n    // @型変換\n    '変数型確認': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return (typeof v);\n        }\n    },\n    'TYPEOF': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return (typeof v);\n        }\n    },\n    '文字列変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return String(v);\n        }\n    },\n    'TOSTR': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return String(v);\n        }\n    },\n    '整数変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return parseInt(v);\n        }\n    },\n    'TOINT': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return parseInt(v);\n        }\n    },\n    '実数変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return parseFloat(v);\n        }\n    },\n    'TOFLOAT': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return parseFloat(v);\n        }\n    },\n    'INT': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return parseInt(v);\n        }\n    },\n    'FLOAT': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return parseFloat(v);\n        }\n    },\n    'NAN判定': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            return isNaN(v);\n        }\n    },\n    '非数判定': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (v) {\n            // https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n            return Number.isNaN(v);\n        }\n    },\n    'HEX': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return parseInt(a).toString(16);\n        }\n    },\n    '進数変換': {\n        type: 'func',\n        josi: [['を', 'の'], ['']],\n        pure: true,\n        fn: function (v, n) {\n            return parseInt(v).toString(n);\n        }\n    },\n    '二進': {\n        type: 'func',\n        josi: [['を', 'の', 'から']],\n        pure: true,\n        fn: function (v) {\n            return parseInt(v).toString(2);\n        }\n    },\n    '二進表示': {\n        type: 'func',\n        josi: [['を', 'の', 'から']],\n        pure: true,\n        fn: function (v, sys) {\n            const s = parseInt(v).toString(2);\n            sys.__exec('表示', [s, sys]);\n        }\n    },\n    'RGB': {\n        type: 'func',\n        josi: [['と'], ['の'], ['で']],\n        pure: true,\n        fn: function (r, g, b) {\n            const z2 = (v) => {\n                const v2 = '00' + (parseInt('' + v).toString(16));\n                return v2.substring(v2.length - 2, v2.length);\n            };\n            return '#' + z2(r) + z2(g) + z2(b);\n        }\n    },\n    // @論理演算\n    '論理OR': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return (a || b);\n        }\n    },\n    '論理AND': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return (a && b);\n        }\n    },\n    '論理NOT': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return (!v) ? 1 : 0;\n        }\n    },\n    // @ビット演算\n    'OR': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return (a | b);\n        }\n    },\n    'AND': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return (a & b);\n        }\n    },\n    'XOR': {\n        type: 'func',\n        josi: [['と'], ['の']],\n        pure: true,\n        fn: function (a, b) {\n            return (a ^ b);\n        }\n    },\n    'NOT': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            return (~v);\n        }\n    },\n    'SHIFT_L': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            return (a << b);\n        }\n    },\n    'SHIFT_R': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            return (a >> b);\n        }\n    },\n    'SHIFT_UR': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, b) {\n            return (a >>> b);\n        }\n    },\n    // @文字列処理\n    '文字数': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            if (!Array.from) {\n                return String(v).length;\n            }\n            return Array.from(v).length;\n        }\n    },\n    '何文字目': {\n        type: 'func',\n        josi: [['で', 'の'], ['が']],\n        pure: true,\n        fn: function (s, a) {\n            return String(s).indexOf(a) + 1;\n        }\n    },\n    'CHR': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            if (!String.fromCodePoint) {\n                return String.fromCharCode(v);\n            }\n            return String.fromCodePoint(v);\n        }\n    },\n    'ASC': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (v) {\n            if (!String.prototype.codePointAt) {\n                return String(v).charCodeAt(0);\n            }\n            return String(v).codePointAt(0);\n        }\n    },\n    '文字挿入': {\n        type: 'func',\n        josi: [['で', 'の'], ['に', 'へ'], ['を']],\n        pure: true,\n        fn: function (s, i, a) {\n            if (i <= 0) {\n                i = 1;\n            }\n            const ss = String(s);\n            const mae = ss.substring(0, i - 1);\n            const usi = ss.substring(i - 1);\n            return mae + a + usi;\n        }\n    },\n    '文字検索': {\n        type: 'func',\n        josi: [['で', 'の'], ['から'], ['を']],\n        pure: true,\n        fn: function (s, a, b) {\n            let str = String(s);\n            str = str.substring(a);\n            const res = str.indexOf(b);\n            if (res === -1) {\n                return 0;\n            }\n            return res + 1 + a;\n        }\n    },\n    '追加': {\n        type: 'func',\n        josi: [['で', 'に', 'へ'], ['を']],\n        pure: true,\n        fn: function (s, a) {\n            if (s instanceof Array) {\n                s.push(a);\n                return s;\n            }\n            return String(s) + String(a);\n        }\n    },\n    '一行追加': {\n        type: 'func',\n        josi: [['で', 'に', 'へ'], ['を']],\n        pure: true,\n        fn: function (s, a) {\n            if (s instanceof Array) {\n                s.push(a);\n                return s;\n            }\n            return String(s) + String(a) + '\\n';\n        }\n    },\n    '文字列分解': {\n        type: 'func',\n        josi: [['を', 'の', 'で']],\n        pure: true,\n        fn: function (v) {\n            if (!Array.from) {\n                return String(v).split('');\n            }\n            return Array.from(v);\n        }\n    },\n    'リフレイン': {\n        type: 'func',\n        josi: [['を', 'の'], ['で']],\n        pure: true,\n        fn: function (v, cnt) {\n            let s = '';\n            for (let i = 0; i < cnt; i++) {\n                s += String(v);\n            }\n            return s;\n        }\n    },\n    '出現回数': {\n        type: 'func',\n        josi: [['で'], ['の']],\n        pure: true,\n        fn: function (s, a) {\n            s = '' + s;\n            a = '' + a;\n            return s.split(a).length - 1;\n        }\n    },\n    'MID': {\n        type: 'func',\n        josi: [['で', 'の'], ['から'], ['を']],\n        pure: true,\n        fn: function (s, a, cnt) {\n            cnt = cnt || 1;\n            return (String(s).substring(a - 1, a + cnt - 1));\n        }\n    },\n    '文字抜出': {\n        type: 'func',\n        josi: [['で', 'の'], ['から'], ['を', '']],\n        pure: true,\n        fn: function (s, a, cnt) {\n            cnt = cnt || 1;\n            return (String(s).substring(a - 1, a + cnt - 1));\n        }\n    },\n    'LEFT': {\n        type: 'func',\n        josi: [['の', 'で'], ['だけ']],\n        pure: true,\n        fn: function (s, cnt) {\n            return (String(s).substring(0, cnt));\n        }\n    },\n    '文字左部分': {\n        type: 'func',\n        josi: [['の', 'で'], ['だけ', '']],\n        pure: true,\n        fn: function (s, cnt) {\n            return (String(s).substring(0, cnt));\n        }\n    },\n    'RIGHT': {\n        type: 'func',\n        josi: [['の', 'で'], ['だけ']],\n        pure: true,\n        fn: function (s, cnt) {\n            s = '' + s;\n            return (s.substring(s.length - cnt, s.length));\n        }\n    },\n    '文字右部分': {\n        type: 'func',\n        josi: [['の', 'で'], ['だけ', '']],\n        pure: true,\n        fn: function (s, cnt) {\n            s = '' + s;\n            return (s.substring(s.length - cnt, s.length));\n        }\n    },\n    '区切': {\n        type: 'func',\n        josi: [['の', 'を'], ['で']],\n        pure: true,\n        fn: function (s, a) {\n            return ('' + s).split('' + a);\n        }\n    },\n    '文字列分割': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (s, a) {\n            s = '' + s;\n            a = '' + a;\n            const i = s.indexOf(a);\n            if (i < 0) {\n                return [s];\n            }\n            return [s.substring(0, i), s.substring(i + a.length)];\n        }\n    },\n    '切取': {\n        type: 'func',\n        josi: [['から', 'の'], ['まで', 'を']],\n        pure: true,\n        fn: function (s, a, sys) {\n            s = String(s);\n            const i = s.indexOf(a);\n            if (i < 0) {\n                sys.__v0['対象'] = '';\n                return s;\n            }\n            sys.__v0['対象'] = s.substring(i + a.length);\n            return s.substring(0, i);\n        }\n    },\n    '文字削除': {\n        type: 'func',\n        josi: [['の'], ['から'], ['だけ', 'を', '']],\n        pure: true,\n        fn: function (s, a, b) {\n            s = '' + s;\n            const mae = s.substring(0, a - 1);\n            const usi = s.substring((a - 1 + b));\n            return mae + usi;\n        }\n    },\n    // @置換・トリム\n    '置換': {\n        type: 'func',\n        josi: [['の', 'で'], ['を', 'から'], ['に', 'へ']],\n        pure: true,\n        fn: function (s, a, b) {\n            return String(s).split(a).join(b);\n        }\n    },\n    '単置換': {\n        type: 'func',\n        josi: [['の', 'で'], ['を'], ['に', 'へ']],\n        pure: true,\n        fn: function (s, a, b) {\n            // replaceは最初の一度だけ置換する\n            return String(s).replace(a, b);\n        }\n    },\n    'トリム': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            s = String(s).replace(/^\\s+/, '').replace(/\\s+$/, '');\n            return s;\n        }\n    },\n    '空白除去': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            s = String(s).replace(/^\\s+/, '').replace(/\\s+$/, '');\n            return s;\n        }\n    },\n    // @文字変換\n    '大文字変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).toUpperCase();\n        }\n    },\n    '小文字変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).toLowerCase();\n        }\n    },\n    '平仮名変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            const kanaToHira = (str) => {\n                return String(str).replace(/[\\u30a1-\\u30f6]/g, function (m) {\n                    const chr = m.charCodeAt(0) - 0x60;\n                    return String.fromCharCode(chr);\n                });\n            };\n            return kanaToHira('' + s);\n        }\n    },\n    'カタカナ変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            const hiraToKana = (str) => {\n                return String(str).replace(/[\\u3041-\\u3096]/g, function (m) {\n                    const chr = m.charCodeAt(0) + 0x60;\n                    return String.fromCharCode(chr);\n                });\n            };\n            return hiraToKana('' + s);\n        }\n    },\n    '英数全角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).replace(/[A-Za-z0-9]/g, function (v) {\n                return String.fromCharCode(v.charCodeAt(0) + 0xFEE0);\n            });\n        }\n    },\n    '英数半角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (v) {\n                return String.fromCharCode(v.charCodeAt(0) - 0xFEE0);\n            });\n        }\n    },\n    '英数記号全角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).replace(/[\\x20-\\x7F]/g, function (v) {\n                return String.fromCharCode(v.charCodeAt(0) + 0xFEE0);\n            });\n        }\n    },\n    '英数記号半角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s) {\n            return String(s).replace(/[\\uFF00-\\uFF5F]/g, function (v) {\n                return String.fromCharCode(v.charCodeAt(0) - 0xFEE0);\n            });\n        }\n    },\n    'カタカナ全角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s, sys) {\n            // 半角カタカナ\n            const zen1 = sys.__v0['全角カナ一覧'];\n            const han1 = sys.__v0['半角カナ一覧'];\n            const zen2 = sys.__v0['全角カナ濁音一覧'];\n            const han2 = sys.__v0['半角カナ濁音一覧'];\n            let str = '';\n            let i = 0;\n            while (i < s.length) {\n                // 濁点の変換\n                const c2 = s.substring(i, i + 2);\n                const n2 = han2.indexOf(c2);\n                if (n2 >= 0) {\n                    str += zen2.charAt(n2 / 2);\n                    i += 2;\n                    continue;\n                }\n                // 濁点以外の変換\n                const c = s.charAt(i);\n                const n = han1.indexOf(c);\n                if (n >= 0) {\n                    str += zen1.charAt(n);\n                    i++;\n                    continue;\n                }\n                str += c;\n                i++;\n            }\n            return str;\n        }\n    },\n    'カタカナ半角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (s, sys) {\n            // 半角カタカナ\n            const zen1 = sys.__v0['全角カナ一覧'];\n            const han1 = sys.__v0['半角カナ一覧'];\n            const zen2 = sys.__v0['全角カナ濁音一覧'];\n            const han2 = sys.__v0['半角カナ濁音一覧'];\n            return s.split('').map((c) => {\n                const i = zen1.indexOf(c);\n                if (i >= 0) {\n                    return han1.charAt(i);\n                }\n                const j = zen2.indexOf(c);\n                if (j >= 0) {\n                    return han2.substring(j * 2, j * 2 + 2);\n                }\n                return c;\n            }).join('');\n        }\n    },\n    '全角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: false,\n        fn: function (s, sys) {\n            let result = s;\n            result = sys.__exec('カタカナ全角変換', [result, sys]);\n            result = sys.__exec('英数記号全角変換', [result, sys]);\n            return result;\n        }\n    },\n    '半角変換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: false,\n        fn: function (s, sys) {\n            let result = s;\n            result = sys.__exec('カタカナ半角変換', [result, sys]);\n            result = sys.__exec('英数記号半角変換', [result, sys]);\n            return result;\n        }\n    },\n    '全角カナ一覧': { type: 'const', value: 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンァィゥェォャュョッ、。ー「」' },\n    '全角カナ濁音一覧': { type: 'const', value: 'ガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポ' },\n    '半角カナ一覧': { type: 'const', value: 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝｧｨｩｪｫｬｭｮｯ､｡ｰ｢｣ﾞﾟ' },\n    '半角カナ濁音一覧': { type: 'const', value: 'ｶﾞｷﾞｸﾞｹﾞｺﾞｻﾞｼﾞｽﾞｾﾞｿﾞﾀﾞﾁﾞﾂﾞﾃﾞﾄﾞﾊﾞﾋﾞﾌﾞﾍﾞﾎﾞﾊﾟﾋﾟﾌﾟﾍﾟﾎﾟ' },\n    // @JSON\n    'JSONエンコード': {\n        type: 'func',\n        josi: [['を', 'の']],\n        pure: true,\n        fn: function (v) {\n            return JSON.stringify(v);\n        }\n    },\n    'JSONエンコード整形': {\n        type: 'func',\n        josi: [['を', 'の']],\n        pure: true,\n        fn: function (v) {\n            return JSON.stringify(v, null, 2);\n        }\n    },\n    'JSONデコード': {\n        type: 'func',\n        josi: [['を', 'の', 'から']],\n        pure: true,\n        fn: function (s) {\n            return JSON.parse(s);\n        }\n    },\n    // @正規表現\n    '正規表現マッチ': {\n        type: 'func',\n        josi: [['を', 'が'], ['で', 'に']],\n        pure: true,\n        fn: function (a, b, sys) {\n            let re;\n            const f = ('' + b).match(/^\\/(.+)\\/([a-zA-Z]*)$/);\n            // パターンがない場合\n            if (f === null) {\n                re = new RegExp(b, 'g');\n            }\n            else {\n                re = new RegExp(f[1], f[2]);\n            }\n            const sa = sys.__varslist[0]['抽出文字列'] = [];\n            const m = String(a).match(re);\n            let result = m;\n            if (re.global) {\n                // no groups\n            }\n            else if (m) {\n                // has group?\n                if (m.length > 0) {\n                    result = m[0];\n                    for (let i = 1; i < m.length; i++) {\n                        sa[i - 1] = m[i];\n                    }\n                }\n            }\n            return result;\n        }\n    },\n    '抽出文字列': { type: 'const', value: [] },\n    '正規表現置換': {\n        type: 'func',\n        josi: [['の'], ['を', 'から'], ['で', 'に', 'へ']],\n        pure: true,\n        fn: function (s, a, b) {\n            let re;\n            const f = a.match(/^\\/(.+)\\/([a-zA-Z]*)/);\n            if (f === null) {\n                re = new RegExp(a, 'g');\n            }\n            else {\n                re = new RegExp(f[1], f[2]);\n            }\n            return String(s).replace(re, b);\n        }\n    },\n    '正規表現区切': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (s, a) {\n            let re;\n            const f = a.match(/^\\/(.+)\\/([a-zA-Z]*)/);\n            if (f === null) {\n                re = new RegExp(a, 'g');\n            }\n            else {\n                re = new RegExp(f[1], f[2]);\n            }\n            return String(s).split(re);\n        }\n    },\n    // @指定形式\n    '通貨形式': {\n        type: 'func',\n        josi: [['を', 'の']],\n        pure: true,\n        fn: function (v) {\n            return String(v).replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1,');\n        }\n    },\n    'ゼロ埋': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (v, a) {\n            v = String(v);\n            let z = '0';\n            for (let i = 0; i < a; i++) {\n                z += '0';\n            }\n            a = parseInt(a);\n            if (a < v.length) {\n                a = v.length;\n            }\n            const s = z + String(v);\n            return s.substring(s.length - a, s.length);\n        }\n    },\n    '空白埋': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (v, a) {\n            v = String(v);\n            let z = ' ';\n            for (let i = 0; i < a; i++) {\n                z += ' ';\n            }\n            a = parseInt(a);\n            if (a < v.length) {\n                a = v.length;\n            }\n            const s = z + String(v);\n            return s.substring(s.length - a, s.length);\n        }\n    },\n    // @文字種類\n    'かなか判定': {\n        type: 'func',\n        josi: [['を', 'の', 'が']],\n        pure: true,\n        fn: function (s) {\n            const c = String(s).charCodeAt(0);\n            return (c >= 0x3041 && c <= 0x309F);\n        }\n    },\n    'カタカナ判定': {\n        type: 'func',\n        josi: [['を', 'の', 'が']],\n        pure: true,\n        fn: function (s) {\n            const c = String(s).charCodeAt(0);\n            return (c >= 0x30A1 && c <= 0x30FA);\n        }\n    },\n    '数字判定': {\n        type: 'func',\n        josi: [['を', 'が']],\n        pure: true,\n        fn: function (s) {\n            const c = String(s).charAt(0);\n            return ((c >= '0' && c <= '9') || (c >= '０' && c <= '９'));\n        }\n    },\n    '数列判定': {\n        type: 'func',\n        josi: [['を', 'が']],\n        pure: true,\n        fn: function (s) {\n            return (String(s).match(/^[0-9.]+$/) !== null);\n        }\n    },\n    // @配列操作\n    '配列結合': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (a, s) {\n            // 配列ならOK\n            if (a instanceof Array) {\n                return a.join('' + s);\n            }\n            const a2 = String(a).split('\\n'); // 配列でなければ無理矢理改行で区切ってみる\n            return a2.join('' + s);\n        }\n    },\n    '配列検索': {\n        type: 'func',\n        josi: [['の', 'から'], ['を']],\n        pure: true,\n        fn: function (a, s) {\n            if (a instanceof Array) {\n                return a.indexOf(s);\n            } // 配列ならOK\n            return -1;\n        }\n    },\n    '配列要素数': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) {\n                return a.length;\n            } // 配列ならOK\n            if (a instanceof Object) {\n                return Object.keys(a).length;\n            }\n            return 1;\n        }\n    },\n    '要素数': {\n        type: 'func',\n        josi: [['の']],\n        pure: false,\n        fn: function (a, sys) {\n            return sys.__exec('配列要素数', [a]);\n        }\n    },\n    '配列挿入': {\n        type: 'func',\n        josi: [['の'], ['に', 'へ'], ['を']],\n        pure: true,\n        fn: function (a, i, s) {\n            if (a instanceof Array) {\n                return a.splice(i, 0, s);\n            } // 配列ならOK\n            throw new Error('『配列挿入』で配列以外の要素への挿入。');\n        }\n    },\n    '配列一括挿入': {\n        type: 'func',\n        josi: [['の'], ['に', 'へ'], ['を']],\n        pure: true,\n        fn: function (a, i, b) {\n            if (a instanceof Array && b instanceof Array) { // 配列ならOK\n                for (let j = 0; j < b.length; j++) {\n                    a.splice(i + j, 0, b[j]);\n                }\n                return a;\n            }\n            throw new Error('『配列一括挿入』で配列以外の要素への挿入。');\n        }\n    },\n    '配列ソート': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) {\n                return a.sort();\n            } // 配列ならOK\n            throw new Error('『配列ソート』で配列以外が指定されました。');\n        }\n    },\n    '配列数値ソート': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (a) {\n            // 配列ならOK\n            if (a instanceof Array) {\n                return a.sort((a, b) => {\n                    return parseFloat(a) - parseFloat(b);\n                });\n            }\n            throw new Error('『配列数値ソート』で配列以外が指定されました。');\n        }\n    },\n    '配列カスタムソート': {\n        type: 'func',\n        josi: [['で'], ['の', 'を']],\n        pure: false,\n        fn: function (f, a, sys) {\n            let ufunc = f;\n            if (typeof f === 'string') {\n                ufunc = sys.__findFunc(f, '配列カスタムソート');\n            }\n            if (a instanceof Array) {\n                return a.sort(ufunc);\n            }\n            throw new Error('『配列カスタムソート』で配列以外が指定されました。');\n        }\n    },\n    '配列逆順': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) {\n                return a.reverse();\n            } // 配列ならOK\n            throw new Error('『配列ソート』で配列以外が指定されました。');\n        }\n    },\n    '配列シャッフル': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) { // 配列ならOK\n                for (let i = a.length - 1; i > 0; i--) {\n                    const r = Math.floor(Math.random() * (i + 1));\n                    const tmp = a[i];\n                    a[i] = a[r];\n                    a[r] = tmp;\n                }\n                return a;\n            }\n            throw new Error('『配列シャッフル』で配列以外が指定されました。');\n        }\n    },\n    '配列削除': {\n        type: 'func',\n        josi: [['の', 'から'], ['を']],\n        pure: false,\n        fn: function (a, i, sys) {\n            return sys.__exec('配列切取', [a, i, sys]);\n        }\n    },\n    '配列切取': {\n        type: 'func',\n        josi: [['の', 'から'], ['を']],\n        pure: true,\n        fn: function (a, i) {\n            // 配列変数のとき\n            if (a instanceof Array) {\n                const b = a.splice(i, 1);\n                if (b instanceof Array) {\n                    return b[0];\n                } // 切り取った戻り値は必ずArrayになるので。\n                return null;\n            }\n            // 辞書型変数のとき\n            if (a instanceof Object && typeof (i) === 'string') { // 辞書型変数も許容\n                if (a[i]) {\n                    const old = a[i];\n                    delete a[i];\n                    return old;\n                }\n                return undefined;\n            }\n            throw new Error('『配列切取』で配列以外を指定。');\n        }\n    },\n    '配列取出': {\n        type: 'func',\n        josi: [['の'], ['から'], ['を']],\n        pure: true,\n        fn: function (a, i, cnt) {\n            if (a instanceof Array) {\n                return a.splice(i, cnt);\n            }\n            throw new Error('『配列取出』で配列以外を指定。');\n        }\n    },\n    '配列ポップ': {\n        type: 'func',\n        josi: [['の', 'から']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) {\n                return a.pop();\n            }\n            throw new Error('『配列ポップ』で配列以外の処理。');\n        }\n    },\n    '配列追加': {\n        type: 'func',\n        josi: [['に', 'へ'], ['を']],\n        pure: true,\n        fn: function (a, b) {\n            if (a instanceof Array) { // 配列ならOK\n                a.push(b);\n                return a;\n            }\n            throw new Error('『配列追加』で配列以外の処理。');\n        }\n    },\n    '配列複製': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (a) {\n            return JSON.parse(JSON.stringify(a));\n        }\n    },\n    '配列足': {\n        type: 'func',\n        josi: [['に', 'へ', 'と'], ['を']],\n        pure: true,\n        fn: function (a, b) {\n            if (a instanceof Array) {\n                return a.concat(b);\n            }\n            return JSON.parse(JSON.stringify(a));\n        }\n    },\n    '配列最大値': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return a.reduce((x, y) => Math.max(x, y));\n        }\n    },\n    '配列最小値': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            return a.reduce((x, y) => Math.min(x, y));\n        }\n    },\n    '配列合計': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            if (a instanceof Array) {\n                let v = 0;\n                a.forEach((n) => {\n                    const nn = parseFloat(n);\n                    if (isNaN(nn)) {\n                        return;\n                    }\n                    v += nn;\n                });\n                return v;\n            }\n            throw new Error('『配列合計』で配列変数以外の値が指定されました。');\n        }\n    },\n    // @二次元配列処理\n    '表ソート': {\n        type: 'func',\n        josi: [['の'], ['を']],\n        pure: true,\n        fn: function (a, no) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表ソート』には配列を指定する必要があります。');\n            }\n            a.sort((n, m) => {\n                const ns = n[no];\n                const ms = m[no];\n                if (ns === ms) {\n                    return 0;\n                }\n                else if (ns < ms) {\n                    return -1;\n                }\n                else {\n                    return 1;\n                }\n            });\n            return a;\n        }\n    },\n    '表数値ソート': {\n        type: 'func',\n        josi: [['の'], ['を']],\n        pure: true,\n        fn: function (a, no) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表数値ソート』には配列を指定する必要があります。');\n            }\n            a.sort((n, m) => {\n                const ns = n[no];\n                const ms = m[no];\n                return ns - ms;\n            });\n            return a;\n        }\n    },\n    '表ピックアップ': {\n        type: 'func',\n        josi: [['の'], ['から'], ['を', 'で']],\n        pure: true,\n        fn: function (a, no, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表ピックアップ』には配列を指定する必要があります。');\n            }\n            return a.filter((row) => String(row[no]).indexOf(s) >= 0);\n        }\n    },\n    '表完全一致ピックアップ': {\n        type: 'func',\n        josi: [['の'], ['から'], ['を', 'で']],\n        pure: true,\n        fn: function (a, no, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表完全ピックアップ』には配列を指定する必要があります。');\n            }\n            return a.filter((row) => row[no] === s);\n        }\n    },\n    '表検索': {\n        type: 'func',\n        josi: [['の'], ['で', 'に'], ['から'], ['を']],\n        pure: true,\n        fn: function (a, col, row, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表検索』には配列を指定する必要があります。');\n            }\n            for (let i = row; i < a.length; i++) {\n                if (a[i][col] === s) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    },\n    '表列数': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表列数』には配列を指定する必要があります。');\n            }\n            let cols = 1;\n            for (let i = 0; i < a.length; i++) {\n                if (a[i].length > cols) {\n                    cols = a[i].length;\n                }\n            }\n            return cols;\n        }\n    },\n    '表行数': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表行数』には配列を指定する必要があります。');\n            }\n            return a.length;\n        }\n    },\n    '表行列交換': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: false,\n        fn: function (a, sys) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表行列交換』には配列を指定する必要があります。');\n            }\n            const cols = sys.__exec('表列数', [a]);\n            const rows = a.length;\n            const res = [];\n            for (let r = 0; r < cols; r++) {\n                const row = [];\n                res.push(row);\n                for (let c = 0; c < rows; c++) {\n                    row[c] = (a[c][r] !== undefined) ? a[c][r] : '';\n                }\n            }\n            return res;\n        }\n    },\n    '表右回転': {\n        type: 'func',\n        josi: [['の', 'を']],\n        pure: false,\n        fn: function (a, sys) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表右回転』には配列を指定する必要があります。');\n            }\n            const cols = sys.__exec('表列数', [a]);\n            const rows = a.length;\n            const res = [];\n            for (let r = 0; r < cols; r++) {\n                const row = [];\n                res.push(row);\n                for (let c = 0; c < rows; c++) {\n                    row[c] = a[rows - c - 1][r];\n                }\n            }\n            return res;\n        }\n    },\n    '表重複削除': {\n        type: 'func',\n        josi: [['の'], ['を', 'で']],\n        pure: true,\n        fn: function (a, i) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表重複削除』には配列を指定する必要があります。');\n            }\n            const res = [];\n            const keys = {};\n            for (let n = 0; n < a.length; n++) {\n                const k = a[n][i];\n                if (undefined === keys[k]) {\n                    keys[k] = true;\n                    res.push(a[n]);\n                }\n            }\n            return res;\n        }\n    },\n    '表列取得': {\n        type: 'func',\n        josi: [['の'], ['を']],\n        pure: true,\n        fn: function (a, i) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表列取得』には配列を指定する必要があります。');\n            }\n            const res = a.map(row => row[i]);\n            return res;\n        }\n    },\n    '表列挿入': {\n        type: 'func',\n        josi: [['の'], ['に', 'へ'], ['を']],\n        pure: true,\n        fn: function (a, i, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表列挿入』には配列を指定する必要があります。');\n            }\n            const res = [];\n            a.forEach((row, idx) => {\n                let nr = [];\n                if (i > 0) {\n                    nr = nr.concat(row.slice(0, i));\n                }\n                nr.push(s[idx]);\n                nr = nr.concat(row.slice(i));\n                res.push(nr);\n            });\n            return res;\n        }\n    },\n    '表列削除': {\n        type: 'func',\n        josi: [['の'], ['を']],\n        pure: true,\n        fn: function (a, i) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表列削除』には配列を指定する必要があります。');\n            }\n            const res = [];\n            a.forEach((row) => {\n                const nr = row.slice(0);\n                nr.splice(i, 1);\n                res.push(nr);\n            });\n            return res;\n        }\n    },\n    '表列合計': {\n        type: 'func',\n        josi: [['の'], ['を', 'で']],\n        pure: true,\n        fn: function (a, i) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表列合計』には配列を指定する必要があります。');\n            }\n            let sum = 0;\n            a.forEach((row) => { sum += row[i]; });\n            return sum;\n        }\n    },\n    '表曖昧検索': {\n        type: 'func',\n        josi: [['の'], ['から'], ['で'], ['を']],\n        pure: true,\n        fn: function (a, row, col, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表曖昧検索』には配列を指定する必要があります。');\n            }\n            const re = new RegExp(s);\n            for (let i = row; i < a.length; i++) {\n                const line = a[i];\n                if (re.test(line[col])) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    },\n    '表正規表現ピックアップ': {\n        type: 'func',\n        josi: [['の', 'で'], ['から'], ['を']],\n        pure: true,\n        fn: function (a, col, s) {\n            if (!(a instanceof Array)) {\n                throw new Error('『表正規表現ピックアップ』には配列を指定する必要があります。');\n            }\n            const re = new RegExp(s);\n            const res = [];\n            for (let i = 0; i < a.length; i++) {\n                const row = a[i];\n                if (re.test(row[col])) {\n                    res.push(row.slice(0));\n                }\n            }\n            return res;\n        }\n    },\n    // @辞書型変数の操作\n    '辞書キー列挙': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            const keys = [];\n            if (a instanceof Object) { // オブジェクトのキーを返す\n                for (const key in a) {\n                    keys.push(key);\n                }\n                return keys;\n            }\n            if (a instanceof Array) { // 配列なら数字を返す\n                for (let i = 0; i < a.length; i++) {\n                    keys.push(i);\n                }\n                return keys;\n            }\n            throw new Error('『辞書キー列挙』でハッシュ以外が与えられました。');\n        }\n    },\n    '辞書キー削除': {\n        type: 'func',\n        josi: [['から', 'の'], ['を']],\n        pure: true,\n        fn: function (a, key) {\n            if (a instanceof Object) { // オブジェクトのキーを返す\n                if (a[key]) {\n                    delete a[key];\n                }\n                return a;\n            }\n            throw new Error('『辞書キー削除』でハッシュ以外が与えられました。');\n        }\n    },\n    '辞書キー存在': {\n        type: 'func',\n        josi: [['の', 'に'], ['が']],\n        pure: true,\n        fn: function (a, key) {\n            return key in a;\n        }\n    },\n    // @ハッシュ\n    'ハッシュキー列挙': {\n        type: 'func',\n        josi: [['の']],\n        pure: false,\n        fn: function (a, sys) {\n            return sys.__exec('辞書キー列挙', [a, sys]);\n        }\n    },\n    'ハッシュ内容列挙': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (a) {\n            const body = [];\n            if (a instanceof Object) { // オブジェクトのキーを返す\n                for (const key in a) {\n                    body.push(a[key]);\n                }\n                return body;\n            }\n            throw new Error('『ハッシュ内容列挙』でハッシュ以外が与えられました。');\n        }\n    },\n    'ハッシュキー削除': {\n        type: 'func',\n        josi: [['から', 'の'], ['を']],\n        pure: false,\n        fn: function (a, key, sys) {\n            return sys.__exec('辞書キー削除', [a, key, sys]);\n        }\n    },\n    'ハッシュキー存在': {\n        type: 'func',\n        josi: [['の', 'に'], ['が']],\n        pure: true,\n        fn: function (a, key) {\n            return key in a;\n        }\n    },\n    // @タイマー\n    '秒待': {\n        type: 'func',\n        josi: [['']],\n        pure: true,\n        asyncFn: true,\n        fn: function (n) {\n            return new Promise((resolve, reject) => {\n                try {\n                    setTimeout(() => { resolve(); }, parseFloat(n) * 1000);\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        },\n        return_none: true\n    },\n    '秒待機': {\n        type: 'func',\n        josi: [['']],\n        pure: true,\n        fn: function (n, sys) {\n            if (sys.__genMode === '非同期モード') {\n                const sysenv = sys.setAsync(sys);\n                setTimeout(() => {\n                    sys.compAsync(sys, sysenv);\n                }, n * 1000);\n                return;\n            }\n            if (sys.resolve === undefined) {\n                throw new Error('『秒待機』命令は『!非同期モード』で使ってください。');\n            }\n            sys.__exec('秒逐次待機', [n, sys]);\n        },\n        return_none: true\n    },\n    '秒逐次待機': {\n        type: 'func',\n        josi: [['']],\n        pure: true,\n        fn: function (n, sys) {\n            if (sys.resolve === undefined) {\n                throw new Error('『秒逐次待機』命令は『逐次実行』構文と一緒に使ってください。');\n            }\n            const resolve = sys.resolve;\n            // const reject = sys.reject\n            sys.resolveCount++;\n            const timerId = setTimeout(function () {\n                const idx = sys.__timeout.indexOf(timerId);\n                if (idx >= 0) {\n                    sys.__timeout.splice(idx, 1);\n                }\n                resolve();\n            }, n * 1000);\n            sys.__timeout.unshift(timerId);\n        },\n        return_none: true\n    },\n    '秒後': {\n        type: 'func',\n        josi: [['を'], ['']],\n        pure: false,\n        fn: function (f, n, sys) {\n            // 文字列で指定された関数をオブジェクトに変換\n            if (typeof f === 'string') {\n                f = sys.__findFunc(f, '秒後');\n            }\n            // 1回限りのタイマーをセット\n            const timerId = setTimeout(() => {\n                // 使用中リストに追加したIDを削除\n                const i = sys.__timeout.indexOf(timerId);\n                if (i >= 0) {\n                    sys.__timeout.splice(i, 1);\n                }\n                if (sys.__genMode === '非同期モード') {\n                    sys.newenv = true;\n                }\n                try {\n                    f(timerId, sys);\n                }\n                catch (e) {\n                    let err = e;\n                    if (!(e instanceof _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError)) {\n                        err = new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError(e, sys.__varslist[0].line);\n                    }\n                    sys.logger.error(err);\n                }\n            }, parseFloat(n) * 1000);\n            sys.__timeout.unshift(timerId);\n            sys.__v0['対象'] = timerId;\n            return timerId;\n        }\n    },\n    '秒毎': {\n        type: 'func',\n        josi: [['を'], ['']],\n        pure: false,\n        fn: function (f, n, sys) {\n            // 文字列で指定された関数をオブジェクトに変換\n            if (typeof f === 'string') {\n                f = sys.__findFunc(f, '秒毎');\n            }\n            // タイマーをセット\n            const timerId = setInterval(() => {\n                if (sys.__genMode === '非同期モード') {\n                    sys.newenv = true;\n                }\n                f(timerId, sys);\n            }, parseFloat(n) * 1000);\n            // タイマーIDを追加\n            sys.__interval.unshift(timerId);\n            sys.__v0['対象'] = timerId;\n            return timerId;\n        }\n    },\n    '秒タイマー開始時': {\n        type: 'func',\n        josi: [['を'], ['']],\n        pure: false,\n        fn: function (f, n, sys) {\n            return sys.__exec('秒毎', [f, n, sys]);\n        }\n    },\n    'タイマー停止': {\n        type: 'func',\n        josi: [['の', 'で']],\n        pure: true,\n        fn: function (timerId, sys) {\n            const i = sys.__interval.indexOf(timerId);\n            if (i >= 0) {\n                sys.__interval.splice(i, 1);\n                clearInterval(timerId);\n                return true;\n            }\n            const j = sys.__timeout.indexOf(timerId);\n            if (j >= 0) {\n                sys.__timeout.splice(j, 1);\n                clearTimeout(timerId);\n                return true;\n            }\n            return false;\n        },\n        return_none: false\n    },\n    '全タイマー停止': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            // clearInterval\n            for (let i = 0; i < sys.__interval.length; i++) {\n                const timerId = sys.__interval[i];\n                clearInterval(timerId);\n            }\n            sys.__interval = [];\n            // clearTimeout\n            for (let i = 0; i < sys.__timeout.length; i++) {\n                const timerId = sys.__timeout[i];\n                clearTimeout(timerId);\n            }\n            sys.__timeout = [];\n        },\n        return_none: true\n    },\n    // @日時処理(簡易)\n    '元号データ': { type: 'const', value: [{ '元号': '令和', '改元日': '2019/05/01' }, { '元号': '平成', '改元日': '1989/01/08' }, { '元号': '昭和', '改元日': '1926/12/25' }, { '元号': '大正', '改元日': '1912/07/30' }, { '元号': '明治', '改元日': '1868/10/23' }] },\n    '今': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            const z2 = (n) => {\n                n = '00' + n;\n                return n.substring(n.length - 2, n.length);\n            };\n            const t = new Date();\n            return z2(t.getHours()) + ':' + z2(t.getMinutes()) + ':' + z2(t.getSeconds());\n        }\n    },\n    'システム時間': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            const now = new Date();\n            return Math.floor(now.getTime() / 1000);\n        }\n    },\n    'システム時間ミリ秒': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            const now = new Date();\n            return now.getTime();\n        }\n    },\n    '今日': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            return sys.__formatDate(new Date());\n        }\n    },\n    '明日': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const t = Date.now() + (24 * 60 * 60 * 1000);\n            return sys.__formatDate(new Date(t));\n        }\n    },\n    '昨日': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const t = Date.now() - (24 * 60 * 60 * 1000);\n            return sys.__formatDate(new Date(t));\n        }\n    },\n    '今年': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getFullYear();\n        }\n    },\n    '来年': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getFullYear() + 1;\n        }\n    },\n    '去年': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getFullYear() - 1;\n        }\n    },\n    '今月': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getMonth() + 1;\n        }\n    },\n    '来月': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getMonth() + 2;\n        }\n    },\n    '先月': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            return (new Date()).getMonth();\n        }\n    },\n    '曜日': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (s, sys) {\n            const d = sys.__str2date(s);\n            return '日月火水木金土'.charAt(d.getDay() % 7);\n        }\n    },\n    '曜日番号取得': {\n        type: 'func',\n        josi: [['の']],\n        pure: true,\n        fn: function (s) {\n            const a = s.split('/');\n            const t = new Date(a[0], a[1] - 1, a[2]);\n            return t.getDay();\n        }\n    },\n    'UNIXTIME変換': {\n        type: 'func',\n        josi: [['の', 'を', 'から']],\n        pure: true,\n        fn: function (s, sys) {\n            const d = sys.__str2date(s);\n            return d.getTime() / 1000;\n        }\n    },\n    'UNIX時間変換': {\n        type: 'func',\n        josi: [['の', 'を', 'から']],\n        pure: true,\n        fn: function (s, sys) {\n            const d = sys.__str2date(s);\n            return d.getTime() / 1000;\n        }\n    },\n    '日時変換': {\n        type: 'func',\n        josi: [['を', 'から']],\n        pure: true,\n        fn: function (tm, sys) {\n            const t = tm * 1000;\n            return sys.__formatDateTime(new Date(t), '2022/01/01 00:00:00');\n        }\n    },\n    '日時書式変換': {\n        type: 'func',\n        josi: [['を'], ['で']],\n        pure: true,\n        fn: function (tm, fmt, sys) {\n            const t = sys.__str2date(tm);\n            fmt = fmt.replace(/(YYYY|ccc|WWW|MMM|YY|MM|DD|HH|mm|ss|[MDHmsW])/g, (m) => {\n                switch (m) {\n                    case 'YYYY': return t.getFullYear();\n                    case 'YY': return ('' + t.getFullYear()).substring(2);\n                    case 'MM': return sys.__zero2(t.getMonth() + 1);\n                    case 'DD': return sys.__zero2(t.getDate());\n                    case 'M': return (t.getMonth() + 1);\n                    case 'D': return (t.getDate());\n                    case 'HH': return sys.__zero2(t.getHours());\n                    case 'mm': return sys.__zero2(t.getMinutes());\n                    case 'ss': return sys.__zero2(t.getSeconds());\n                    case 'ccc': return sys.__zero(t.getMilliseconds(), 3);\n                    case 'H': return (t.getHours());\n                    case 'm': return (t.getMinutes());\n                    case 's': return (t.getSeconds());\n                    case 'W': return '日月火水木金土'.charAt(t.getDay() % 7);\n                    case 'WWW': return ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][t.getDay() % 7];\n                    case 'MMM': return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][t.getMonth()];\n                }\n                return m;\n            });\n            return fmt;\n        }\n    },\n    '和暦変換': {\n        type: 'func',\n        josi: [['を']],\n        pure: true,\n        fn: function (s, sys) {\n            const d = sys.__str2date(s);\n            const t = d.getTime();\n            for (const era of sys.__v0['元号データ']) {\n                const gengo = era['元号'];\n                const d2 = sys.__str2date(era['改元日']);\n                const t2 = d2.getTime();\n                if (t2 <= t) {\n                    let y = (d.getFullYear() - d2.getFullYear()) + 1;\n                    if (y === 1) {\n                        y = '元';\n                    }\n                    return gengo + y + '年' + sys.__zero2(d.getMonth() + 1) + '月' + sys.__zero2(d.getDate()) + '日';\n                }\n            }\n            throw new Error('『和暦変換』は明示以前の日付には対応していません。');\n        }\n    },\n    '年数差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = sys.__str2date(a);\n            const t2 = sys.__str2date(b);\n            return (t2.getFullYear() - t1.getFullYear());\n        }\n    },\n    '月数差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = sys.__str2date(a);\n            const t2 = sys.__str2date(b);\n            return ((t2.getFullYear() * 12 + t2.getMonth()) -\n                (t1.getFullYear() * 12 + t1.getMonth()));\n        }\n    },\n    '日数差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = Math.ceil(sys.__str2date(a).getTime() / 1000);\n            const t2 = Math.ceil(sys.__str2date(b).getTime() / 1000);\n            const days = Math.ceil((t2 - t1) / (60 * 60 * 24));\n            return days;\n        }\n    },\n    '時間差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = Math.ceil(sys.__str2date(a).getTime() / 1000);\n            const t2 = Math.ceil(sys.__str2date(b).getTime() / 1000);\n            const hours = Math.ceil((t2 - t1) / (60 * 60));\n            return hours;\n        }\n    },\n    '分差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = Math.ceil(sys.__str2date(a).getTime() / 1000);\n            const t2 = Math.ceil(sys.__str2date(b).getTime() / 1000);\n            const min = Math.ceil((t2 - t1) / (60));\n            return min;\n        }\n    },\n    '秒差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの']],\n        pure: true,\n        fn: function (a, b, sys) {\n            const t1 = Math.ceil(sys.__str2date(a).getTime() / 1000);\n            const t2 = Math.ceil(sys.__str2date(b).getTime() / 1000);\n            const sec = Math.ceil((t2 - t1));\n            return sec;\n        }\n    },\n    '日時差': {\n        type: 'func',\n        josi: [['と', 'から'], ['の', 'までの'], ['による']],\n        pure: true,\n        fn: function (a, b, unit, sys) {\n            switch (unit) {\n                case '年': return sys.__exec('年数差', [a, b, sys]);\n                case '月': return sys.__exec('月数差', [a, b, sys]);\n                case '日': return sys.__exec('日数差', [a, b, sys]);\n                case '時間': return sys.__exec('時間差', [a, b, sys]);\n                case '分': return sys.__exec('分差', [a, b, sys]);\n                case '秒': return sys.__exec('秒差', [a, b, sys]);\n            }\n            throw new Error('『日時差』で不明な単位です。');\n        }\n    },\n    '時間加算': {\n        type: 'func',\n        josi: [['に'], ['を']],\n        pure: true,\n        fn: function (s, a, sys) {\n            const op = a.charAt(0);\n            if (op === '-' || op === '+') {\n                a = a.substring(1);\n            }\n            const d = sys.__str2date(s);\n            const aa = (a + ':0:0').split(':');\n            let sec = parseInt(aa[0]) * 60 * 60 +\n                parseInt(aa[1]) * 60 +\n                parseInt(aa[2]);\n            if (op === '-') {\n                sec *= -1;\n            }\n            const rd = new Date(d.getTime() + (sec * 1000));\n            return sys.__formatDateTime(rd, s);\n        }\n    },\n    '日付加算': {\n        type: 'func',\n        josi: [['に'], ['を']],\n        pure: true,\n        fn: function (s, a, sys) {\n            let op = 1;\n            const opc = a.charAt(0);\n            if (opc === '-' || opc === '+') {\n                a = a.substring(1);\n                if (opc === '-') {\n                    op *= -1;\n                }\n            }\n            const d = sys.__str2date(s);\n            const aa = (a + '/0/0').split('/');\n            const addY = parseInt(aa[0]) * op;\n            const addM = parseInt(aa[1]) * op;\n            const addD = parseInt(aa[2]) * op;\n            d.setFullYear(d.getFullYear() + addY);\n            d.setMonth(d.getMonth() + addM);\n            d.setDate(d.getDate() + addD);\n            return sys.__formatDateTime(d, s);\n        }\n    },\n    '日時加算': {\n        type: 'func',\n        josi: [['に'], ['を']],\n        pure: true,\n        fn: function (s, a, sys) {\n            const r = ('' + a).match(/([+|-]?)(\\d+)(年|ヶ月|日|週間|時間|分|秒)$/);\n            if (!r) {\n                throw new Error('『日付加算』は『(+｜-)1(年|ヶ月|日|時間|分|秒)』の書式で指定します。');\n            }\n            switch (r[3]) {\n                case '年': return sys.__exec('日付加算', [s, `${r[1]}${r[2]}/0/0`, sys]);\n                case 'ヶ月': return sys.__exec('日付加算', [s, `${r[1]}0/${r[2]}/0`, sys]);\n                case '週間': return sys.__exec('日付加算', [s, `${r[1]}0/0/${parseInt(r[2]) * 7}`, sys]);\n                case '日': return sys.__exec('日付加算', [s, `${r[1]}0/0/${r[2]}`, sys]);\n                case '時間': return sys.__exec('時間加算', [s, `${r[1]}${r[2]}:0:0`, sys]);\n                case '分': return sys.__exec('時間加算', [s, `${r[1]}0:${r[2]}:0`, sys]);\n                case '秒': return sys.__exec('時間加算', [s, `${r[1]}0:0:${r[2]}`, sys]);\n            }\n        }\n    },\n    '時間ミリ秒取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function () {\n            if (performance && performance.now) {\n                return performance.now();\n            }\n            else if (Date.now) {\n                return Date.now();\n            }\n            else {\n                const now = new Date();\n                return now.getTime();\n            }\n        }\n    },\n    // @デバッグ支援\n    'エラー発生': {\n        type: 'func',\n        josi: [['の', 'で']],\n        pure: true,\n        fn: function (s) {\n            throw new Error(s);\n        }\n    },\n    'グローバル関数一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const vars = sys.__varslist[1];\n            const res = [];\n            for (const key in vars) {\n                if (Object.prototype.hasOwnProperty.call(vars, key)) {\n                    res.push(key);\n                }\n            }\n            return res;\n        }\n    },\n    'システム関数一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const vars = sys.__varslist[0];\n            const res = [];\n            for (const key in vars) {\n                if (Object.prototype.hasOwnProperty.call(vars, key)) {\n                    res.push(key);\n                }\n            }\n            return res;\n        }\n    },\n    'システム関数存在': {\n        type: 'func',\n        josi: [['が', 'の']],\n        pure: true,\n        fn: function (fname, sys) {\n            return (typeof sys.__v0[fname] !== 'undefined');\n        }\n    },\n    'プラグイン一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const a = [];\n            for (const f in sys.pluginfiles) {\n                a.push(f);\n            }\n            return a;\n        }\n    },\n    'モジュール一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            const a = [];\n            for (const f in sys.__module) {\n                a.push(f);\n            }\n            return a;\n        }\n    },\n    '助詞一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        asyncFn: true,\n        fn: function () {\n            return new Promise((resolve, reject) => {\n                Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./nako_josi_list.mjs */ \"./core/src/nako_josi_list.mjs\"))\n                    .then((mod) => {\n                    const obj = Object.assign({}, mod);\n                    resolve(obj.josiList);\n                })\n                    .catch((err) => {\n                    reject(err);\n                });\n            });\n        }\n    },\n    '予約語一覧取得': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        asyncFn: true,\n        fn: function () {\n            // const words = require('./nako_reserved_words.mjs')\n            return new Promise((resolve, reject) => {\n                Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./nako_reserved_words.mjs */ \"./core/src/nako_reserved_words.mjs\"))\n                    .then((mod) => {\n                    const obj = Object.assign({}, mod);\n                    const w = [];\n                    for (const key in obj.default) {\n                        w.push(key);\n                    }\n                    resolve(w);\n                })\n                    .catch((err) => {\n                    reject(err);\n                });\n            });\n        }\n    },\n    // @プラグイン管理\n    'プラグイン名': { type: 'const', value: 'メイン' },\n    'プラグイン名設定': {\n        type: 'func',\n        josi: [['に', 'へ']],\n        pure: true,\n        fn: function (s, sys) {\n            sys.__v0['プラグイン名'] = s;\n        },\n        return_none: true\n    },\n    // @URLエンコードとパラメータ\n    'URLエンコード': {\n        type: 'func',\n        josi: [['を', 'から']],\n        pure: true,\n        fn: function (text) {\n            return encodeURIComponent(text);\n        }\n    },\n    'URLデコード': {\n        type: 'func',\n        josi: [['を', 'へ', 'に']],\n        pure: true,\n        fn: function (text) {\n            return decodeURIComponent(text);\n        }\n    },\n    'URLパラメータ解析': {\n        type: 'func',\n        josi: [['を', 'の', 'から']],\n        pure: true,\n        fn: function (url, sys) {\n            const res = {};\n            if (typeof url !== 'string') {\n                return res;\n            }\n            const p = url.split('?');\n            if (p.length <= 1) {\n                return res;\n            }\n            const params = p[1].split('&');\n            for (const line of params) {\n                const line2 = line + '=';\n                const kv = line2.split('=');\n                const k = sys.__exec('URLデコード', [kv[0]]);\n                res[k] = sys.__exec('URLデコード', [kv[1]]);\n            }\n            return res;\n        }\n    },\n    // @BASE64\n    'BASE64エンコード': {\n        type: 'func',\n        josi: [['を', 'から']],\n        pure: true,\n        fn: function (text) {\n            // browser?\n            if (typeof (window) !== 'undefined' && window.btoa) {\n                const u8a = new TextEncoder().encode(text);\n                const utf8str = String.fromCharCode.apply(null, u8a);\n                return btoa(utf8str);\n            }\n            // Node?\n            if (typeof (Buffer) !== 'undefined') {\n                return Buffer.from(text).toString('base64');\n            }\n            throw new Error('『BASE64エンコード』は利用できません。');\n        }\n    },\n    'BASE64デコード': {\n        type: 'func',\n        josi: [['を', 'へ', 'に']],\n        pure: true,\n        fn: function (text) {\n            if (typeof (window) !== 'undefined' && window.atob) {\n                const decodedUtf8str = atob(text);\n                const dec = Array.prototype.map.call(decodedUtf8str, c => c.charCodeAt());\n                const decodedArray = new Uint8Array(dec);\n                return new TextDecoder('UTF-8').decode(decodedArray);\n            }\n            // Node?\n            if (typeof (Buffer) !== 'undefined') {\n                return Buffer.from(text, 'base64').toString();\n            }\n            throw new Error('『BASE64デコード』は利用できません。');\n        }\n    }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/plugin_system.mjs?")},"./core/src/plugin_test.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/**\n * file: plugin_test.js\n * テスト実行用プラグイン\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    // @テスト\n    'ASSERT等': {\n        type: 'func',\n        josi: [['と'], ['が']],\n        pure: true,\n        fn: function (a, b) {\n            if (a !== b) {\n                throw new Error(`不一致 [実際]${a} [期待]${b}`);\n            }\n            return true;\n        }\n    },\n    'テスト実行': {\n        type: 'func',\n        josi: [['と'], ['で']],\n        pure: false,\n        fn: function (a, b, sys) {\n            sys.__exec('ASSERT等', [a, b, sys]);\n        }\n    },\n    'テスト等': {\n        type: 'func',\n        josi: [['と'], ['が']],\n        pure: false,\n        fn: function (a, b, sys) {\n            sys.__exec('ASSERT等', [a, b, sys]);\n        }\n    }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/plugin_test.mjs?")},"./src/nako_version.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// 実際のバージョン定義 (自動生成されるので以下を編集しない)\nconst nakoVersion = {\n    version: '3.3.52',\n    major: 3,\n    minor: 3,\n    patch: 52\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (nakoVersion);\n\n\n//# sourceURL=webpack://nadesiko3/./src/nako_version.mjs?")},"./src/plugin_browser.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plugin_browser_color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin_browser_color.mjs */ \"./src/plugin_browser_color.mjs\");\n/* harmony import */ var _plugin_browser_system_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugin_browser_system.mjs */ \"./src/plugin_browser_system.mjs\");\n/* harmony import */ var _plugin_browser_dialog_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugin_browser_dialog.mjs */ \"./src/plugin_browser_dialog.mjs\");\n/* harmony import */ var _plugin_browser_location_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugin_browser_location.mjs */ \"./src/plugin_browser_location.mjs\");\n/* harmony import */ var _plugin_browser_ajax_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugin_browser_ajax.mjs */ \"./src/plugin_browser_ajax.mjs\");\n/* harmony import */ var _plugin_browser_dom_basic_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugin_browser_dom_basic.mjs */ \"./src/plugin_browser_dom_basic.mjs\");\n/* harmony import */ var _plugin_browser_dom_event_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugin_browser_dom_event.mjs */ \"./src/plugin_browser_dom_event.mjs\");\n/* harmony import */ var _plugin_browser_dom_parts_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugin_browser_dom_parts.mjs */ \"./src/plugin_browser_dom_parts.mjs\");\n/* harmony import */ var _plugin_browser_html_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugin_browser_html.mjs */ \"./src/plugin_browser_html.mjs\");\n/* harmony import */ var _plugin_browser_storage_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugin_browser_storage.mjs */ \"./src/plugin_browser_storage.mjs\");\n/* harmony import */ var _plugin_browser_canvas_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugin_browser_canvas.mjs */ \"./src/plugin_browser_canvas.mjs\");\n/* harmony import */ var _plugin_browser_geolocation_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugin_browser_geolocation.mjs */ \"./src/plugin_browser_geolocation.mjs\");\n/* harmony import */ var _plugin_browser_speech_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugin_browser_speech.mjs */ \"./src/plugin_browser_speech.mjs\");\n/* harmony import */ var _plugin_browser_websocket_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugin_browser_websocket.mjs */ \"./src/plugin_browser_websocket.mjs\");\n/* harmony import */ var _plugin_browser_audio_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugin_browser_audio.mjs */ \"./src/plugin_browser_audio.mjs\");\n/* harmony import */ var _plugin_browser_hotkey_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugin_browser_hotkey.mjs */ \"./src/plugin_browser_hotkey.mjs\");\n/* harmony import */ var _plugin_browser_chart_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugin_browser_chart.mjs */ \"./src/plugin_browser_chart.mjs\");\n/* harmony import */ var _plugin_browser_crypto_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugin_browser_crypto.mjs */ \"./src/plugin_browser_crypto.mjs\");\n// plugin_browser\n// @ts-nocheck\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst BrowserParts = [\n    _plugin_browser_color_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    _plugin_browser_system_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    _plugin_browser_dialog_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    _plugin_browser_location_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    _plugin_browser_ajax_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    _plugin_browser_dom_basic_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n    _plugin_browser_dom_event_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n    _plugin_browser_dom_parts_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n    _plugin_browser_html_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n    _plugin_browser_storage_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n    _plugin_browser_canvas_mjs__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n    _plugin_browser_geolocation_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n    _plugin_browser_speech_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n    _plugin_browser_websocket_mjs__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n    _plugin_browser_audio_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n    _plugin_browser_hotkey_mjs__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n    _plugin_browser_chart_mjs__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n    _plugin_browser_crypto_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"]\n];\nconst PluginBrowser = {\n    'meta': {\n        type: 'const',\n        value: {\n            pluginName: 'plugin_browser',\n            pluginVersion: '3.2.24',\n            nakoRuntime: ['wnako'],\n            nakoVersion: '^3.2.24' // 要求なでしこバージョン\n        }\n    },\n    '初期化': {\n        type: 'func',\n        josi: [],\n        pure: true,\n        fn: function (sys) {\n            /* eslint no-global-assign: 0 */\n            const doc = (typeof document === 'undefined') ? { 'body': {} } : document;\n            const win = (typeof window === 'undefined') ? { 'location': { 'href': 'http://localhost/' } } : window;\n            const nav = (typeof navigator === 'undefined') ? {} : navigator;\n            const loc = (typeof win.location === 'undefined') ? { 'href': 'http://localhost/' } : win.location;\n            // 定数を初期化\n            sys.__v0['AJAX:ONERROR'] = (err) => { console.log(err); };\n            // オブジェクトを初期化\n            sys.__v0.DOCUMENT = doc;\n            sys.__v0.WINDOW = win;\n            sys.__v0.NAVIGATOR = nav;\n            sys.__v0['DOM親要素'] = doc.body;\n            sys.__v0['ブラウザURL'] = loc.href;\n            // 便利なメソッドを定義\n            sys.__tohtml = (text) => {\n                return ('' + text)\n                    .replace(/&/g, '&amp;')\n                    .replace(/>/g, '&gt;')\n                    .replace(/</g, '&lt;');\n            };\n            sys.__tohtmlQ = (text) => {\n                return sys.__tohtml(text)\n                    .replace(/\"/g, '&#34;')\n                    .replace(/'/g, '&#39;');\n            };\n            // 「!クリア」でDOMイベントを削除するため\n            sys.__dom_events = []; // [{}, {}, {} ...]\n            // DOM追加イベント\n            sys.__addEvent = (dom, event, func, setHandler) => {\n                // dom\n                if (typeof (dom) === 'string') {\n                    dom = doc.querySelector(dom);\n                    if (!dom) {\n                        throw new Error('DOMイベントが追加できません。要素が見当たりません。');\n                    }\n                }\n                // func\n                if (typeof (func) === 'string') {\n                    func = sys.__findVar(func, null);\n                    if (!func) {\n                        throw new Error('DOMイベントが追加できません。関数が見当たりません。');\n                    }\n                }\n                // make wrapper func\n                const wrapperFunc = (e) => {\n                    sys.__v0['対象'] = e.target;\n                    sys.__v0['対象イベント'] = e;\n                    // 追加データが得られる場合\n                    if (setHandler) {\n                        setHandler(e, sys);\n                    }\n                    if (sys.__genMode === '非同期モード') {\n                        sys.newenv = true;\n                    }\n                    return func(e, sys);\n                };\n                // add\n                sys.__dom_events.push({ dom, event, func: wrapperFunc, rawFunc: func });\n                dom.addEventListener(event, wrapperFunc);\n            };\n            // キーイベントハンドラ\n            sys.__keyHandler = (e, sys) => {\n                sys.__v0['押キー'] = e.key;\n            };\n            // マウスイベントハンドラ\n            sys.__mouseHandler = (e, sys) => {\n                const box = e.target.getBoundingClientRect();\n                sys.__v0['マウスX'] = e.clientX - box.left;\n                sys.__v0['マウスY'] = e.clientY - box.top;\n            };\n            // タッチイベントハンドラ\n            sys.__touchHandler = (e, sys) => {\n                const box = e.target.getBoundingClientRect();\n                const touches = e.changedTouches;\n                if (touches.length <= 0) {\n                    return;\n                }\n                const ts = [];\n                for (let i = 0; i < touches.length; i++) {\n                    const t = touches[i];\n                    const tx = t.clientX - box.left;\n                    const ty = t.clientY - box.top;\n                    if (i === 0) {\n                        sys.__v0['タッチX'] = tx;\n                        sys.__v0['タッチY'] = ty;\n                    }\n                    ts.push([tx, ty]);\n                }\n                sys.__v0['タッチ配列'] = ts;\n                return ts;\n            };\n            // DOMイベント削除 (探して削除)\n            sys.__removeEvent = (dom, event, func) => {\n                // dom\n                if (typeof (dom) === 'string') {\n                    dom = doc.querySelector(dom);\n                    if (!dom) {\n                        throw new Error('DOMイベントが削除できません。要素が見当たりません。');\n                    }\n                }\n                // func\n                if (typeof (func) === 'string') {\n                    func = sys.__findVar(func, null);\n                    if (!func) {\n                        throw new Error('DOMイベントが削除できません。関数が見当たりません。');\n                    }\n                }\n                // find\n                for (let i = 0; i < sys.__dom_events.length; i++) {\n                    const e = sys.__dom_events[i];\n                    if (e.dom === dom && e.event === event && e.rawFunc === func) {\n                        e.dom.removeEventListener(e.event, e.func);\n                        sys.__dom_events.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            // requestAnimationFrame のためのid\n            sys.__requestAnimationFrameLastId = 0;\n            // DOMイベント全クリア\n            sys.__removeAllDomEvent = () => {\n                sys.__dom_events.forEach(e => {\n                    console.log(e.event, e.dom, e);\n                    e.dom.removeEventListener(e.event, e.func);\n                });\n                sys.__dom_events = [];\n                // requestAnimationFrame\n                if (sys.__requestAnimationFrameLastId > 0) {\n                    win.cancelAnimationFrame(sys.__requestAnimationFrameLastId);\n                    sys.__requestAnimationFrameLastId = 0;\n                }\n            };\n        }\n    },\n    '!クリア': {\n        type: 'func',\n        josi: [],\n        pure: false,\n        fn: function (sys) {\n            // chart.jsを破棄\n            if (sys.__chartjs) {\n                sys.__chartjs.destroy();\n            }\n            // 全DOMイベントをクリア\n            sys.__removeAllDomEvent();\n        }\n    }\n};\nBrowserParts.forEach((a) => {\n    const b = {};\n    Object.assign(b, a);\n    // 各モジュールでの初期化処理は認めない\n    if (typeof b['初期化'] !== 'undefined') {\n        delete b['初期化'];\n    }\n    Object.assign(PluginBrowser, b);\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (PluginBrowser);\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser.mjs?")},"./src/plugin_browser_ajax.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* eslint-disable quote-props */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @AJAXとHTTP\n  'AJAX送信時': { // @非同期通信(Ajax)でURLにデータを送信し、成功するとcallbackが実行される。その際『対象』にデータが代入される。『AJAXオプション』を指定できる。 // @AJAXそうしんしたとき\n    type: 'func',\n    josi: [['の'], ['まで', 'へ', 'に']],\n    pure: true,\n    fn: function (callback, url, sys) {\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        if (sys.__genMode === '非同期モード') { sys.newenv = true }\n        callback(text, sys)\n      }).catch(err => {\n        console.log('[fetch.error]', err)\n        sys.__v0['AJAX:ONERROR'](err)\n      })\n    },\n    return_none: true\n  },\n  'AJAX受信': { // @ (非推奨)『AJAXテキスト取得』をご利用ください。-「!非同期モード」で非同期通信(Ajax)でURLからデータを受信する。『AJAXオプション』を指定できる。結果は変数『対象』に入る// @AJAXじゅしん\n    type: 'func',\n    josi: [['から', 'を']],\n    pure: true,\n    fn: function (url, sys) {\n      if (sys.__genMode !== '非同期モード') {\n        throw new Error('『AJAX受信』を使うには、プログラムの冒頭で「!非同期モード」と宣言してください。')\n      }\n      const sysenv = sys.setAsync(sys)\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      // fetch 実行\n      fetch(url, options).then(res => {\n        if (res.ok) { // 成功したとき\n          return res.text()\n        } else { // 失敗したとき\n          throw new Error('status=' + res.status)\n        }\n      }).then(text => {\n        sys.__v0['対象'] = text\n        sys.compAsync(sys, sysenv)\n      }).catch(err => {\n        console.error('[AJAX受信のエラー]', err)\n        sys.__errorAsync(err, sys)\n      })\n    },\n    return_none: true\n  },\n  'AJAX受信時': { // @非同期通信(Ajax)を利用してURLからデータを受信した時callbackが実行される。その際『対象』にデータが代入される。『AJAXオプション』を指定できる。 // @AJAXじゅしんしたとき\n    type: 'func',\n    josi: [['で'], ['から', 'を']],\n    pure: true,\n    fn: function (callback, url, sys) {\n      sys.__exec('AJAX送信時', [callback, url, sys])\n    },\n    return_none: true\n  },\n  'GET送信時': { // @非同期通信(Ajax)でURLにデータを送信し、成功するとcallbackが実行される。その際『対象』にデータが代入される。 // @GETそうしんしたとき\n    type: 'func',\n    josi: [['の'], ['まで', 'へ', 'に']],\n    pure: false,\n    fn: function (callback, url, sys) {\n      sys.__exec('AJAX送信時', [callback, url, sys])\n    },\n    return_none: true\n  },\n  'POSTデータ生成': { // @辞書形式のデータPARAMSをkey=value&key=value...の形式に変換する // @POSTでーたせいせい\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (params, sys) {\n      const flist = []\n      for (const key in params) {\n        const v = params[key]\n        const kv = encodeURIComponent(key) + '=' + encodeURIComponent(v)\n        flist.push(kv)\n      }\n      return flist.join('&')\n    }\n  },\n  'POST送信時': { // @AjaxでURLにPARAMSをPOST送信し『対象』にデータを設定 // @POSTそうしんしたとき\n    type: 'func',\n    josi: [['の'], ['まで', 'へ', 'に'], ['を']],\n    pure: false,\n    fn: function (callback, url, params, sys) {\n      const bodyData = sys.__exec('POSTデータ生成', [params, sys])\n      const options = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: bodyData\n      }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        callback(text)\n      }).catch(err => {\n        sys.__v0['AJAX:ONERROR'](err)\n      })\n    }\n  },\n  'POSTフォーム送信時': { // @AjaxでURLにPARAMSをフォームとしてPOST送信し『対象』にデータを設定 // @POSTふぉーむそうしんしたとき\n    type: 'func',\n    josi: [['の'], ['まで', 'へ', 'に'], ['を']],\n    pure: true,\n    fn: function (callback, url, params, sys) {\n      const fd = new FormData()\n      for (const key in params) { fd.set(key, params[key]) }\n\n      const options = {\n        method: 'POST',\n        body: fd\n      }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        callback(text)\n      }).catch(err => {\n        sys.__v0['AJAX:ONERROR'](err)\n      })\n    }\n  },\n  'AJAX失敗時': { // @Ajax命令でエラーが起きたとき // @AJAXえらーしっぱいしたとき\n    type: 'func',\n    josi: [['の']],\n    pure: true,\n    fn: function (callback, sys) {\n      sys.__v0['AJAX:ONERROR'] = callback\n    }\n  },\n  'AJAXオプション': { type: 'const', value: '' }, // @AJAXおぷしょん\n  'AJAXオプション設定': { // @AJAX命令でオプションを設定 // @AJAXおぷしょんせってい\n    type: 'func',\n    josi: [['に', 'へ', 'と']],\n    pure: true,\n    fn: function (option, sys) {\n      sys.__v0['AJAXオプション'] = option\n    },\n    return_none: true\n  },\n  'AJAXオプションPOST設定': { // @AJAXオプションにPOSTメソッドとパラメータPARAMSを設定 // @AJAXおぷしょんPOSTせってい\n    type: 'func',\n    josi: [['を', 'で']],\n    pure: true,\n    fn: function (params, sys) {\n      const bodyData = sys.__exec('POSTデータ生成', [params, sys])\n      const options = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: bodyData\n      }\n      sys.__v0['AJAXオプション'] = options\n    },\n    return_none: true\n  },\n  'AJAX送信': { // @(非推奨)『AJAXテキスト取得』をご利用ください。- 逐次実行構文にて、非同期通信(Ajax)でURLにデータを送信する。成功すると『対象』にデータが代入される。 // @AJAXそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に']],\n    pure: true,\n    fn: function (url, sys) {\n      if (!sys.resolve) { throw new Error('『AJAX送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.__exec('AJAX逐次送信', [url, sys])\n    },\n    return_none: true\n  },\n  'AJAX逐次送信': { // @(非推奨)『AJAXテキスト取得』をご利用ください。- 逐次実行構文にて、非同期通信(Ajax)でURLにデータを送信する。成功すると『対象』にデータが代入される。 // @AJAXちくじそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に']],\n    pure: true,\n    fn: function (url, sys) {\n      if (!sys.resolve) { throw new Error('『AJAX逐次送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.resolveCount++\n      const resolve = sys.resolve\n      const reject = sys.reject\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        resolve()\n      }).catch(err => {\n        reject(err.message)\n      })\n    },\n    return_none: true\n  },\n  'AJAX保障送信': { // @非同期通信(Ajax)でURLにデータの送信を開始する非同期処理オブジェクト(Promise)を作成する。 // @AJAXほしょうそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に']],\n    pure: true,\n    fn: function (url, sys) {\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      return fetch(url, options)\n    },\n    return_none: false\n  },\n  'HTTP取得': { // @(非推奨)『AJAXテキスト取得』をご利用ください。- 逐次実行構文にて、非同期通信(Ajax)でURLにデータを送信する。成功すると『対象』にデータが代入される。失敗すると『AJAX失敗時』を実行。 // @HTTPしゅとく\n    type: 'func',\n    josi: [['の', 'から', 'を']],\n    pure: true,\n    fn: function (url, sys) {\n      if (!sys.resolve) { throw new Error('『HTTP取得』は『逐次実行』構文内で利用する必要があります。') }\n      sys.__exec('AJAX逐次送信', [url, sys])\n    },\n    return_none: true\n  },\n  'HTTP逐次取得': { // @(非推奨)『AJAXテキスト取得』をご利用ください。- 逐次実行構文にて、非同期通信(Ajax)でURLにデータを送信する。成功すると『対象』にデータが代入される。失敗すると『AJAX失敗時』を実行。 // @HTTPちくじしゅとく\n    type: 'func',\n    josi: [['の', 'から', 'を']],\n    pure: false,\n    fn: function (url, sys) {\n      if (!sys.resolve) { throw new Error('『HTTP逐次取得』は『逐次実行』構文内で利用する必要があります。') }\n      sys.__exec('AJAX逐次送信', [url, sys])\n    },\n    return_none: true\n  },\n  'HTTP保障取得': { // @非同期通信(Ajax)でURLにデータの送信を開始する非同期処理オブジェクト(Promise)を作成する。 // @HTTPほしょうしゅとく\n    type: 'func',\n    josi: [['の', 'から', 'を']],\n    pure: true,\n    fn: function (url, sys) {\n      return sys.__exec('AJAX保障送信', [url, sys])\n    },\n    return_none: false\n  },\n  'POST逐次送信': { // @逐次実行構文にて、AjaxでURLにPARAMSをPOST送信し『対象』にデータを設定。失敗すると『AJAX失敗時』を実行。 // @POSTちくじそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: false,\n    fn: function (url, params, sys) {\n      if (!sys.resolve) { throw new Error('『POST送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.resolveCount++\n      const resolve = sys.resolve\n      const reject = sys.reject\n      const bodyData = sys.__exec('POSTデータ生成', [params, sys])\n      const options = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: bodyData\n      }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        resolve(text)\n      }).catch(err => {\n        reject(err.message)\n      })\n    },\n    return_none: true\n  },\n  'POST送信': { // @逐次実行構文にて、AjaxでURLにPARAMSをPOST送信し『対象』にデータを設定。失敗すると『AJAX失敗時』を実行。 // @POSTそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: false,\n    fn: function (url, params, sys) {\n      if (!sys.resolve) { throw new Error('『POST送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.__exec('POST逐次送信', [url, params, sys])\n    },\n    return_none: true\n  },\n  'POST保障送信': { // @非同期通信(Ajax)でURLにPARAMSをPOST送信を開始する非同期処理オブジェクト(Promise)を作成する。 // @POSTほしょうそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: true,\n    fn: function (url, params, sys) {\n      const bodyData = sys.__exec('POSTデータ生成', [params, sys])\n      const options = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: bodyData\n      }\n      return fetch(url, options)\n    },\n    return_none: false\n  },\n  'POSTフォーム逐次送信': { // @逐次実行構文にて、AjaxでURLにPARAMSをフォームとしてPOST送信し『対象』にデータを設定。失敗すると『AJAX失敗時』を実行。 // @POSTふぉーむちくじそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: true,\n    fn: function (url, params, sys) {\n      if (!sys.resolve) { throw new Error('『POSTフォーム逐次送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.resolveCount++\n      const resolve = sys.resolve\n      const reject = sys.reject\n      const fd = new FormData()\n      for (const key in params) { fd.set(key, params[key]) }\n\n      const options = {\n        method: 'POST',\n        body: fd\n      }\n      fetch(url, options).then(res => {\n        return res.text()\n      }).then(text => {\n        sys.__v0['対象'] = text\n        resolve(text)\n      }).catch(err => {\n        reject(err.message)\n      })\n    },\n    return_none: true\n  },\n  'POSTフォーム送信': { // @逐次実行構文にて、AjaxでURLにPARAMSをフォームとしてPOST送信し『対象』にデータを設定。失敗すると『AJAX失敗時』を実行。 // @POSTふぉーむそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: false,\n    fn: function (url, params, sys) {\n      if (!sys.resolve) { throw new Error('『POSTフォーム送信』は『逐次実行』構文内で利用する必要があります。') }\n      sys.__exec('POSTフォーム逐次送信', [url, params, sys])\n    },\n    return_none: true\n  },\n  'POSTフォーム保障送信': { // @非同期通信(Ajax)でURLにPARAMSをフォームとしてPOST送信を開始する非同期処理オブジェクト(Promise)を作成する。  // @POSTふぉーむほしょうそうしん\n    type: 'func',\n    josi: [['まで', 'へ', 'に'], ['を']],\n    pure: true,\n    fn: function (url, params, sys) {\n      const fd = new FormData()\n      for (const key in params) { fd.set(key, params[key]) }\n\n      const options = {\n        method: 'POST',\n        body: fd\n      }\n      return fetch(url, options)\n    },\n    return_none: false\n  },\n  'AJAX内容取得': { // @非同期通信(Ajax)の応答から内容を指定した形式で取り出すための非同期処理オブジェクト(Promise)を返す。  // @AJAXないようしゅとく\n    type: 'func',\n    josi: [['から'], ['で']],\n    pure: true,\n    fn: function (res, type, sys) {\n      type = type.toString().toUpperCase()\n      if (type === 'TEXT' || type === 'テキスト') {\n        return res.text()\n      } else\n      if (type === 'JSON') {\n        return res.json()\n      } else\n      if (type === 'BLOB') {\n        return res.blob()\n      } else\n      if (type === 'ARRAY' || type === '配列') {\n        return res.arrayBuffer()\n      } else\n      if (type === 'BODY' || type === '本体') {\n        return res.body\n      }\n      return res.body()\n    },\n    return_none: false\n  },\n  // @新AJAX\n  'AJAXテキスト取得': { // @AJAXでURLにアクセスしテキスト形式で結果を得る。送信時AJAXオプションの値を参照。 // @AJAXてきすとしゅとく\n    type: 'func',\n    josi: [['から']],\n    pure: true,\n    asyncFn: true,\n    fn: async function (url, sys) {\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      const res = await fetch(url, options)\n      const txt = await res.text()\n      return txt\n    },\n    return_none: false\n  },\n  'AJAX_JSON取得': { // @AJAXでURLにアクセスしJSONの結果を得て、送信時AJAXオプションの値を参照。 // @AJAX_JSONしゅとく\n    type: 'func',\n    josi: [['から']],\n    pure: true,\n    asyncFn: true,\n    fn: async function (url, sys) {\n      let options = sys.__v0['AJAXオプション']\n      if (options === '') { options = { method: 'GET' } }\n      const res = await fetch(url, options)\n      const txt = await res.json()\n      return txt\n    },\n    return_none: false\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_ajax.mjs?")},"./src/plugin_browser_audio.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* eslint-disable quote-props */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @オーディオ\n  'オーディオ開': { // @オーディオファイルのURLを指定して、オーディオを読み込み、Audioオブジェクトを返す // @おーでぃおひらく\n    type: 'func',\n    josi: [['を', 'の']],\n    pure: true,\n    fn: function (url, sys) {\n      const a = new Audio()\n      a.src = url\n      return a\n    },\n    return_none: false\n  },\n  'オーディオ再生': { // @AudioオブジェクトOBJを指定してオーディを再生 // @おーでぃおさいせい\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ再生する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.loop = false\n      obj.play()\n    },\n    return_none: true\n  },\n  'オーディオループ再生': { // @AudioオブジェクトOBJを指定してオーディをループ再生する // @おーでぃおるーぷさいせい\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ再生する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.loop = true\n      obj.play()\n    },\n    return_none: true\n  },\n  'オーディオ停止': { // @AudioオブジェクトOBJを指定してオーディを停止 // @おーでぃおていし\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ停止する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.pause()\n      obj.currentTime = 0 // 暫定\n      // オーディオ停止で再生位置が0に戻らない問題(#715)\n      setTimeout(() => {\n        obj.currentTime = 0 // しっかりと設定\n      }, 10)\n    },\n    return_none: true\n  },\n  'オーディオ一時停止': { // @AudioオブジェクトOBJを指定してオーディを一時停止 // @おーでぃおいちじていし\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ一時停止する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.pause()\n    },\n    return_none: true\n  },\n  'オーディオ音量取得': { // @AudioオブジェクトOBJの音量を取得して返す // @おーでぃおおんりょうしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ長取得する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      return obj.volume\n    }\n  },\n  'オーディオ音量設定': { // @AudioオブジェクトOBJの音量をV(0-1)に設定する // @おーでぃおおんりょうせってい\n    type: 'func',\n    josi: [['を'], ['に', 'へ']],\n    pure: true,\n    fn: function (obj, v, sys) {\n      if (!obj) { throw new Error('オーディオ長取得する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.volume = v\n    },\n    return_none: true\n  },\n  'オーディオ長取得': { // @AudioオブジェクトOBJを指定してオーディの長さを取得して返す // @おーでぃおながさしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ長取得する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      return obj.duration\n    }\n  },\n  'オーディオ再生位置取得': { // @AudioオブジェクトOBJを指定してオーディの再生位置を取得して返す // @おーでぃおさいせいいちしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (obj, sys) {\n      if (!obj) { throw new Error('オーディオ再生位置取得する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      return obj.currentTime\n    }\n  },\n  'オーディオ再生位置設定': { // @AudioオブジェクトOBJを指定してオーディの位置を数値Vで設定する // @おーでぃおさいせい\n    type: 'func',\n    josi: [['を'], ['に', 'へ']],\n    pure: true,\n    fn: function (obj, v, sys) {\n      if (!obj) { throw new Error('オーディオ停止する前に、オーディオ開くで音声ファイルを読み込んでください') }\n      obj.currentTime = v\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_audio.mjs?")},"./src/plugin_browser_canvas.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* eslint-disable quote-props */\nconst errMsgCanvasInit = '描画を行うためには、HTML内にcanvasを配置し、idを振って『描画開始』命令に指定します。'\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @描画\n  '描画開始': { // @描画先にCanvas(文字列でクエリの指定も可)を指定して描画API(2D)の利用準備する // @びょうがかいし\n    type: 'func',\n    josi: [['の', 'へ', 'で']],\n    pure: true,\n    fn: function (cv, sys) {\n      if (typeof cv === 'string') { cv = document.querySelector(cv) || document.getElementById(cv) }\n\n      if (!cv) { throw new Error('『描画開始』でCanvasを取得できませんでした。') }\n      sys.__canvas = cv\n      sys.__ctx = cv.getContext('2d')\n      sys.__fillStyle = 'black'\n      sys.__strokeStyle = 'black'\n      sys.__v0['描画中キャンバス'] = cv\n      sys.__v0['描画中コンテキスト'] = sys.__ctx\n    },\n    return_none: true\n  },\n  '描画中キャンバス': { type: 'const', value: null }, // @ びょうがちゅうきゃんばす\n  '描画中コンテキスト': { type: 'const', value: null }, // @ びょうがちゅうこんてきすと\n  'キャンバス状態保存': { // @Canvasの状態を保存(save)   // @ きゃんばすじょうたいほぞん\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function (sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.save()\n    },\n    return_none: true\n  },\n  'キャンバス状態復元': { // @Canvasの状態を復元(restore)   // @ きゃんばすじょうたいふくげん\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function (sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.restore()\n    },\n    return_none: true\n  },\n  '線色設定': { // @Canvasの線の描画色(lineStyle)を指定する   // @ せんいろしてい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (v, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__strokeStyle = v\n      if (v !== '') {\n        sys.__ctx.strokeStyle = v\n      }\n    },\n    return_none: true\n  },\n  '塗色設定': { // @Canvasへの描画色(fillStyle)を指定する   // @ ぬりいろしてい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (v, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__fillStyle = v\n      if (v !== '') {\n        sys.__ctx.fillStyle = v\n      }\n    },\n    return_none: true\n  },\n  '線描画': { // @ [x1, y1]から[x2, y2]まで線を描画する // @ せんびょうが\n    type: 'func',\n    josi: [['から'], ['へ', 'まで']],\n    pure: true,\n    fn: function (a, b, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.beginPath()\n      sys.__ctx.moveTo(a[0], a[1])\n      sys.__ctx.lineTo(b[0], b[1])\n      sys.__ctx.stroke()\n    },\n    return_none: true\n  },\n  '線太設定': { // @ vに線の太さ設定 // @ せんふとさせってい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (v, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.lineWidth = v\n    },\n    return_none: true\n  },\n  '四角描画': { // @ [x, y, w, h]で矩形を描画する // @ しかくびょうが\n    type: 'func',\n    josi: [['の', 'へ', 'に']],\n    pure: true,\n    fn: function (b, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      if (sys.__fillStyle === '' && sys.__strokeStyle === '') { return }\n      sys.__ctx.beginPath()\n      sys.__ctx.rect(b[0], b[1], b[2], b[3])\n      if (sys.__fillStyle !== '') { sys.__ctx.fill() }\n      if (sys.__strokeStyle !== '') { sys.__ctx.stroke() }\n    },\n    return_none: true\n  },\n  '全描画クリア': { // @ 描画中のキャンバスをクリアする。 // @ ぜんびょうがくりあ\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function (sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.clearRect(0, 0,\n        sys.__canvas.width, sys.__canvas.height)\n    },\n    return_none: true\n  },\n  '描画クリア': { // @ [x, y, w, h]の範囲を描画クリア。空配列を指定すると『全描画クリア』と同じ。2要素の配列だと[0,0]を省略したのと同じ。 // @ びょうがくりあ\n    type: 'func',\n    josi: [['の', 'へ', 'に']],\n    pure: true,\n    fn: function (b, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      if (!(b instanceof Array)) { b = [] }\n      if (b.length === 0) {\n        b = [0, 0, sys.__canvas.width, sys.__canvas.height]\n      } else if (b.length <= 2) {\n        b.unshift(0)\n        b.unshift(0)\n      }\n      sys.__ctx.clearRect(b[0], b[1], b[2], b[3])\n    },\n    return_none: true\n  },\n  '円描画': { // @ [x, y]へrの円を描画する // @ えんびょうが\n    type: 'func',\n    josi: [['へ', 'に'], ['の']],\n    pure: true,\n    fn: function (xy, r, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      if (sys.__fillStyle === '' && sys.__strokeStyle === '') { return }\n      sys.__ctx.beginPath()\n      sys.__ctx.arc(xy[0], xy[1], r, 0, 2 * Math.PI, false)\n      if (sys.__fillStyle !== '') { sys.__ctx.fill() }\n      if (sys.__strokeStyle !== '') { sys.__ctx.stroke() }\n    },\n    return_none: true\n  },\n  '楕円描画': { // @ [x, y, x幅, y幅, 回転, 開始角, 終了角, 左回転か]に楕円を描画する // @ だえんびょうが\n    type: 'func',\n    josi: [['へ', 'に', 'の']],\n    pure: true,\n    fn: function (args, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      if (!args) { throw new Error('楕円描画の引数配列が無効です') }\n      if (args.length < 4) { throw new Error('楕円描画の引数配列が不足しています') }\n      if (args.length < 7) {\n        if (!args[4]) { args[4] = 0 }\n        if (!args[5]) { args[5] = 0 }\n        if (!args[6]) { args[6] = Math.PI * 2 }\n        if (!args[7]) { args[7] = true }\n      }\n      if (sys.__fillStyle === '' && sys.__strokeStyle === '') { return }\n      sys.__ctx.beginPath()\n      sys.__ctx.ellipse.apply(sys.__ctx, args)\n      if (sys.__fillStyle !== '') { sys.__ctx.fill() }\n      if (sys.__strokeStyle !== '') { sys.__ctx.stroke() }\n    },\n    return_none: true\n  },\n  '多角形描画': { // @ 座標配列vを指定して多角形を描画する // @ たかっけいびょうが\n    type: 'func',\n    josi: [['で', 'の', 'を']],\n    pure: true,\n    fn: function (a, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      if (sys.__fillStyle === '' && sys.__strokeStyle === '') { return }\n      sys.__ctx.beginPath()\n      const p = a[0]\n      sys.__ctx.moveTo(p[0], p[1])\n      for (let i = 1; i < a.length; i++) {\n        const t = a[i]\n        sys.__ctx.lineTo(t[0], t[1])\n      }\n      sys.__ctx.lineTo(p[0], p[1])\n      if (sys.__fillStyle !== '') { sys.__ctx.fill() }\n      if (sys.__strokeStyle !== '') { sys.__ctx.stroke() }\n    },\n    return_none: true\n  },\n  '画像読': { // @ 画像のURLを読み込んでImageオブジェクトを返す。(URLにdataスキームも指定可能) // @ がぞうよむ\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (url, sys) {\n      const img = new window.Image()\n      img.src = url\n      return img\n    }\n  },\n  '画像逐次読': { // @ 画像のURLを読み込んでImageオブジェクトを返す。また完了時『対象』にも代入する。『逐次実行』構文で使う。 // @ がぞうちくじよむ\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (url, sys) {\n      if (sys.resolve === undefined) { throw new Error('『画像逐次読』は『逐次実行』構文で使ってください。') }\n      sys.resolveCount++\n      const img = new window.Image()\n      img.src = url\n      img.onload = () => {\n        sys.__v0['対象'] = img\n        sys.resolve()\n      }\n      img.onerror = () => {\n        sys.__v0['対象'] = ''\n        sys.reject()\n      }\n      return img\n    }\n  },\n  '画像読時': { // @ 画像のURLを読み込んでコールバック関数Fを読み込み、変数『対象』にImageオブジェクトを代入する // @ がぞうよんだとき\n    type: 'func',\n    josi: [['で'], ['の', 'を']],\n    pure: true,\n    fn: function (f, url, sys) {\n      // 関数オブジェクトを得る\n      const func = sys.__findVar(f, null) // 文字列指定なら関数に変換\n      // 画像を読む\n      const img = new window.Image()\n      img.src = url\n      img.onload = () => {\n        sys.__v0['対象'] = img\n        func(sys)\n      }\n      img.onerror = () => {\n        sys.__v0['対象'] = ''\n        func(sys)\n      }\n    },\n    return_none: true\n  },\n  '画像描画': { // @ 画像IMG(またはURL)を描画先座標[x,y]へ描画し、Imageオブジェクトを返す。座標には2,4,8個の引数を指定可能。 // @ がぞうびょうが\n    type: 'func',\n    josi: [['の', 'を'], ['へ', 'に']],\n    pure: true,\n    fn: function (img, xy, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      const drawFunc = (im, ctx) => {\n        if (xy.length === 2) {\n          ctx.drawImage(im, xy[0], xy[1])\n        } else if (xy.length === 4) {\n          ctx.drawImage(im, xy[0], xy[1], xy[2], xy[3])\n        } else if (xy.length === 8) {\n          ctx.drawImage(im, xy[0], xy[1], xy[2], xy[3], xy[4], xy[5], xy[6], xy[7])\n        } else {\n          throw new Error('『画像描画』の第二引数の配列要素は2,4,8個のいずれかです。')\n        }\n      }\n      if (typeof img === 'string') {\n        const image = new window.Image()\n        image.src = img\n        image.onload = () => {\n          drawFunc(image, sys.__ctx)\n        }\n        return image\n      } else {\n        drawFunc(img, sys.__ctx)\n        return img\n      }\n    },\n    return_none: false\n  },\n  '画像部分描画': { // @ 画像IMG(またはURL)の座標[sx, sy, sw, sh]を描画先座標[dx, dy, dw, dh]へ描画し、Imageオブジェクトを返す // @ がぞうぶぶんびょうが\n    type: 'func',\n    josi: [['の'], ['を', 'から'], ['へ', 'に']],\n    pure: true,\n    fn: function (img, sxy, dxy, sys) {\n      const errArgLen =\n        '『画像部分描画』に使える引数は画像と、描画する座標へ2つか、' +\n        '描画する座標とその位置の4つか、使用する座標と使用する位置と描画する座標と大きさの8つだけです。'\n      if (img && sxy) {\n        if (!Array.isArray(sxy) && Array.isArray(img)) { // 逆になっていれば入れ替える\n          // eslint-disable-next-line no-proto\n          if (typeof sxy === 'string' || String(sxy.__proto__) === '[object HTMLImageElement]') {\n            const sw = img\n            img = sxy\n            sxy = sw\n          }\n        }\n      }\n\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      const drawFunc = (im, ctx) => {\n        if (!dxy) {\n          if (!sxy) {\n            ctx.drawImage(im)\n          } else if (sxy.length >= 2) { // もしsxyがあるのにdxyがなかったらdxyを代わりにする\n            dxy = sxy\n            sxy = undefined\n          }\n        }\n        if (dxy.length === 2) { ctx.drawImage(im, dxy[0], dxy[1]) } else if (dxy.length === 4) {\n          if (!sxy) {\n            ctx.drawImage(im, dxy[0], dxy[1], dxy[2], dxy[3])\n          } else if (sxy.length === 4) {\n            ctx.drawImage(im, sxy[0], sxy[1], sxy[2], sxy[3], dxy[0], dxy[1], dxy[2], dxy[3])\n          } else { throw new Error(errArgLen) }\n        } else { throw new Error(errArgLen) }\n      }\n      if (typeof img === 'string') {\n        const image = new window.Image()\n        image.src = img\n        image.onload = () => {\n          drawFunc(image, sys.__ctx)\n        }\n        return image\n      } else {\n        drawFunc(img, sys.__ctx)\n        return img\n      }\n    },\n    return_none: false\n  },\n  '描画フォント設定': { // @ 描画フォントを指定する(CSSのフォント設定と同じ 例「36px Aria」)。フォントサイズのみの指定も可。 // @ びょうがふぉんとせってい\n    type: 'func',\n    josi: [['を', 'の', 'で', 'に']],\n    pure: true,\n    fn: function (n, sys) {\n      // 数値だけならフォントサイズのみの指定\n      if (typeof n === 'number') { n += 'px sans-serif' }\n      // ピクセル数のみの指定なら適当にフォントを足す\n      if (/^[0-9]+(px|em)$/.test(n)) {\n        n = n + ' sans-serif'\n      }\n      sys.__ctx.font = n\n    },\n    return_none: true\n  },\n  '文字描画': { // @ [x, y]へテキストSを描画する(描画フォント設定でサイズなど指定) // @ もじびょうが\n    type: 'func',\n    josi: [['へ', 'に'], ['の', 'を']],\n    pure: true,\n    fn: function (xy, s, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.fillText(s, xy[0], xy[1])\n    },\n    return_none: true\n  },\n  '文字描画幅取得': { // @ テキストSを指定して文字の描画幅を取得する // @ もじびょうがはばしゅとく\n    type: 'func',\n    josi: [['の']],\n    pure: true,\n    fn: function (s, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      return sys.__ctx.measureText(s)\n    },\n    return_none: true\n  },\n  '描画起点設定': { // @ 描画位置の起点を[x,y]へ設定する(translate) // @ びょうがきてんせってい\n    type: 'func',\n    josi: [['へ', 'に']],\n    pure: true,\n    fn: function (xy, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.translate(xy[0], xy[1])\n    },\n    return_none: true\n  },\n  '描画回転': { // @ 描画内容をA度だけ回転する(rotate) // @ びょうがかいてん\n    type: 'func',\n    josi: [['だけ', 'に', 'へ']],\n    pure: true,\n    fn: function (a, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.rotate(a * Math.PI / 180)\n    },\n    return_none: true\n  },\n  '描画拡大': { // @ 描画内容を[x方向,y方向]だけ拡大する(scale) // @ びょうがかくだい\n    type: 'func',\n    josi: [['だけ', 'に', 'へ']],\n    pure: true,\n    fn: function (xy, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.scale(xy[0], xy[1])\n    },\n    return_none: true\n  },\n  '描画変換マトリクス設定': { // @ 描画内容を[a,b,c,d,e,f]の変換マトリクスに設定。既存内容を破棄して設定(setTransform) // @ びょうがへんかんまとりくすせってい\n    type: 'func',\n    josi: [['だけ', 'に', 'へ']],\n    pure: true,\n    fn: function (a, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.setTransform(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n    },\n    return_none: true\n  },\n  '描画変換マトリクス追加': { // @ 描画内容を[a,b,c,d,e,f]のマトリクスで変換。既存のマトリクスに掛け合わせる(transform) // @ びょうがへんかんまとりくすついか\n    type: 'func',\n    josi: [['だけ', 'に', 'へ']],\n    pure: true,\n    fn: function (a, sys) {\n      if (!sys.__ctx) { throw new Error(errMsgCanvasInit) }\n      sys.__ctx.transform(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n    },\n    return_none: true\n  },\n  '描画データURL変換': { // @ 描画内容をPNG形式のデータURLに変換して得る。 // @ びょうがでーたURLへんかん\n    type: 'func',\n    josi: [],\n    pure: false,\n    fn: function (sys) {\n      const cv = sys.__v0['描画中キャンバス']\n      const url = cv.toDataURL('image/png')\n      return url\n    }\n  },\n  '描画ダウンロードリンク作成': { // @ 描画内容をPNG形式のデータURLに変換してDOMに設定する。 // @ びょうがだうんろーどりんくさくせい\n    type: 'func',\n    josi: [['へ', 'に']],\n    pure: false,\n    fn: function (dom, sys) {\n      if (typeof dom === 'string') { dom = document.querySelector(dom) }\n      if (!dom) { throw new Error('『描画ダウンロードリンク作成』でDOMが見当たりません。') }\n      const cv = sys.__v0['描画中キャンバス']\n      if (!cv) { throw new Error('『描画ダウンロード』で描画中キャンバスが設定されていません。') }\n      dom.href = cv.toDataURL('image/png')\n      dom.download = 'canvas.png'\n    },\n    return_none: true\n  },\n  '描画ダウンロード': { // @ 描画内容をPNG形式のデータURLに変換してダウンロードする。(「クリックした時」などと組み合わせて使う) // @ びょうがだうんろーど\n    type: 'func',\n    josi: [],\n    pure: false,\n    fn: function (sys) {\n      if (typeof dom === 'string') { dom = document.querySelector(dom) }\n      const cv = sys.__v0['描画中キャンバス']\n      if (!cv) { throw new Error('『描画ダウンロード』で描画中キャンバスが設定されていません。') }\n      const a = document.createElement('a')\n      a.href = cv.toDataURL('image/png')\n      a.download = 'canvas.png'\n      a.click()\n      return true\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_canvas.mjs?")},"./src/plugin_browser_chart.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @グラフ描画_CHARTJS\n  'グラフ描画': { // @ Chart.jsを利用して、DATAのグラフを描画 // @ぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: true,\n    fn: function (data, sys) {\n      // Chart.jsが使えるかチェック\n      if (!window.Chart) {\n        throw new Error('『グラフ描画』のエラー。Chart.jsを取り込んでください。')\n      }\n      // Canvasが有効？\n      if (!sys.__canvas) {\n        throw new Error('『グラフ描画』のエラー。『描画開始』命令で描画先のCanvasを指定してください。 ')\n      }\n      // 日本語のキーワードを変換\n      if (data['タイプ']) { data.type = data['タイプ'] }\n      if (data['データ']) { data.data = data['データ'] }\n      if (data['オプション']) { data.options = data['オプション'] }\n      if (sys.__chartjs) {\n        sys.__chartjs.destroy()\n      }\n      // eslint-disable-next-line no-undef\n      const chart = new Chart(sys.__canvas, data)\n      sys.__chartjs = chart\n      return chart\n    }\n  },\n  'グラフオプション': { type: 'const', value: {} }, // @ぐらふおぷしょん\n  '線グラフ描画': { // @ 線グラフを描画 // @せんぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      data = sys.__exec('二次元グラフデータ変形', ['line', data, sys])\n      const d = {\n        type: 'line',\n        data: data,\n        options: sys.__v0['グラフオプション']\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '棒グラフ描画': { // @ 棒グラフを描画 // @ぼうぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      // グラフオプションの差分作成\n      const gopt = Object.assign({},\n        sys.__v0['グラフオプション'],\n        { 'indexAxis': 'x' })\n      data = sys.__exec('二次元グラフデータ変形', ['bar', data, sys])\n      const d = {\n        type: 'bar',\n        data: data,\n        options: gopt\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '横棒グラフ描画': { // @ 横棒グラフを描画 // @よこぼうぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      // グラフオプションの差分作成\n      const gopt = Object.assign({},\n        sys.__v0['グラフオプション'],\n        { 'indexAxis': 'y' })\n      data = sys.__exec('二次元グラフデータ変形', ['bar', data, sys])\n      const d = {\n        type: 'bar', // horizontalBar\n        data: data,\n        options: gopt\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '積上棒グラフ描画': { // @ 複数列のデータがある場合積み上げ棒グラフを描画 // @つみあげぼうぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      // グラフオプションの差分作成\n      const gopt = Object.assign({},\n        sys.__v0['グラフオプション'],\n        {\n          'indexAxis': 'x',\n          'scales': {\n            x: { stacked: true },\n            y: { stacked: true }\n          }\n        })\n      data = sys.__exec('二次元グラフデータ変形', ['bar', data, sys])\n      const d = {\n        type: 'bar',\n        data: data,\n        options: gopt\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '積上横棒グラフ描画': { // @ 複数列のデータがある場合積み上げ棒グラフを描画 // @つみあげよこぼうぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      // グラフオプションの差分作成\n      const gopt = Object.assign({},\n        sys.__v0['グラフオプション'],\n        {\n          'indexAxis': 'y',\n          'scales': {\n            x: { stacked: true },\n            y: { stacked: true }\n          }\n        })\n      data = sys.__exec('二次元グラフデータ変形', ['bar', data, sys])\n      const d = {\n        type: 'bar',\n        data: data,\n        options: gopt\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '散布図描画': { // @ 散布図を描画 // @さんぷず\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      // グラフオプションの差分作成\n      const gopt = Object.assign({},\n        sys.__v0['グラフオプション'],\n        {})\n      data = sys.__exec('二次元グラフデータ変形', ['scatter', data, sys])\n      const d = {\n        type: 'scatter',\n        data: data,\n        options: gopt\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '円グラフ描画': { // @ 円グラフを描画 // @えんぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      data = sys.__exec('二次元グラフデータ変形', ['pie', data, sys])\n      const d = {\n        type: 'pie',\n        data: data,\n        options: sys.__v0['グラフオプション']\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  'ドーナツグラフ描画': { // @ 円グラフ（ドーナツ）を描画 // @ドーナツぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      data = sys.__exec('二次元グラフデータ変形', ['pie', data, sys])\n      const d = {\n        type: 'doughnut',\n        data: data,\n        options: sys.__v0['グラフオプション']\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  'ポーラーグラフ描画': { // @ 円グラフ（鶏頭グラフ/ポーラーエリアチャート）を描画 // @ぽーらーぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      data = sys.__exec('二次元グラフデータ変形', ['pie', data, sys])\n      const d = {\n        type: 'polarArea',\n        data: data,\n        options: sys.__v0['グラフオプション']\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  'レーダーグラフ描画': { // @ レーダーチャートを描画 // @れーだーぐらふびょうが\n    type: 'func',\n    josi: [['を', 'で', 'の']],\n    pure: false,\n    fn: function (data, sys) {\n      data = sys.__exec('二次元グラフデータ変形', ['bar', data, sys])\n      const d = {\n        type: 'radar',\n        data: data,\n        options: sys.__v0['グラフオプション']\n      }\n      return sys.__exec('グラフ描画', [d, sys])\n    }\n  },\n  '二次元グラフデータ変形': { // @ 二次元配列をXXグラフ描画の形式に整形する。種類TとDATAを指定。 // @にじげんぐらふでーたへんけい\n    type: 'func',\n    josi: [['の'], ['を']],\n    pure: false,\n    fn: function (t, data, sys) {\n      const bgcolorList = [\n        'rgba(255, 99, 132, 0.2)',\n        'rgba(54, 162, 235, 0.2)',\n        'rgba(255, 206, 86, 0.2)',\n        'rgba(75, 192, 192, 0.2)',\n        'rgba(153, 102, 255, 0.2)',\n        'rgba(255, 159, 64, 0.2)'\n      ]\n      const fgcolorList = [\n        'rgba(255, 99, 132, 1)',\n        'rgba(54, 162, 235, 1)',\n        'rgba(255, 206, 86, 1)',\n        'rgba(75, 192, 192, 1)',\n        'rgba(153, 102, 255, 1)',\n        'rgba(255, 159, 64, 1)'\n      ]\n      const res = {}\n      const bgcolors = []\n      const fgcolors = []\n      res.labels = []\n      // 配列かどうか\n      if (data instanceof Array) {\n        // 二次元データのとき\n        if (data[0] instanceof Array) {\n          if (t === 'pie') { // 円グラフの時だけ整形方法が異なる\n            const o = {}\n            o.data = []\n            res.datasets = [o]\n            for (let i = 0; i < data.length; i++) {\n              res.labels.push(data[i][0]) // label\n              o.data.push(data[i][1]) // value\n              bgcolors.push(bgcolorList[i % 6])\n              fgcolors.push(fgcolorList[i % 6])\n            }\n            o.backgroundColor = bgcolors\n            o.borderColor = fgcolors\n            return res\n          }\n          // 左側のラベルの処理\n          // [1,0]が文字列ならラベルあり\n          if (typeof (data[1][0]) === 'string') {\n            for (let i = 1; i < data.length; i++) {\n              res.labels.push(data[i][0]) // 左ラベルを追加\n              data[i] = data[i].slice(1) // 左ラベル除去\n            }\n            data[0] = data[0].slice(1) // ヘッダ行も左ラベルを削除\n          } else {\n            // 左側ラベルない場合 - ダミーのラベルを追加\n            for (let i = 1; i < data.length; i++) {\n              res.labels.push(i)\n            }\n          }\n          res.datasets = []\n          for (let i = 0; i < data[0].length; i++) {\n            const o = {}\n            res.datasets.push(o)\n            o.label = data[0][i]\n            o.backgroundColor = bgcolorList[i % 6]\n            o.borderColor = fgcolorList[i % 6]\n            o.data = []\n            for (let j = 1; j < data.length; j++) {\n              o.data.push(data[j][i])\n            }\n          }\n          return res\n        }\n        // 一次元データのとき\n        // ラベルを作成\n        for (let i = 0; i < data.length; i++) {\n          res.labels.push(i + 1)\n          bgcolors.push(bgcolorList[i % 6])\n          fgcolors.push(fgcolorList[i % 6])\n        }\n        const o1 = {}\n        res.datasets = [o1]\n        o1.label = 'データ'\n        o1.data = data\n        o1.backgroundColor = bgcolors\n        o1.borderColor = fgcolors\n        return res\n      }\n      if (data instanceof Object) { return data }\n      // データが1つだけのとき\n      return sys.__exec('二次元グラフデータ変形', [[data], sys])\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_chart.mjs?")},"./src/plugin_browser_color.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @色定数\n  '水色': { type: 'const', value: 'aqua' }, // @みずいろ\n  '紫色': { type: 'const', value: 'fuchsia' }, // @むらさきいろ\n  '緑色': { type: 'const', value: 'lime' }, // @みどりいろ\n  '青色': { type: 'const', value: 'blue' }, // @あおいろ\n  '赤色': { type: 'const', value: 'red' }, // @あかいろ\n  '黄色': { type: 'const', value: 'yellow' }, // @きいろ\n  '黒色': { type: 'const', value: 'black' }, // @くろいろ\n  '白色': { type: 'const', value: 'white' }, // @しろいろ\n  '茶色': { type: 'const', value: 'maroon' }, // @ちゃいろ\n  '灰色': { type: 'const', value: 'gray' }, // @はいいろ\n  '金色': { type: 'const', value: 'gold' }, // @きんいろ\n  '黄金色': { type: 'const', value: 'gold' }, // @こがねいろ\n  '銀色': { type: 'const', value: 'silver' }, // @ぎんいろ\n  '白金色': { type: 'const', value: 'silver' }, // @しろがねいろ\n  'オリーブ色': { type: 'const', value: 'olive' }, // @おりーぶいろ\n  'ベージュ色': { type: 'const', value: 'beige' }, // @べーじゅいろ\n  'アリスブルー色': { type: 'const', value: 'aliceblue' }, // @ありすぶるーいろ\n  'RGB': { // @赤緑青を256段階でそれぞれ指定して、#RRGGBB形式の値を返す // @RGB\n    type: 'func',\n    josi: [['と'], ['と'], ['で', 'の']],\n    pure: true,\n    fn: function (r, g, b) {\n      const z2 = (v) => {\n        const v2 = '00' + v.toString(16)\n        return v2.substr(v2.length - 2, 2)\n      }\n      return '#' + z2(r) + z2(g) + z2(b)\n    },\n    return_none: false\n  },\n  '色混': { // @配列で[RR,GG,BB]を指定して色を混ぜて#RRGGBB形式の値を返す // @いろまぜる\n    type: 'func',\n    josi: [['の']],\n    pure: true,\n    fn: function (a) {\n      const z2 = (v) => {\n        const v2 = '00' + v.toString(16)\n        return v2.substr(v2.length - 2, 2)\n      }\n      if (!a) { throw new Error('『色混ぜる』の引数には配列を指定します') }\n      if (a.length < 3) { throw new Error('『色混ぜる』の引数には[RR,GG,BB]形式の配列を指定します') }\n      return '#' + z2(a[0]) + z2(a[1]) + z2(a[2])\n    },\n    return_none: false\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_color.mjs?")},"./src/plugin_browser_crypto.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @ハッシュ関数\n  'ハッシュ値計算時': { // @データSをアルゴリズムALG(sha-256/sha-384/sha-512)のエンコーディングでハッシュ値を計算して変数「対象」に代入する。 // @ はっしゅちけいさんしたとき\n    type: 'func',\n    josi: [['へ'], ['を'], ['で']],\n    pure: false,\n    fn: function (func, s, alg, sys) {\n      func = sys.__findVar(func, null) // 文字列指定なら関数に変換\n      // convert\n      const buffer = new TextEncoder('utf-8').encode(s)\n      crypto.subtle.digest(alg, buffer).then(function (hash) {\n        const codes = []\n        const view = new DataView(hash)\n        for (let i = 0; i < view.byteLength; i += 4) {\n          const v = view.getUint32(i)\n          const h = v.toString(16)\n          const pad = '00' + h\n          codes.push(pad.substr(pad.length - 2, 2))\n        }\n        const res = sys.__v0['対象'] = codes.join('')\n        func(res)\n      })\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_crypto.mjs?")},"./src/plugin_browser_dialog.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @ダイアログ\n  '言': { // @メッセージダイアログにSを表示 // @いう\n    type: 'func',\n    josi: [['と', 'を']],\n    pure: true,\n    fn: function (s) {\n      window.alert(s)\n    },\n    return_none: true\n  },\n  '尋': { // @メッセージSと入力ボックスを出して尋ねる // @たずねる\n    type: 'func',\n    josi: [['と', 'を']],\n    pure: true,\n    fn: function (s, sys) {\n      const r = window.prompt(s)\n      if (!r) {\n        return sys.__v0['空']\n      }\n      if (/^[-+]?[0-9]+(\\.[0-9]+)?$/.test(r)) {\n        return parseFloat(r)\n      }\n      if (/^[-+－＋]?[0-9０-９]+([.．][0-9０-９]+)?$/.test(r)) {\n        return parseFloat(r.replace(/[－＋０-９．]/g, c => {\n          return String.fromCharCode(c.charCodeAt(0) - 0xFEE0)\n        }))\n      }\n      return r\n    }\n  },\n  '文字尋': { // @メッセージSと入力ボックスを出して尋ねる。返り値は常に入力されたままの文字列となる // @もじたずねる\n    type: 'func',\n    josi: [['と', 'を']],\n    pure: true,\n    fn: function (s, sys) {\n      const r = window.prompt(s)\n      if (!r) {\n        return sys.__v0['空']\n      }\n      return r\n    }\n  },\n  '二択': { // @メッセージSと[OK]と[キャンセル]のダイアログを出して尋ねる // @にたく\n    type: 'func',\n    josi: [['で', 'の', 'と', 'を']],\n    pure: true,\n    fn: function (s) {\n      return window.confirm(s)\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_dialog.mjs?")},"./src/plugin_browser_dom_basic.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @DOM操作\n  'DOCUMENT': { type: 'const', value: '' }, // @DOCUMENT\n  'WINDOW': { type: 'const', value: '' }, // @WINDOW\n  'NAVIGATOR': { type: 'const', value: '' }, // @NAVIGATOR\n  'DOM要素ID取得': { // @DOMの要素をIDを指定して取得 // @DOMようそIDしゅとく\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (id) {\n      return document.getElementById(id)\n    }\n  },\n  'DOM要素取得': { // @DOMの要素をクエリqで取得して返す // @DOMようそしゅとく\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (q) {\n      return document.querySelector(q)\n    }\n  },\n  'DOM要素全取得': { // @DOMの要素をクエリqで全部取得して返す // @DOMようそぜんしゅとく\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (q) {\n      return Array.from(document.querySelectorAll(q))\n    }\n  },\n  'タグ一覧取得': { // @任意のタグの一覧を取得して返す // @たぐいちらんしゅとく\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (tag) {\n      return document.getElementsByTagName(tag)\n    }\n  },\n  'DOM子要素取得': { // @DOMの要素PAの子要素をクエリqを指定して結果を一つ取得して返す // @DOMこようそしゅとく\n    type: 'func',\n    josi: [['の'], ['を']],\n    pure: true,\n    fn: function (pa, q) {\n      if (typeof pa === 'string') { pa = document.querySelector(pa) }\n      if (!pa.querySelector) {\n        throw new Error('『DOM子要素取得』で親要素がDOMではありません。')\n      }\n      return pa.querySelector(q)\n    }\n  },\n  'DOM子要素全取得': { // @DOMの要素PAの子要素をクエリqを指定して結果を複数取得して返す // @DOMこようそぜんしゅとく\n    type: 'func',\n    josi: [['の'], ['を']],\n    pure: true,\n    fn: function (pa, q) {\n      if (typeof pa === 'string') { pa = document.querySelector(pa) }\n      if (!pa.querySelectorAll) {\n        throw new Error('『DOM子要素取得』で親要素がDOMではありません。')\n      }\n      return pa.querySelectorAll(q)\n    }\n  },\n  'DOMイベント設定': { // @DOMのEVENTになでしこ関数名funcStrのイベントを設定 // @DOMいべんとせってい\n    type: 'func',\n    josi: [['の'], ['に', 'へ'], ['を']],\n    pure: false,\n    fn: function (dom, event, funcStr, sys) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n\n      dom[event] = sys.__findVar(funcStr, null)\n    },\n    return_none: true\n  },\n  'DOMテキスト設定': { // @DOMにテキストを設定 // @DOMてきすとせってい\n    type: 'func',\n    josi: [['に', 'の', 'へ'], ['を']],\n    pure: true,\n    fn: function (dom, text) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n\n      const tag = dom.tagName.toUpperCase()\n      if (tag === 'INPUT' || tag === 'TEXTAREA') { dom.value = text } else if (tag === 'SELECT') {\n        for (let i = 0; i < dom.options.length; i++) {\n          const v = dom.options[i].value\n          if (String(v) === text) {\n            dom.selectedIndex = i\n            break\n          }\n        }\n      } else { dom.innerHTML = text }\n    },\n    return_none: true\n  },\n  'DOMテキスト取得': { // @DOMのテキストを取得 // @DOMてきすとしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (dom) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      if (!dom.tagName) {\n        console.log('[DOMテキスト取得]でタグ名が取得できません。', dom)\n        return ''\n      }\n      const tag = dom.tagName.toUpperCase()\n      // input or textarea\n      if (tag === 'INPUT' || tag === 'TEXTAREA') { return dom.value }\n      // select\n      if (tag === 'SELECT') {\n        const idx = dom.selectedIndex\n        if (idx < 0) { return null }\n        return dom.options[idx].value\n      }\n      return dom.innerHTML\n    }\n  },\n  'DOM_HTML設定': { // @DOMにHTML文字列を設定 // @DOM_HTMLせってい\n    type: 'func',\n    josi: [['に', 'の', 'へ'], ['を']],\n    pure: true,\n    fn: function (dom, text) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n\n      dom.innerHTML = text\n    },\n    return_none: true\n  },\n  'DOM_HTML取得': { // @DOMのHTML文字列を取得 // @DOM_HTMLしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (dom) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n\n      return dom.innerHTML\n    }\n  },\n  'テキスト設定': { // @DOMのテキストにVを設定 // @てきすとせってい\n    type: 'func',\n    josi: [['に', 'の', 'へ'], ['を']],\n    pure: false,\n    fn: function (dom, v, sys) {\n      return sys.__exec('DOMテキスト設定', [dom, v, sys])\n    }\n  },\n  'テキスト取得': { // @DOMのテキストを取得 // @てきすとしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: false,\n    fn: function (dom, sys) {\n      return sys.__exec('DOMテキスト取得', [dom, sys])\n    }\n  },\n  'HTML設定': { // @DOMのHTMLにVを設定 // @HTMLせってい\n    type: 'func',\n    josi: [['に', 'の', 'へ'], ['を']],\n    pure: false,\n    fn: function (dom, v, sys) {\n      return sys.__exec('DOM_HTML設定', [dom, v, sys])\n    }\n  },\n  'HTML取得': { // @DOMのテキストを取得 // @HTMLしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: false,\n    fn: function (dom, sys) {\n      return sys.__exec('DOM_HTML取得', [dom, sys])\n    }\n  },\n  'DOM属性設定': { // @DOMの属性Sに値Vを設定 // @DOMぞくせいせってい\n    type: 'func',\n    josi: [['の'], ['に', 'へ'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, s, v, sys) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      const wa = sys.__v0['DOM和スタイル']\n      if (wa[s]) { s = wa[s] }\n      dom[s] = v\n    },\n    return_none: true\n  },\n  'DOM属性取得': { // @DOMの属性Sを取得 // @DOMぞくせいしゅとく\n    type: 'func',\n    josi: [['の', 'から'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, s, sys) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      const wa = sys.__v0['DOM和スタイル']\n      if (wa[s]) { s = wa[s] }\n      return dom[s]\n    }\n  },\n  'DOM和スタイル': { // const // @DOMわすたいる\n    type: 'const',\n    value: {\n      '幅': 'width',\n      '高さ': 'height',\n      '高': 'height',\n      '背景色': 'background-color',\n      '色': 'color',\n      'マージン': 'margin',\n      '余白': 'padding',\n      '文字サイズ': 'font-size',\n      '行揃え': 'text-align',\n      '左': 'left',\n      '右': 'right',\n      '中央': 'center',\n      'ボーダー': 'border',\n      'ボックス表示': 'display',\n      'なし': 'none',\n      'ブロック': 'block',\n      '表示位置': 'float',\n      '重なり': 'z-index'\n    }\n  },\n  'DOMスタイル設定': { // @DOMのスタイルAに値Bを設定 // @DOMすたいるせってい\n    type: 'func',\n    josi: [['の'], ['に', 'へ'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, s, v, sys) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      const wa = sys.__v0['DOM和スタイル']\n      if (wa[s] !== undefined) { s = wa[s] }\n      if (wa[v] !== undefined) { v = wa[v] }\n      dom.style[s] = v\n    },\n    return_none: true\n  },\n  'DOMスタイル一括設定': { // @DOMに(オブジェクト型で)スタイル情報を一括設定 // @DOMすたいるいっかつせってい\n    type: 'func',\n    josi: [['に', 'へ'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, values, sys) {\n      if (typeof dom === 'string') { dom = document.querySelectorAll(dom) }\n      if (!dom) { return }\n      if (dom instanceof window.HTMLElement) { dom = [dom] }\n      const wa = sys.__v0['DOM和スタイル']\n      // 列挙したDOM一覧を全てスタイル変更する\n      for (let i = 0; i < dom.length; i++) {\n        const e = dom[i]\n        for (const key in values) {\n          let s = key\n          let v = values[key]\n          if (wa[s] !== undefined) { s = wa[s] }\n          if (wa[v] !== undefined) { v = wa[v] }\n          e.style[s] = v\n        }\n      }\n    },\n    return_none: true\n  },\n  'DOMスタイル取得': { // @DOMのSTYLEの値を取得 // @DOMすたいるしゅとく\n    type: 'func',\n    josi: [['の'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, style, sys) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      if (!dom) { return '' }\n      const wa = sys.__v0['DOM和スタイル']\n      if (wa[style]) { style = wa[style] }\n      return dom.style[style]\n    }\n  },\n  'DOMスタイル一括取得': { // @DOMのSTYLE(配列で複数指定)の値を取得 // @DOMすたいるいっかつしゅとく\n    type: 'func',\n    josi: [['の'], ['を']],\n    uses: ['DOM和スタイル'],\n    pure: true,\n    fn: function (dom, style, sys) {\n      const res = {}\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n\n      if (!dom) { return res }\n      if (style instanceof String) { style = [style] }\n\n      const wa = sys.__v0['DOM和スタイル']\n      if (style instanceof Array) {\n        style.forEach((key) => {\n          if (wa[key]) { key = wa[key] }\n          res[key] = dom.style[key]\n        })\n        return res\n      }\n      if (style instanceof Object) {\n        for (let key in style) {\n          if (wa[key]) { key = wa[key] }\n          res[key] = dom.style[key]\n        }\n        return res\n      }\n      return dom.style[style]\n    }\n  },\n  'DOM要素作成': { // @DOMにTAGの新規要素を作成 // @DOMようそさくせい\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: true,\n    fn: function (tag) {\n      return document.createElement(tag)\n    }\n  },\n  'DOM子要素追加': { // @DOMの要素PAの子へ要素ELを追加してPAを返す // @DOMこようそついか\n    type: 'func',\n    josi: [['に', 'へ'], ['を']],\n    pure: true,\n    fn: function (pa, el) {\n      if (typeof el === 'string') { el = document.querySelector(el) }\n      if (typeof pa === 'string') { pa = document.querySelector(pa) }\n      pa.appendChild(el)\n    }\n  },\n  'DOM子要素削除': { // @DOMの要素PAの子から要素ELを削除してPAを返す // @DOMこようそさくじょ\n    type: 'func',\n    josi: [['から'], ['を']],\n    pure: true,\n    fn: function (pa, el) {\n      if (typeof el === 'string') { el = document.querySelector(el) }\n      if (typeof pa === 'string') { pa = document.querySelector(pa) }\n      pa.removeChild(el)\n    }\n  },\n  '注目': { // @DOMの要素Aにフォーカスする(カーソルを移動する) // @ちゅうもく\n    type: 'func',\n    josi: [['を', 'へ', 'に']],\n    pure: true,\n    fn: function (el) {\n      if (typeof el === 'string') { el = document.querySelector(el) }\n      if (el.focus) { el.focus() }\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_dom_basic.mjs?")},"./src/plugin_browser_dom_event.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @DOM操作とイベント\n  '対象イベント': { type: 'const', value: '' }, // @たいしょういべんと\n  'DOMイベント追加': { // @DOMのEVENTになでしこ関数名funcStrのイベントを追加// @DOMいべんとついか\n    type: 'func',\n    josi: [['の'], ['に', 'へ'], ['を']],\n    pure: false,\n    fn: function (dom, event, funcStr, sys) {\n      sys.__addEvent(dom, event, funcStr, null)\n    },\n    return_none: true\n  },\n  'DOMイベント削除': { // @DOMのEVENTからなでしこ関数名funcStrのイベントを削除// @DOMいべんとさくじょ\n    type: 'func',\n    josi: [['の'], ['から'], ['を']],\n    pure: false,\n    fn: function (dom, event, funcStr, sys) {\n      sys.__removeEvent(dom, event, funcStr)\n    },\n    return_none: true\n  },\n  'DOMイベント発火時': { // @DOMのEVENTが発火した時にCALLBACKを実行するように設定 // @DOMいべんとはっかしたとき\n    type: 'func',\n    josi: [['で'], ['の'], ['が']],\n    pure: true,\n    fn: function (callback, dom, event, sys) {\n      sys.__addEvent(dom, event, callback, null)\n    },\n    return_none: true\n  },\n  'DOMイベント処理停止': { // @キーイベントやマウスイベントで、元々ブラウザが行う処理を中止する // @DOMいべんとしょりていし\n    type: 'func',\n    josi: [['を', 'の']],\n    pure: true,\n    fn: function (event, sys) {\n      event.preventDefault()\n    },\n    return_none: true\n  },\n  'クリック時': { // @無名関数FでDOMをクリックした時に実行するイベントを設定 // @くりっくしたとき\n    type: 'func',\n    josi: [['で'], ['を']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'click', func, null)\n    },\n    return_none: true\n  },\n  '読込時': { // @無名関数FでDOMを読み込んだ時に実行するイベントを設定 // @よみこんだとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'load', func, null)\n    },\n    return_none: true\n  },\n  'フォーム送信時': { // @無名関数Fでフォームを送信した時に実行するイベントを設定 // @ふぉーむそうしんしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'submit', func, null)\n    },\n    return_none: true\n  },\n  '押キー': { type: 'const', value: '' }, // @おされたきー\n  'キー押時': { // @無名関数FでDOMに対してキーを押した時に実行するイベントを設定。『押されたキー』が設定される。 // @きーおしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'keydown', func, sys.__keyHandler)\n    },\n    return_none: true\n  },\n  'キー離時': { // @無名関数FでDOMに対してキーを離した時に実行するイベントを設定。『押されたキー』が設定される。 // @きーはなしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'keyup', func, sys.__keyHandler)\n    },\n    return_none: true\n  },\n  'キータイピング時': { // @無名関数FでDOMに対してキーをプレスした時に実行するイベントを設定。『押されたキー』が設定される。 // @きーたいぴんぐしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'keypress', func, sys.__keyHandler)\n    },\n    return_none: true\n  },\n  'マウスX': { type: 'const', value: 0 }, // @まうすX\n  'マウスY': { type: 'const', value: 0 }, // @まうすY\n  'マウス押時': { // @無名関数FでDOMに対してマウスボタンを押した時に実行するイベントを設定。『マウスX』『マウスY』に座標が設定される。『対象』にイベントDOM。『対象イベント』にイベント引数。 // @まうすおしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'mousedown', func, sys.__mouseHandler)\n    },\n    return_none: true\n  },\n  'マウス移動時': { // @無名関数FでDOMに対してマウスカーソルが移動した時に実行するイベントを設定。『マウスX』『マウスY』に座標が設定される。『対象』にイベントDOM。『対象イベント』にイベント引数。 // @まうすいどうしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'mousemove', func, sys.__mouseHandler)\n    },\n    return_none: true\n  },\n  'マウス離時': { // @無名関数FでDOMに対してマウスボタンを離した時に実行するイベントを設定。『マウスX』『マウスY』に座標が設定される。『対象』にイベントDOM。『対象イベント』にイベント引数。 // @まうすはなしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'mouseup', func, sys.__mouseHandler)\n    },\n    return_none: true\n  },\n  'タッチX': { type: 'const', value: 0 }, // @たっちX\n  'タッチY': { type: 'const', value: 0 }, // @たっちY\n  'タッチ配列': { type: 'const', value: [] }, // @たっちはいれつ\n  'タッチイベント計算': { // @タッチイベントで座標計算を行う。『タッチX』『タッチY』『タッチ配列』『対象』『対象イベント』が設定される。『タッチ配列』の内容が返る // @たっちいべんとけいさん\n    type: 'func',\n    josi: [['の']],\n    pure: true,\n    fn: function (e, sys) {\n      return sys.__touchHandler(e, sys)\n    }\n  },\n  'タッチ開始時': { // @無名関数FでDOMに対してタッチを開始した時に実行するイベントを設定。// @たっちかいししたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'touchstart', func, sys.__touchHandler)\n    },\n    return_none: true\n  },\n  'タッチ時': { // @無名関数FでDOMに対してタッチして指を動かした時に実行するイベントを設定。// @たっちしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'touchmove', func, sys.__touchHandler)\n    },\n    return_none: true\n  },\n  'タッチ終了時': { // @無名関数FでDOMに対してタッチして指を離した時のイベントを設定。// @たっちしゅうりょうしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'touchend', func, sys.__touchHandler)\n    },\n    return_none: true\n  },\n  'タッチキャンセル時': { // @無名関数FでDOMに対してタッチイベントをキャンセルした時の動作を設定。// @たっちきゃんせるしたとき\n    type: 'func',\n    josi: [['で'], ['を', 'の']],\n    pure: false,\n    fn: function (func, dom, sys) {\n      sys.__addEvent(dom, 'touchcancel', func, sys.__touchHandler)\n    },\n    return_none: true\n  },\n  '画面更新時実行': { // @画面描画タイミングで関数F(文字列指定も可)を実行する。識別IDを返す。// @がめんこうしんじじっこう\n    type: 'func',\n    josi: [['を']],\n    pure: false,\n    fn: function (func, sys) {\n      func = sys.__findVar(func, null) // 文字列指定なら関数に変換\n      if (!func) { throw new Error('『画面更新時実行』で関数の取得に失敗しました。') }\n      sys.__requestAnimationFrameLastId = window.requestAnimationFrame(func)\n      return sys.__requestAnimationFrameLastId\n    }\n  },\n  '画面更新処理取消': { // @識別IDを指定して『画面更新時実行』を取り消す// @がめんこうしんしょりとりけし\n    type: 'func',\n    josi: [['の', 'を']],\n    pure: false,\n    fn: function (id, sys) {\n      window.cancelAnimationFrame(id)\n      if (sys.__requestAnimationFrameLastId === id) { sys.__requestAnimationFrameLastId = 0 }\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_dom_event.mjs?")},"./src/plugin_browser_dom_parts.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @DOM部品操作\n  'DOM親要素': { type: 'const', value: '' }, // @DOMおやようそ\n  'DOM部品個数': { type: 'const', value: 0 }, // @DOMせいせいこすう\n  'DOM部品オプション': { type: 'const', value: { '自動改行': false, 'テーブル背景色': ['#AA4040', '#ffffff', '#fff0f0'] } }, // @DOMぶひんおぷしょん\n  'DOM親要素設定': { // @「ボタン作成」「エディタ作成」など『DOM部品作成』で追加する要素の親要素を指定(デフォルトはdocument)して要素を返す。 // @DOMおやようそせってい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: false,\n    fn: function (el, sys) {\n      if (typeof el === 'string') { el = document.querySelector(el) || document.getElementById(el) }\n      sys.__v0['DOM親要素'] = el\n      return el\n    }\n  },\n  'DOM親部品設定': { // @ DOM部品作成でDOM要素を追加する親の対象を指定。『DOM親要素設定』と同じ。// @DOMおやぶひんせってい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: false,\n    fn: function (el, sys) {\n      return sys.__exec('DOM親要素設定', [el, sys])\n    }\n  },\n  'DOMスキン': { type: 'const', value: '' }, // @DOMすきん\n  'DOMスキン辞書': { type: 'const', value: {} }, // @DOMすきんじしょ\n  'DOMスキン設定': { // @「ボタン作成」「エディタ作成」などで適用するスキンを指定する(#1033) // @DOMすきんせってい\n    type: 'func',\n    josi: [['を', 'に', 'の']],\n    pure: false,\n    fn: function (skin, sys) {\n      sys.__v0['DOMスキン'] = skin\n    },\n    return_none: true\n  },\n  'DOM部品作成': { // @elmの要素を作成して『DOM親要素設定』で指定した要素に追加して、DOMオブジェクトを返す。(elmがDOM要素なら追加する) // @DOMぶひんさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (elm, sys) {\n      const parent = sys.__v0['DOM親要素']\n      const btn = (typeof (elm) === 'string') ? document.createElement(elm) : elm\n      btn.id = 'nadesi-dom-' + sys.__v0['DOM部品個数']\n      // スキン適用\n      const func = sys.__v0['DOMスキン辞書'][sys.__v0['DOMスキン']]\n      if (typeof (func) === 'function') { func(elm, btn, sys) }\n      // DOM追加\n      parent.appendChild(btn)\n      sys.__v0['DOM部品個数']++\n      // オプションを適用\n      const opt = sys.__v0['DOM部品オプション']\n      if (opt['自動改行']) {\n        parent.appendChild(document.createElement('br'))\n      }\n      return btn\n    }\n  },\n  'ボタン作成': { // @ラベルlabelを持つbutton要素を追加しDOMオブジェクトを返す // @ぼたんさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (label, sys) {\n      const btn = sys.__exec('DOM部品作成', ['button', sys])\n      btn.innerHTML = label\n      return btn\n    }\n  },\n  'エディタ作成': { // @textの値を持つテキストボックス(input[type='text'])の要素を追加しDOMオブジェクトを返す // @えでぃたさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (text, sys) {\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'text'\n      inp.value = text\n      return inp\n    }\n  },\n  'テキストエリア作成': { // @textの値を持つtextarea要素を追加しDOMオブジェクトを返す // @てきすとえりあさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (text, sys) {\n      const te = sys.__exec('DOM部品作成', ['textarea', sys])\n      te.value = text\n      return te\n    }\n  },\n  'ラベル作成': { // @textの値を持つラベル(span要素)を追加しDOMオブジェクトを返す // @らべるさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (text, sys) {\n      const lbl = sys.__exec('DOM部品作成', ['span', sys])\n      lbl.innerHTML = text\n      return lbl\n    }\n  },\n  'キャンバス作成': { // @大きさ[幅, 高]のcanvas要素を追加しDOMオブジェクトを返す // @きゃんばすさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (size, sys) {\n      const cv = sys.__exec('DOM部品作成', ['canvas', sys])\n      cv.width = size[0]\n      cv.height = size[1]\n      cv.style.width = size[0]\n      cv.style.height = size[1]\n      // 描画中キャンバスを移動する\n      sys.__exec('描画開始', [cv, sys])\n      return cv\n    }\n  },\n  '画像作成': { // @URLを指定してimg要素を追加しDOMオブジェクトを返す // @がぞうさくせい\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: false,\n    fn: function (url, sys) {\n      const img = sys.__exec('DOM部品作成', ['img', sys])\n      img.src = url\n      return img\n    }\n  },\n  '改行作成': { // @改行(br要素)を追加しDOMオブジェクトを返す // @かいぎょうさくせい\n    type: 'func',\n    josi: [],\n    pure: false,\n    fn: function (sys) {\n      const br = sys.__exec('DOM部品作成', ['br', sys])\n      return br\n    }\n  },\n  'チェックボックス作成': { // @textのラベルを持つチェックボックス(input[type='checkbox'])要素を追加しDOMオブジェクトを返す // @ちぇっくぼっくすさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (text, sys) {\n      // チェックボックスは、<span><input><label></span>で成り立つように構築\n      const span = document.createElement('span')\n      const inp = document.createElement('input')\n      inp.type = 'checkbox'\n      inp.id = 'nadesi-dom-' + sys.__v0['DOM部品個数']\n      sys.__v0['DOM部品個数']++\n      const label = document.createElement('label')\n      label.innerHTML = text\n      label.htmlFor = inp.id\n      span.appendChild(inp)\n      span.appendChild(label)\n      // 親部品に追加\n      sys.__exec('DOM部品作成', [span, sys])\n      return inp\n    }\n  },\n  'セレクトボックス作成': { // @配列optionsの選択肢を持つselect要素を追加しDOMオブジェクトを返す // @せれくとぼっくすさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (options, sys) {\n      const dom = document.createElement('select')\n      for (let i = 0; i < options.length; i++) {\n        const item = document.createElement('option')\n        item.value = options[i]\n        item.appendChild(document.createTextNode(options[i]))\n        dom.appendChild(item)\n      }\n      // 親部品に追加\n      const obj = sys.__exec('DOM部品作成', [dom, sys])\n      return dom\n    }\n  },\n  'セレクトボックスアイテム設定': { // @配列データをセレクトボックスdomのアイテムに差し替える // @せれくとぼっくすあいてむさくせい\n    type: 'func',\n    josi: [['を'], ['へ', 'に']],\n    pure: false,\n    fn: function (options, dom, sys) {\n      if (typeof dom === 'string') { dom = document.querySelector(dom) }\n      // 既存のoptionsをクリア\n      dom.options.length = 0\n      // アイテムを追加\n      for (let i = 0; i < options.length; i++) {\n        const item = document.createElement('option')\n        item.value = options[i]\n        item.appendChild(document.createTextNode(options[i]))\n        dom.appendChild(item)\n      }\n    },\n    return_none: true\n  },\n  '色選択ボックス作成': { // @色選択ボックス(input[type='color'])を作成しDOMオブジェクトを返す // @いろせんたくぼっくすさくせい\n    type: 'func',\n    josi: [],\n    pure: false,\n    fn: function (sys) {\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'color'\n      return inp\n    }\n  },\n  '日付選択ボックス作成': { // @日付選択ボックス(input[type='date'])を作成しDOMオブジェクトを返す // @ひづけせんたくぼっくすさくせい\n    type: 'func',\n    josi: [],\n    pure: false,\n    fn: function (sys) {\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'date'\n      return inp\n    }\n  },\n  'パスワード入力エディタ作成': { // @パスワード入力エディタ(input[type='password'])を作成し初期値Sを設定し、DOMオブジェクトを返す // @ぱすわーどにゅうりょくさくせい\n    type: 'func',\n    josi: [['の', 'で']],\n    pure: false,\n    fn: function (s, sys) {\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'password'\n      inp.value = s\n      return inp\n    }\n  },\n  '値指定バー作成': { // @範囲RANGE(配列で[最小,最大[,値]])を指定するバー(input[type='range'])を作成しDOMオブジェクトを返す // @ぱすわーどにゅうりょくさくせい\n    type: 'func',\n    josi: [['の', 'で']],\n    pure: false,\n    fn: function (range, sys) {\n      if (!(range instanceof Array) || range.length < 2) {\n        range = [0, 100, 50]\n      }\n      if (range.length <= 2) { // 3つ目を省略したとき\n        range.push(Math.floor((range[1] - range[0]) / 2))\n      }\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'range'\n      inp.min = range[0]\n      inp.max = range[1]\n      inp.value = range[2]\n      return inp\n    }\n  },\n  '送信ボタン作成': { // @ラベルSの送信ボタン(input[type='submit'])を作成しDOMオブジェクトを返す // @そうしんぼたんさくせい\n    type: 'func',\n    josi: [['の']],\n    pure: false,\n    fn: function (label, sys) {\n      const inp = sys.__exec('DOM部品作成', ['input', sys])\n      inp.type = 'submit'\n      inp.value = label\n      return inp\n    }\n  },\n  'フォーム作成': { // @属性OBJ{method:\"GET\",action:\"...\"}で項目一覧S「a=初期値{改行}b=初期値{改行}色=?c#fff0f0{改行}=?送信」を送信フォームを作成しDOMオブジェクトを返す // @ふぉーむさくせい\n    type: 'func',\n    josi: [['で', 'の'], ['を']],\n    pure: false,\n    fn: function (obj, s, sys) {\n      const frm = sys.__exec('DOM部品作成', ['form', sys])\n      // 可能ならformにobjの値を移し替える\n      if (obj instanceof Object) {\n        for (const key in obj) {\n          if (frm[key]) { frm[key] = obj[key] }\n        }\n      }\n      // 入力項目をtableで作る\n      const rows = s.split('\\n')\n      const table = document.createElement('table')\n      for (const rowIndex in rows) {\n        let row = '' + (rows[rowIndex])\n        if (row === '') { continue }\n        if (row.indexOf('=') < 0) { row += '=' }\n        const cols = row.split('=')\n        const key = cols[0]\n        const val = cols[1]\n        // key\n        const th = document.createElement('th')\n        th.innerHTML = sys.__tohtmlQ(key)\n        // val\n        const td = document.createElement('td')\n        if (val.substring(0, 2) === '?(') {\n          // select box\n          const it = val.substring(2) + ')'\n          const ita = it.split(')')\n          const its = ita[0]\n          const def = ita[1]\n          const items = its.split('|')\n          const select = document.createElement('select')\n          select.name = key\n          for (const it of items) {\n            const option = document.createElement('option')\n            option.value = it\n            option.text = it\n            select.appendChild(option)\n          }\n          const idx = items.indexOf(def)\n          if (idx >= 0) { select.selectedIndex = idx }\n          td.appendChild(select)\n        } else {\n          // input element\n          const inp = document.createElement('input')\n          td.appendChild(inp)\n          inp.id = 'nako3form_' + key\n          if (val === '?送信' || val === '?submit') {\n            inp.type = 'submit'\n            inp.value = val.substring(1)\n            if (key !== '') { inp.name = key }\n          } else if (val.substring(0, 2) === '?c') {\n            inp.type = 'color'\n            inp.value = val.substring(2)\n            inp.name = key\n          } else {\n            inp.type = 'text'\n            inp.value = val\n            inp.name = key\n          }\n        }\n        const tr = document.createElement('tr')\n        tr.appendChild(th)\n        tr.appendChild(td)\n        table.appendChild(tr)\n      }\n      frm.appendChild(table)\n      return frm\n    }\n  },\n  'フォーム入力一括取得': { // @DOMのフォームを取得し、そのフォーム以下にある入力項目のnameとvalueを辞書形式で返す // @ふぉーむにゅうりょくいっかつしゅとく\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: true,\n    fn: function (dom) {\n      if (typeof (dom) === 'string') { dom = document.querySelector(dom) }\n      const res = {}\n      const getChildren = (pa) => {\n        if (!pa || !pa.childNodes) { return }\n        for (let i = 0; i < pa.childNodes.length; i++) {\n          const el = pa.childNodes[i]\n          if (!el.tagName) { return }\n          const tag = el.tagName.toLowerCase()\n          if (tag === 'input') {\n            if (el.type === 'checkbox') {\n              res[el.name] = el.checked ? el.value : ''\n              continue\n            }\n            res[el.name] = el.value\n            continue\n          } else if (tag === 'textarea') {\n            res[el.name] = el.value\n          } else if (tag === 'select') {\n            if (el.selectedIndex >= 0) {\n              res[el.name] = el.options[el.selectedIndex].value\n            } else {\n              res[el.name] = ''\n            }\n          }\n          getChildren(el)\n        }\n      }\n      getChildren(dom)\n      return res\n    }\n  },\n  'テーブル作成': { // @二次元配列AA(あるいは文字列の簡易CSVデータ)からTABLE要素を作成し、DOMオブジェクトを返す // @てーぶるさくせい\n    type: 'func',\n    josi: [['の', 'から']],\n    pure: false,\n    fn: function (aa, sys) {\n      if (typeof (aa) === 'string') {\n        const rr = []\n        const rows = aa.split('\\n')\n        for (const row of rows) { rr.push(row.split(',')) }\n        aa = rr\n      }\n      const bgColor = JSON.parse(JSON.stringify(sys.__v0['DOM部品オプション']['テーブル背景色']))\n      for (let i = 0; i < 3; i++) { bgColor.push('') }\n      const bgHead = bgColor.shift()\n      const table = sys.__exec('DOM部品作成', ['table', sys])\n      for (const rowNo in aa) {\n        const row = aa[rowNo]\n        const tr = document.createElement('tr')\n        for (let col of row) {\n          col = '' + col\n          const td = document.createElement((rowNo === 0) ? 'th' : 'td')\n          td.innerHTML = sys.__tohtml(col)\n          // 色指定\n          if (bgHead !== '') {\n            td.style.backgroundColor = (rowNo === 0) ? bgHead : bgColor[rowNo % 2]\n            td.style.color = (rowNo === 0) ? 'white' : 'black'\n          }\n          if (col.match(/^(\\+|-)?\\d+(\\.\\d+)?$/)) { // number?\n            td.style.textAlign = 'right'\n          }\n          tr.appendChild(td)\n        }\n        table.appendChild(tr)\n      }\n      return table\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_dom_parts.mjs?")},"./src/plugin_browser_geolocation.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @位置情報\n  '位置情報取得時': { // @位置情報を取得してコールバック関数内で変数「対象」に配列で[緯度,経度]を返す // @いちじょうほうしゅとくしたとき\n    type: 'func',\n    josi: [['の', 'に', 'へ']],\n    pure: false,\n    fn: function (func, sys) {\n      let cb = func\n      if (typeof cb === 'string') { cb = sys.__findVar(cb) }\n      if (!('geolocation' in navigator)) { throw new Error('関数『位置情報取得時』は使えません。') }\n\n      navigator.geolocation.getCurrentPosition((position) => {\n        sys.__v0['対象'] = [\n          position.coords.latitude,\n          position.coords.longitude\n        ]\n        cb(position)\n      })\n    },\n    return_none: true\n  },\n  '位置情報監視時': { // @位置情報を監視してIDを返す。引数に指定したコールバック関数内で変数「対象」に配列で[緯度,経度]を返す // @いちじょうほうかんししたとき\n    type: 'func',\n    josi: [['の', 'に', 'へ']],\n    pure: false,\n    fn: function (func, sys) {\n      let cb = func\n      if (typeof cb === 'string') { cb = sys.__findVar(cb) }\n      if (!('geolocation' in navigator)) { throw new Error('関数『位置情報監視時』は使えません。') }\n\n      return navigator.geolocation.watchPosition((position) => {\n        sys.__v0['対象'] = [\n          position.coords.latitude,\n          position.coords.longitude\n        ]\n        cb(position)\n      })\n    },\n    return_none: false\n  },\n  '位置情報監視停止': { // @『位置情報監視時』で開始した監視を停止する // @いちじょうほうかんしていし\n    type: 'func',\n    josi: [['の']],\n    pure: true,\n    fn: function (wid, sys) {\n      navigator.geolocation.clearWatch(wid)\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_geolocation.mjs?")},"./src/plugin_browser_hotkey.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var hotkeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hotkeys-js */ \"./node_modules/hotkeys-js/index.js\");\n// @ts-nocheck\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @ホットキー\n  'ホットキー登録': { // @ホットキーKEYにEVENTを登録する // @ほっときーとうろく\n    type: 'func',\n    josi: [['に', 'で'], ['を']],\n    pure: true,\n    fn: function (key, fname, sys) {\n      hotkeys_js__WEBPACK_IMPORTED_MODULE_0__(key, function (event, handler) {\n        event.preventDefault()\n        sys.__v1[fname]()\n      })\n    }\n  },\n  'ホットキー解除': { // @ホットキーKEYを解除する // @ほっときーかいじょ\n    type: 'func',\n    josi: [['を', 'の']],\n    pure: true,\n    fn: function (key) {\n      hotkeys_js__WEBPACK_IMPORTED_MODULE_0__.unbind(key)\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_hotkey.mjs?")},"./src/plugin_browser_html.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @HTML操作\n  'HTML変換': { // @文字列をHTMLに変換して返す // @HTMLへんかん\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (text) {\n      return String(text)\n        .replace(/&/g, '&amp;')\n        .replace(/>/g, '&gt;')\n        .replace(/</g, '&lt;')\n    }\n  },\n  // @クリップボード\n  'クリップボード設定': { // @文字列をクリップボードにコピー // @くりっぷぼーどせってい\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (text) {\n      // Clipboard APIをサポートしているか\n      if (navigator.clipboard) {\n        navigator.clipboard.writeText(text)\n      } else {\n        const tmp = document.createElement('div')\n        const pre = document.createElement('pre')\n        pre.style.webkitUserSelect = 'auto'\n        pre.style.userSelect = 'auto'\n        tmp.appendChild(pre).textContent = text\n        // 画面外へ表示する\n        tmp.style.position = 'fixed'\n        tmp.right = '200%'\n        document.body.appendChild(tmp)\n        document.getSelection().selectAllChildren(tmp)\n        document.execCommand('copy')\n        document.body.removeChild(tmp)\n      }\n    },\n    return_none: true\n  },\n  'クリップボード取得時': { // @クリップボードの値を取得した後関数Fを実行する。結果は変数『対象』に代入される(ユーザーの許可が必要)。 // @くりっぷぼーどしゅとくしたとき\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (f, sys) {\n      // Clipboard APIをサポートしているか\n      if (navigator.clipboard) {\n        if (typeof (f) === 'string') { f = sys.__findFunc(f, 'クリップボード取得時') }\n        const pm = navigator.clipboard.readText()\n        pm.then(text => {\n          sys.__v0['対象'] = text\n          f(sys)\n        })\n      } else {\n        throw new Error('Clipbard APIが利用できません。')\n      }\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_html.mjs?")},"./src/plugin_browser_location.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @ブラウザ操作\n  'ブラウザ移動': { // @任意のURLにブラウザ移動(ただし移動後スクリプトの実行は停止する) // @ぶらうざいどう\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (url, sys) {\n      window.location.href = url\n    }\n  },\n  'ブラウザ戻': { // @任意のURLにブラウザ移動(ただし移動後スクリプトの実行は停止する) // @ぶらうざもどる\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function () {\n      window.history.back(-1)\n    }\n  },\n  'ブラウザURL': { type: 'const', value: '' } // @NぶらうざURL\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_location.mjs?")},"./src/plugin_browser_speech.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @音声合成\n  '話': { // @音声合成APIを使って、Sを発話する // @はなす\n    type: 'func',\n    josi: [['と', 'を', 'の']],\n    pure: false,\n    fn: function (s, sys) {\n      // 話者の特定\n      let voice = sys.__v0['話:話者']\n      if (!voice) { voice = sys.__exec('話者設定', ['ja', sys]) }\n      // インスタンス作成\n      const msg = new SpeechSynthesisUtterance(s)\n      msg.voice = voice\n      if (voice) { msg.lang = voice.lang } // 必ず話者の特定に成功している訳ではない\n      msg.rate = sys.__v0['話者速度']\n      msg.pitch = sys.__v0['話者声高']\n      msg.volume = sys.__v0['話者音量']\n      window.speechSynthesis.speak(msg)\n      console.log('#話す:', s)\n      return s\n    }\n  },\n  '話終時': { // @音声合成APIを使って、Sを発話し発話した後でcallbackを実行 // @はなしおわったとき\n    type: 'func',\n    josi: [['で'], ['と', 'を', 'の']],\n    pure: false,\n    fn: function (callback, s, sys) {\n      // 話者の特定\n      let voice = sys.__v0['話:話者']\n      if (!voice) { voice = sys.__exec('話者設定', ['ja', sys]) }\n      // インスタンス作成\n      const msg = new SpeechSynthesisUtterance(s)\n      msg.voice = voice\n      if (voice) { msg.lang = voice.lang } // 必ず話者の特定に成功している訳ではない\n      msg.rate = sys.__v0['話者速度']\n      msg.pitch = sys.__v0['話者声高']\n      msg.volume = sys.__v0['話者音量']\n      msg.onend = (e) => {\n        console.log('#話終時')\n        sys.__v0['対象イベント'] = e\n        callback(sys)\n      }\n      window.speechSynthesis.speak(msg)\n      console.log('#話す:', s)\n      return s\n    }\n  },\n  '話者一覧取得': { // @音声合成APIの話者一覧を得る // @わしゃいちらんしゅとく\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function (sys) {\n      // 対応している？\n      if (!('SpeechSynthesisUtterance' in window)) { throw new Error('音声合成APIに対応していません') }\n\n      return window.speechSynthesis.getVoices()\n    }\n  },\n  '話者設定': { // @音声合成APIの話者を指定する // @わしゃせってい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (v, sys) {\n      // 対応している？\n      if (!('SpeechSynthesisUtterance' in window)) { throw new Error('音声合成APIに対応していません') }\n\n      // 文字列で値を指定\n      if (typeof v === 'string') {\n        // 話者を特定する\n        const voices = window.speechSynthesis.getVoices()\n        for (const i of voices) {\n          if (i.lang.indexOf(v) >= 0 || i.name === v) {\n            const msg = new SpeechSynthesisUtterance()\n            msg.voice = i\n            msg.lang = i.lang\n            sys.__v0['話:話者'] = i\n            console.log('#話者:', i.name)\n            return i\n          }\n        }\n      }\n      // 話者一覧取得で得たオブジェクトを直接指定した場合\n      if (typeof v === 'object') {\n        sys.__v0['話:話者'] = v\n        return v\n      }\n      return undefined\n    }\n  },\n  '話者速度': { type: 'const', value: 1.0 }, // @わしゃそくど\n  '話者声高': { type: 'const', value: 1.0 }, // @わしゃこわだか\n  '話者音量': { type: 'const', value: 1.0 }, // @わしゃこおんりょう\n  '話者詳細設定': { // @音声合成APIの話者の設定をオブジェクト形式で設定する。『速度,声高,ピッチ,音量』を指定 // @わしゃしょうさいせってい\n    type: 'func',\n    josi: [['で', 'に', 'へ']],\n    pure: true,\n    fn: function (obj, sys) {\n      const changeFunc = (key, v) => {\n        if (key === '速度') { sys.__v0['話者速度'] = v }\n        if (key === '声高' || key === 'ピッチ') { sys.__v0['話者声高'] = v }\n        if (key === '音量') { sys.__v0['話者音量'] = v }\n      }\n      // 一括変更\n      for (const key in obj) {\n        const v = obj[key]\n        changeFunc(key, v)\n      }\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_speech.mjs?")},"./src/plugin_browser_storage.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @ローカルストレージ\n  '保存': { // @ブラウザのlocalStorageのキーKに文字列Vを保存 // @ほぞん\n    type: 'func',\n    josi: [['を'], ['に', 'へ']],\n    pure: false,\n    fn: function (v, key, sys) {\n      sys.__exec('ローカルストレージ保存', [v, key, sys])\n    },\n    return_none: true\n  },\n  '開': { // @ブラウザのlocalStorageからVを読む // @ひらく\n    type: 'func',\n    josi: [['を', 'から', 'の']],\n    pure: false,\n    fn: function (key, sys) {\n      return sys.__exec('ローカルストレージ読', [key, sys])\n    },\n    return_none: false\n  },\n  '読': { // @ブラウザのlocalStorageからVを読む // @よむ\n    type: 'func',\n    josi: [['を', 'から', 'の']],\n    pure: false,\n    fn: function (key, sys) {\n      return sys.__exec('ローカルストレージ読', [key, sys])\n    },\n    return_none: false\n  },\n  '存在': { // @ブラウザのlocalStorageにKEYが存在しているか調べる // @そんざい\n    type: 'func',\n    josi: [['が']],\n    pure: true,\n    fn: function (key) {\n      const s = window.localStorage.getItem(key)\n      return (s !== null)\n    },\n    return_none: false\n  },\n  'ローカルストレージ保存': { // @ブラウザのlocalStorageのKにVを保存 // @ろーかるすとれーじほぞん\n    type: 'func',\n    josi: [['を'], ['に', 'へ']],\n    pure: true,\n    fn: function (v, key, sys) {\n      let body = v\n      if (sys.__v0['保存オプション'] && (sys.__v0['保存オプション'].indexOf('json') >= 0)) {\n        body = JSON.stringify(body)\n      }\n      window.localStorage[key] = body\n    },\n    return_none: true\n  },\n  'ローカルストレージ読': { // @ブラウザのlocalStorageからVを読む // @ろーかるすとれーじよむ\n    type: 'func',\n    josi: [['を', 'から', 'の']],\n    pure: true,\n    fn: function (key, sys) {\n      const v = window.localStorage[key]\n      if (sys.__v0['保存オプション'] && (sys.__v0['保存オプション'].indexOf('json') >= 0)) {\n        try {\n          return JSON.parse(v)\n        } catch (e) {\n          console.log('ローカルストレージ『' + key + '』の読み込みに失敗')\n        }\n      }\n      return v\n    },\n    return_none: false\n  },\n  'ローカルストレージキー列挙': { // @ブラウザのlocalStorageのキー一覧を返す // @ろーかるすとれーじきーれっきょ\n    type: 'func',\n    josi: [[]],\n    pure: true,\n    fn: function (key) {\n      const keys = []\n      for (const key in window.localStorage) { keys.push(key) }\n\n      return keys\n    },\n    return_none: false\n  },\n  'ローカルストレージキー削除': { // @ブラウザのlocalStorageのkeyを削除 // @ろーかるすとれーじきーさくじょ\n    type: 'func',\n    josi: [['を', 'の']],\n    pure: true,\n    fn: function (key) {\n      window.localStorage.removeItem(key)\n    },\n    return_none: true\n  },\n  'ローカルストレージ全削除': { // @ブラウザのlocalStorageのデータを全部削除する // @ろーかるすとれーじぜんさくじょ\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function () {\n      window.localStorage.clear()\n    },\n    return_none: true\n  },\n  'ローカルストレージ有効確認': { // @ブラウザのlocalStorageが使えるか確認 // @ろーかるすとれーじりようかくにん\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function () {\n      return (typeof window.localStorage !== 'undefined')\n    },\n    return_none: false\n  },\n  '保存オプション': { type: 'const', value: 'json' }, // @ ほぞんおぷしょん\n  '保存オプション設定': { // @ブラウザのlocalStorageへの保存オプション「json」を設定する // @ほぞんおぷしょんせってい\n    type: 'func',\n    josi: [['に', 'へ']],\n    pure: true,\n    fn: function (v, sys) {\n      v = v.toUpperCase(v)\n      sys.__v0['保存オプション'] = v\n    },\n    return_none: true\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_storage.mjs?")},"./src/plugin_browser_system.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @システム\n  'WNAKOバージョン': { type: 'const', value: '' }, // @WNAKOなでしこランタイムバージョン(言語エンジンのナデシコバージョンと異なることがある) // @WNAKOばーじょん\n  '終': { // @ブラウザでプログラムの実行を強制終了する // @おわる\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function () {\n      throw new Error('__終わる__')\n    },\n    return_none: true\n  },\n  'OS取得': { // @OSプラットフォームを返す(darwin/windows/ubuntu/linux/android/iphone/ipad/unknown) // @OSしゅとく\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function () {\n      const ua = window.navigator.userAgent.toLowerCase()\n      if (ua.indexOf('windows') !== -1) { return 'windows' }\n      if (ua.indexOf('android') !== -1) { return 'android' }\n      if (ua.indexOf('iphone') !== -1) { return 'iphone' }\n      if (ua.indexOf('ipad') !== -1) { return 'ipad' }\n      if (ua.indexOf('mac os x') !== -1) { return 'darwin' }\n      if (ua.indexOf('macintosh') !== -1) { return 'darwin' }\n      if (ua.indexOf('cros') !== -1) { return 'chromeos' }\n      if (ua.indexOf('ubuntu') !== -1) { return 'ubuntu' }\n      if (ua.indexOf('linux') !== -1) { return 'linux' }\n      return 'unknown'\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_system.mjs?")},"./src/plugin_browser_websocket.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// @ts-nocheck\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // @WebSocket\n  'WS接続完了時': { // @WebSocketでサーバに接続完了した時に実行されるイベントを指定 // @WSせつぞくかんりょうしたとき\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (callback, sys) {\n      sys.__v0['WS:ONOPEN'] = callback\n    },\n    return_none: true\n  },\n  'WS受信時': { // @WebSocketでサーバからメッセージを受信した時に実行されるイベントを指定 // @WSじゅしんしたとき\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (callback, sys) {\n      sys.__v0['WS:ONMESSAGE'] = callback\n    },\n    return_none: true\n  },\n  'WSエラー発生時': { // @WebSocketでエラーが発生した時に実行されるイベントを指定 // @WSえらーはっせいじ\n    type: 'func',\n    josi: [['を']],\n    pure: true,\n    fn: function (callback, sys) {\n      sys.__v0['WS:ONERROR'] = callback\n    },\n    return_none: true\n  },\n  'WS接続': { // @WebSocketサーバsに接続する // @WSせつぞく\n    type: 'func',\n    josi: [['に', 'へ', 'の']],\n    pure: true,\n    fn: function (s, sys) {\n      const ws = new WebSocket(s)\n      ws.onopen = () => {\n        const cbOpen = sys.__v0['WS:ONOPEN']\n        if (cbOpen) { cbOpen(sys) }\n      }\n      ws.onerror = (err) => {\n        const cbError = sys.__v0['WS:ONERROR']\n        if (cbError) { cbError(err, sys) }\n        console.log('WSエラー', err)\n      }\n      ws.onmessage = (e) => {\n        sys.__v0['対象'] = e.data\n        const cbMsg = sys.__v0['WS:ONMESSAGE']\n        if (cbMsg) { cbMsg(sys) }\n      }\n      sys.__v0['WS:SOCKET'] = ws\n      return ws\n    }\n  },\n  'WS送信': { // @アクティブなWebSocketへsを送信する // @WSそうしん\n    type: 'func',\n    josi: [['を', 'と']],\n    pure: true,\n    fn: function (s, sys) {\n      const ws = sys.__v0['WS:SOCKET']\n      ws.send(s)\n    }\n  },\n  'WS切断': { // @アクティブなWebSocketを閉じる // @WSせつだん\n    type: 'func',\n    josi: [],\n    pure: true,\n    fn: function (sys) {\n      const ws = sys.__v0['WS:SOCKET']\n      ws.close()\n    }\n  }\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/plugin_browser_websocket.mjs?")},"./src/wnako3.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wnako3mod_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wnako3mod.mjs */ \"./src/wnako3mod.mjs\");\n// wnako3 - nadesiko for web browser\n\n// ブラウザから取り込まれる時 navigator.nako3 になでしこを登録\nif ((typeof navigator) === 'object' && !navigator.exportWNako3) {\n    const wnako3 = navigator.nako3 = new _wnako3mod_mjs__WEBPACK_IMPORTED_MODULE_0__.WebNakoCompiler();\n    window.addEventListener('DOMContentLoaded', (e) => {\n        const isAutoRun = wnako3.checkScriptTagParam();\n        if (isAutoRun) {\n            wnako3.runNakoScript();\n        }\n    }, false);\n}\n\n\n//# sourceURL=webpack://nadesiko3/./src/wnako3.mjs?")},"./src/wnako3_editor.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BackgroundTokenizer\": function() { return /* binding */ BackgroundTokenizer; },\n/* harmony export */   \"EditorMarkers\": function() { return /* binding */ EditorMarkers; },\n/* harmony export */   \"LanguageFeatures\": function() { return /* binding */ LanguageFeatures; },\n/* harmony export */   \"createParameterDeclaration\": function() { return /* binding */ createParameterDeclaration; },\n/* harmony export */   \"createParameterName\": function() { return /* binding */ createParameterName; },\n/* harmony export */   \"escapeHTML\": function() { return /* binding */ escapeHTML; },\n/* harmony export */   \"findPluginName\": function() { return /* binding */ findPluginName; },\n/* harmony export */   \"getDocumentationHTML\": function() { return /* binding */ getDocumentationHTML; },\n/* harmony export */   \"getEditorTokens\": function() { return /* binding */ getEditorTokens; },\n/* harmony export */   \"getScope\": function() { return /* binding */ getScope; },\n/* harmony export */   \"setupEditor\": function() { return /* binding */ setupEditor; },\n/* harmony export */   \"tokenize\": function() { return /* binding */ tokenize; }\n/* harmony export */ });\n/* harmony import */ var _core_src_nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/src/nako_source_mapping.mjs */ \"./core/src/nako_source_mapping.mjs\");\n/* harmony import */ var _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/src/nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _core_src_nako_indent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/src/nako_indent.mjs */ \"./core/src/nako_indent.mjs\");\n/* harmony import */ var _core_src_nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/src/nako_prepare.mjs */ \"./core/src/nako_prepare.mjs\");\n// @ts-nocheck\n/* eslint-disable no-template-curly-in-string */\n/** なでしこのtokenのtypeをscope（CSSのクラス名）に変換する。 */\n\n\n\n\n// alias\nconst getBlockStructure = _core_src_nako_indent_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getBlockStructure;\nconst getIndent = _core_src_nako_indent_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getIndent;\nconst countIndent = _core_src_nako_indent_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].countIndent;\nconst isIndentSyntaxEnabled = _core_src_nako_indent_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isIndentSyntaxEnabled;\n/**\n * @typedef {import('./nako3')} NakoCompiler\n *\n * @typedef {{\n *     getValue(): string\n *     setValue(text: string): void\n *     session: Session\n *     execCommand(command: string): void\n *     setReadOnly(value: boolean): void\n *     setOption(key: string, value: unknown): void\n *     getOption(key: string): unknown\n *     setOptions(entries: Record<string, unknown>): void\n *     setFontSize(px: number): void\n *     setKeyboardHandler(name: string): void\n *     setTheme(name: string): void\n *     container: HTMLElement\n *     wnako3EditorId?: number\n *     getCursorPosition(): { row: number, column: number }\n *     commands: { addCommand(data: { name: string, exec: (editor: AceEditor, args: any[]) => void }): void }\n * }} AceEditor\n *\n * @typedef {import(\"./nako_lexer\").TokenWithSourceMap} TokenWithSourceMap\n *\n * @typedef {{\n *     getLine(row: number): string\n *     getAllLines(): string[]\n *     getLength(): number\n *     insertInLine(position: { row: number, column: number }, text: string): void\n *     removeInLine(row: number, columnStart: number, columnEnd: number): void\n *     replace(range: AceRange, text: string): void\n * }} AceDocument\n *\n * @typedef {{\n *     doc: AceDocument\n *     bgTokenizer: BackgroundTokenizer\n *     getScrollTop(): number\n *     setScrollTop(x: number): void\n *     getScrollLeft(): number\n *     setScrollLeft(x: number): void\n *     getUndoManager(): any\n *     setUndoManager(x: any): void\n *     selection: { getRange(): AceRange, isBackwards(): boolean, setRange(range: AceRange, reversed: boolean): void, clearSelection(): void }\n *     setMode(mode: string | object): void\n * }} Session\n *\n * @typedef {{}} AceRange\n *\n * @typedef {new (startLine: number, startColumn: number, endLine: number, endColumn: number) => AceRange} TypeofAceRange\n *\n * @typedef {string} TokenType\n * @typedef {{ type: TokenType, value: string, docHTML: string | null }} EditorToken\n *\n * @typedef {{ start: { row: number }, command: { id: string, title: string, arguments: string[] } }} CodeLens\n */\n/**\n * シンタックスハイライトでは一般にテキストの各部分に 'comment.line' のようなラベルを付け、各エディタテーマがそのそれぞれの色を設定する。\n * ace editor では例えば 'comment.line' が付いた部分はクラス .ace_comment.ace_line が付いたHTMLタグで囲まれ、各テーマはそれに対応するCSSを実装する。\n * @param {TokenWithSourceMap} token\n * @returns {TokenType}\n */\nfunction getScope(token) {\n    switch (token.type) {\n        case 'line_comment': return 'comment.line';\n        case 'range_comment': return 'comment.block';\n        case 'def_test': return 'keyword.control';\n        case 'def_func': return 'keyword.control';\n        case 'func': return 'entity.name.function';\n        case 'number': return 'constant.numeric';\n        // 独立した助詞\n        case 'とは':\n        case 'ならば':\n        case 'でなければ':\n            return 'keyword.control';\n        // 制御構文\n        case 'ここから':\n        case 'ここまで':\n        case 'もし':\n        case '違えば':\n        case 'require':\n            return 'keyword.control';\n        // 予約語\n        case '回':\n        case '間':\n        case '繰り返す':\n        case '反復':\n        case '抜ける':\n        case '続ける':\n        case '戻る':\n        case '先に':\n        case '次に':\n        case '代入':\n        case '逐次実行':\n        case '条件分岐':\n        case '取込':\n        case 'エラー監視':\n        case 'エラー':\n        case '変数':\n        case '実行速度優先':\n            return 'keyword.control';\n        case '定める':\n        case '定数':\n            return 'support.constant';\n        // 演算子\n        case 'shift_r0':\n        case 'shift_r':\n        case 'shift_l':\n        case 'gteq':\n        case 'lteq':\n        case 'noteq':\n        case 'eq':\n        case 'not':\n        case 'gt':\n        case 'lt':\n        case 'and':\n        case 'or':\n        case '@':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '^':\n        case '&':\n            return 'keyword.operator';\n        case 'string':\n        case 'string_ex':\n            return 'string.other';\n        case 'word':\n            if (['そう', 'それ', '回数', '対象キー', '対象'].includes(token.value)) {\n                return 'variable.language';\n            }\n            else {\n                return 'variable.other';\n            }\n        default:\n            return 'markup.other';\n    }\n}\n/**\n * @param {TokenWithSourceMap} compilerToken\n * @param {NakoCompiler} nako3\n * @param {string} value\n * @param {boolean} includesLastCharacter\n * @param {boolean} underlineJosi\n */\nfunction getEditorTokens(compilerToken, nako3, value, includesLastCharacter, underlineJosi) {\n    const type = getScope(compilerToken);\n    const docHTML = getDocumentationHTML(compilerToken, nako3);\n    // 助詞があれば助詞の部分を分割する。\n    // 最後の文字が現在の行に含まれないときは助詞を表示しない。そうしないと例えば `「文字列\\n」を表示` の「列」の部分に下線が引かれてしまう。\n    if (compilerToken.rawJosi && value.length >= compilerToken.rawJosi.length && includesLastCharacter && underlineJosi) {\n        return [\n            { type, docHTML, value: value.slice(0, -compilerToken.rawJosi.length) },\n            { type: type + '.markup.underline', docHTML, value: value.slice(-compilerToken.josi.length) }\n        ];\n    }\n    return [\n        { type, docHTML, value }\n    ];\n}\n/**\n * `name` が定義されたプラグインの名前を返す。\n * @param {string} name\n * @param {NakoCompiler} nako3\n * @returns {string | null}\n */\nfunction findPluginName(name, nako3) {\n    for (const pluginName of Object.keys(nako3.__module)) {\n        if (Object.keys(nako3.__module[pluginName]).includes(name)) {\n            return pluginName;\n        }\n    }\n    return null;\n}\n/**\n * i = 0, 1, 2, ... に対して 'A', 'B', 'C', ... 'Z', 'AA', 'AB', ... を返す。\n * @param {number} i\n * @returns {string}\n */\nfunction createParameterName(i) {\n    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n    return i.toString(26).split('').map((v) => alphabet[parseInt(v, 26)]).join('');\n}\n/**\n * パラメータの定義を表す文字列を生成する。例えば `[['と', 'の'], ['を']]` に対して `'（Aと|Aの、Bを）'` を返す、パラメータが無い場合、空文字列を返す。\n * @param {string[][]} josi\n * @retunrs {string}\n */\nfunction createParameterDeclaration(josi) {\n    const args = josi.map((union, i) => union.map((v) => `${createParameterName(i)}${v}`).join('|')).join('、');\n    if (args !== '') {\n        return `（${args}）`;\n    }\n    else {\n        return '';\n    }\n}\n// https://stackoverflow.com/a/6234804\n/** @param {string} t */\nfunction escapeHTML(t) {\n    return t\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#039;');\n}\n/**\n * 関数のドキュメントを返す。\n * @param {TokenWithSourceMap} token\n * @param {NakoCompiler} nako3\n * @returns {string | null}\n */\nfunction getDocumentationHTML(token, nako3) {\n    /** @param {string} text */\n    const meta = (text) => `<span class=\"tooltip-plugin-name\">${escapeHTML(text)}</span>`;\n    if (token.type === 'func') {\n        /** @type {string | null} */\n        const pluginName = findPluginName(token.value + '', nako3) || (token.meta && token.meta.file ? token.meta.file : null);\n        const josi = (token.meta && token.meta.josi) ? createParameterDeclaration(token.meta.josi) : ''; // {関数} のとき token.meta.josi が存在しない\n        if (pluginName) {\n            return escapeHTML(josi + token.value) + meta(pluginName);\n        }\n        return escapeHTML(josi + token.value);\n    }\n    else if (token.type === 'word') {\n        /** @type {string | null} */\n        const pluginName = findPluginName(token.value + '', nako3) || (token.meta && token.meta.file ? token.meta.file : null);\n        if (pluginName) {\n            return escapeHTML(token.value + '') + meta(pluginName);\n        }\n    }\n    return null;\n}\n/**\n * ace editor ではエディタの文字列の全ての部分に何らかの `type` を付けなければならない。\n * なでしこのエディタでは 'markup.other' をデフォルト値として使うことにした。\n * @param {number} row\n * @param {AceDocument} doc\n * @returns {EditorToken[]}\n */\nconst getDefaultTokens = (row, doc) => [{ type: 'markup.other', value: doc.getLine(row), docHTML: null }];\n/**\n * 一時的にloggerを無効化する。そうしないとシンタックスハイライトの更新のたびにloggerへコンパイルエラーや警告が送られて、結果のボックスに行が追加されてしまう。\n * @type {<T>(nako3: NakoCompiler, f: () => T) => T}\n */\nconst withoutLogger = (nako3, f) => {\n    const logger = nako3.logger;\n    try {\n        nako3.replaceLogger();\n        return f();\n    }\n    finally {\n        nako3.logger = logger;\n    }\n};\n/**\n * プログラムをlexerでtokenizeした後、ace editor 用のトークン列に変換する。\n * @param lines\n * @param nako3\n * @param underlineJosi\n */\nfunction tokenize(lines, nako3, underlineJosi) {\n    const code = lines.join('\\n');\n    // 取り込み文を含めてしまうと依存ファイルが大きい時に時間がかかってしまうため、\n    // 取り込み文を無視してトークン化してから、依存ファイルで定義された関数名と一致するトークンを関数のトークンへ変換する。\n    nako3.reset({ needToClearPlugin: false });\n    const lexerOutput = withoutLogger(nako3, () => nako3.lex(code, 'main.nako3', undefined, true));\n    lexerOutput.commentTokens = lexerOutput.commentTokens.filter((t) => t.file === 'main.nako3');\n    lexerOutput.requireTokens = lexerOutput.requireTokens.filter((t) => t.file === 'main.nako3');\n    lexerOutput.tokens = lexerOutput.tokens.filter((t) => t.file === 'main.nako3');\n    // 外部ファイルで定義された関数名に一致するトークンのtypeをfuncに変更する。\n    // 取り込んでいないファイルも参照される問題や、関数名の重複がある場合に正しくない情報を表示する問題がある。\n    // eslint-disable-next-line no-lone-blocks\n    {\n        /** @type {Record<string, object>} */\n        for (const [file, { funclist }] of Object.entries(nako3.dependencies)) {\n            for (const token of lexerOutput.tokens) {\n                if (token.type === 'word' && token.value !== 'それ' && funclist[token.value]) {\n                    token.type = 'func';\n                    // meta.file に定義元のファイル名を持たせる。\n                    token.meta = { ...funclist[token.value + ''], file };\n                }\n            }\n        }\n    }\n    // eol、eof、長さが1未満のトークン、位置を特定できないトークンを消す\n    /** @type {(TokenWithSourceMap & { startOffset: number, endOffset: number })[]} */\n    // @ts-ignore\n    const tokens = [...lexerOutput.tokens, ...lexerOutput.commentTokens, ...lexerOutput.requireTokens].filter((t) => t.type !== 'eol' && t.type !== 'eof' &&\n        typeof t.startOffset === 'number' && typeof t.endOffset === 'number' &&\n        t.startOffset < t.endOffset);\n    // startOffsetでソートする\n    tokens.sort((a, b) => (a.startOffset || 0) - (b.startOffset || 0));\n    // 各行について、余る文字の無いようにエディタのトークンに変換する。\n    // 複数のトークンが重なることはないと仮定する。\n    let lineStartOffset = 0;\n    let tokenIndex = 0;\n    // 実際に必要なプロパティはtype, valueだけで、docは独自に追加した。\n    /** @type {EditorToken[][]} */\n    const editorTokens = []; // 各行のエディタのトークン\n    for (let i = 0; i < lines.length; i++) {\n        editorTokens.push([]);\n        const lineEndOffset = lineStartOffset + lines[i].length;\n        let offset = lineStartOffset;\n        // 現在の行にかかっているトークンまで飛ばす\n        while (tokenIndex < tokens.length &&\n            tokens[tokenIndex].endOffset <= lineStartOffset) {\n            tokenIndex++;\n        }\n        // 行全体を完全にまたがっているトークンが存在する場合\n        if (tokenIndex < tokens.length &&\n            tokens[tokenIndex].startOffset <= lineStartOffset &&\n            tokens[tokenIndex].endOffset >= lineEndOffset) {\n            editorTokens[i].push(...getEditorTokens(tokens[tokenIndex], nako3, lines[i], tokens[tokenIndex].endOffset <= lineEndOffset, underlineJosi));\n        }\n        else {\n            // 行頭をまたがっているトークンが存在する場合\n            if (tokenIndex < tokens.length &&\n                tokens[tokenIndex].startOffset <= lineStartOffset) {\n                editorTokens[i].push(...getEditorTokens(tokens[tokenIndex], nako3, code.slice(offset, tokens[tokenIndex].endOffset), true, underlineJosi));\n                offset = tokens[tokenIndex].endOffset;\n                tokenIndex++;\n            }\n            // 行頭も行末もまたがっていないトークンを処理する\n            while (tokenIndex < tokens.length &&\n                tokens[tokenIndex].endOffset < lineEndOffset) {\n                // このトークンと直前のトークンの間に隙間があるなら、埋める\n                if (offset < tokens[tokenIndex].startOffset) {\n                    editorTokens[i].push({\n                        type: 'markup.other',\n                        docHTML: null,\n                        value: code.slice(offset, tokens[tokenIndex].startOffset)\n                    });\n                    offset = tokens[tokenIndex].startOffset;\n                }\n                // 現在のトークンを使う\n                editorTokens[i].push(...getEditorTokens(tokens[tokenIndex], nako3, code.slice(offset, tokens[tokenIndex].endOffset), true, underlineJosi));\n                offset = tokens[tokenIndex].endOffset;\n                tokenIndex++;\n            }\n            // 行末をまたがっているトークンが存在する場合\n            if (tokenIndex < tokens.length &&\n                tokens[tokenIndex].startOffset < lineEndOffset) {\n                // トークンの前の隙間\n                if (offset < tokens[tokenIndex].startOffset) {\n                    editorTokens[i].push({\n                        type: 'markup.other',\n                        docHTML: null,\n                        value: code.slice(offset, tokens[tokenIndex].startOffset)\n                    });\n                    offset = tokens[tokenIndex].startOffset;\n                }\n                // トークンを使う\n                editorTokens[i].push(...getEditorTokens(tokens[tokenIndex], nako3, code.slice(tokens[tokenIndex].startOffset, lineEndOffset), tokens[tokenIndex].endOffset <= lineEndOffset, underlineJosi));\n            }\n            else {\n                editorTokens[i].push({\n                    type: 'markup.other',\n                    docHTML: null,\n                    value: code.slice(offset, lineEndOffset)\n                });\n            }\n        }\n        lineStartOffset += lines[i].length + 1;\n    }\n    return { editorTokens, lexerOutput };\n}\n/**\n * エディタ上にエラーメッセージの波線とgutterの赤いマークとエラーメッセージのポップアップを設定するためのクラス。\n */\nclass EditorMarkers {\n    /**\n       * @param {any} session\n       * @param {AceDocument} doc\n       * @param {TypeofAceRange} AceRange\n       * @param {boolean} disable\n       */\n    constructor(session, doc, AceRange, disable) {\n        this.session = session;\n        this.doc = doc;\n        this.AceRange = AceRange;\n        /** @type {any[]} */\n        this.markers = [];\n        this.hasAnnotations = false;\n        this.disable = disable;\n    }\n    /**\n       * @param {number} startLine\n       * @param {number | null} startColumn\n       * @param {number | null} endLine\n       * @param {number | null} endColumn\n       * @param {(row: number) => string} getLine\n       * @returns {[number, number, number, number]}\n       */\n    static fromNullable(startLine, startColumn, endLine, endColumn, getLine) {\n        if (startColumn === null) {\n            startColumn = 0;\n        }\n        if (endLine === null) {\n            endLine = startLine;\n        }\n        if (endColumn === null) {\n            endColumn = getLine(endLine).length;\n        }\n        // 最低でも1文字分の長さをとる\n        if (startLine === endLine && startColumn === endColumn) {\n            endColumn++;\n        }\n        return [startLine, startColumn, endLine, endColumn];\n    }\n    /**\n       * @param {string} code @param {number} startOffset @param {number} endOffset\n       * @returns {[number, number, number, number]}\n       */\n    static fromOffset(code, startOffset, endOffset) {\n        const offsetToLineColumn = new _core_src_nako_source_mapping_mjs__WEBPACK_IMPORTED_MODULE_0__.OffsetToLineColumn(code);\n        const start = offsetToLineColumn.map(startOffset, false);\n        const end = offsetToLineColumn.map(endOffset, false);\n        return [start.line, start.column, end.line, end.column];\n    }\n    /**\n       * @param {string} code\n       * @param {{ line?: number, startOffset?: number | null, endOffset?: number | null, message: string }} error\n       * @param {(row: number) => string} getLine\n       * @returns {[number, number, number, number]}\n       */\n    static fromError(code, error, getLine) {\n        if (typeof error.startOffset === 'number' && typeof error.endOffset === 'number') {\n            // 完全な位置を取得できる場合\n            return this.fromOffset(code, error.startOffset, error.endOffset);\n        }\n        else if (typeof error.line === 'number') {\n            // 行全体の場合\n            return this.fromNullable(error.line, null, null, null, getLine);\n        }\n        else {\n            // 位置が不明な場合\n            return this.fromNullable(0, null, null, null, getLine);\n        }\n    }\n    /**\n       * @param {number} startLine\n       * @param {number | null} startColumn\n       * @param {number | null} endLine\n       * @param {number | null} endColumn\n       * @param {string} message\n       * @param {'warn' | 'error'} type\n       */\n    add(startLine, startColumn, endLine, endColumn, message, type) {\n        if (this.disable) {\n            return;\n        }\n        const range = new this.AceRange(...EditorMarkers.fromNullable(startLine, startColumn, endLine, endColumn, (row) => this.doc.getLine(row)));\n        this.markers.push(this.session.addMarker(range, 'marker-' + (type === 'warn' ? 'yellow' : 'red'), 'text', false));\n        // typeは 'error' | 'warning' | 'info'\n        this.session.setAnnotations([{ row: startLine, column: startColumn, text: message, type: type === 'warn' ? 'warning' : 'error' }]);\n        this.hasAnnotations = true;\n    }\n    /**\n       * @param {string} code\n       * @param {{ line?: number, startOffset?: number | null, endOffset?: number | null, message: string }} error\n       * @param {'warn' | 'error'} type\n       */\n    addByError(code, error, type) {\n        this.add(...EditorMarkers.fromError(code, error, (row) => this.doc.getLine(row)), error.message, type);\n    }\n    /**\n       * 全てのエラーメッセージを削除する。\n       */\n    clear() {\n        for (const marker of this.markers) {\n            this.session.removeMarker(marker);\n        }\n        this.markers.length = 0;\n        if (this.hasAnnotations) {\n            this.session.clearAnnotations();\n            this.hasAnnotations = false;\n        }\n    }\n}\n/**\n * ace editor のBackgroundTokenizerを上書きして、シンタックスハイライトを自由に表示するためのクラス。\n * ace editor ではシンタックスハイライトのために正規表現ベースのBackgroundTokenizerクラスを用意し定期的にトークン化を\n * 行っているが、正規表現ではなくなでしこのコンパイラの出力を使うためにはそれを上書きする必要がある。\n */\nclass BackgroundTokenizer {\n    /**\n       * @param {AceDocument} doc\n       * @param {NakoCompiler} nako3\n       * @param {(firstRow: number, lastRow: number, ms: number) => void} onTokenUpdate\n       * @param {(code: string, err: Error) => void} onCompileError\n       * @param {boolean} underlineJosi\n       */\n    constructor(doc, nako3, onTokenUpdate, onCompileError, underlineJosi) {\n        this.onUpdate = onTokenUpdate;\n        this.doc = doc;\n        this.dirty = true;\n        this.nako3 = nako3;\n        this.onCompileError = onCompileError;\n        this.underlineJosi = underlineJosi;\n        // オートコンプリートで使うために、直近のtokenizeの結果を保存しておく\n        /** @type {ReturnType<NakoCompiler['lex']> | null} */\n        this.lastLexerOutput = null;\n        // 各行のパース結果。\n        // typeはscopeのこと。配列の全要素のvalueを結合した文字列がその行の文字列と等しくなる必要がある。\n        /** @type {EditorToken[][]} */\n        this.lines = this.doc.getAllLines().map((line) => [{ type: 'markup.other', value: line, docHTML: null }]);\n        // this.lines は外部から勝手に編集されてしまうため、コピーを持つ\n        /** @type {{ code: string, lines: string } | null} */\n        this.cache = null;\n        this.deleted = false;\n        /** @public */\n        this.enabled = true;\n        const update = () => {\n            if (this.deleted) {\n                return;\n            }\n            if (this.dirty && this.enabled) {\n                const startTime = Date.now();\n                this.dirty = false;\n                const code = this.doc.getAllLines().join('\\n');\n                try {\n                    const startTime = Date.now();\n                    const out = tokenize(this.doc.getAllLines(), nako3, this.underlineJosi);\n                    this.lastLexerOutput = out.lexerOutput;\n                    this.lines = out.editorTokens;\n                    this.cache = { code, lines: JSON.stringify(this.lines) };\n                    // ファイル全体の更新を通知する。\n                    onTokenUpdate(0, this.doc.getLength() - 1, Date.now() - startTime);\n                }\n                catch (e) {\n                    onCompileError(code, e);\n                }\n                // tokenizeに時間がかかる場合、文字を入力できるように次回の実行を遅くする。\n                setTimeout(update, Math.max(100, Math.min(5000, (Date.now() - startTime) * 5)));\n            }\n            else {\n                setTimeout(update, 100);\n            }\n        };\n        // コンストラクタが返る前にコールバックを呼ぶのはバグの元になるため一瞬待つ。\n        // たとえば `const a = new BackgroundTokenizer(..., () => { /* aを使った処理 */ }, ...)` がReferenceErrorになる。\n        setTimeout(() => { update(); }, 0);\n    }\n    dispose() {\n        this.deleted = true;\n    }\n    /**\n       * テキストに変更があったときに呼ばれる。IME入力中には呼ばれない。\n       * @param {{ action: string, start: { row: number, column: number }, end: { row: number, column: number }, lines: string[] }} delta\n       */\n    $updateOnChange(delta) {\n        this.dirty = true;\n        const startRow = delta.start.row;\n        const endRow = delta.end.row;\n        if (startRow === endRow) { // 1行の編集\n            if (delta.action === 'insert' && this.lines[startRow]) { // 行内に文字列を挿入\n                const columnStart = delta.start.column;\n                // updateOnChangeはIME入力中には呼ばれない。composition_placeholder を消さないとIME確定後の表示がずれる。\n                const oldTokens = this.lines[startRow]\n                    .filter((v) => v.type !== 'composition_placeholder');\n                /** @type {EditorToken[]} */\n                const newTokens = [];\n                let i = 0;\n                let offset = 0;\n                // columnStartより左のトークンはそのまま保持する\n                while (i < oldTokens.length && offset + oldTokens[i].value.length <= columnStart) {\n                    newTokens.push(oldTokens[i]);\n                    offset += oldTokens[i].value.length;\n                    i++;\n                }\n                // columnStartに重なっているトークンがあれば、2つに分割する\n                if (i < oldTokens.length && offset < columnStart) {\n                    newTokens.push({ type: oldTokens[i].type, value: oldTokens[i].value.slice(0, columnStart - offset), docHTML: null });\n                    newTokens.push({ type: 'markup.other', value: delta.lines[0], docHTML: null });\n                    newTokens.push({ type: oldTokens[i].type, value: oldTokens[i].value.slice(columnStart - offset), docHTML: null });\n                    i++;\n                }\n                else {\n                    newTokens.push({ type: 'markup.other', value: delta.lines[0], docHTML: null });\n                }\n                // columnStartより右のトークンもそのまま保持する\n                while (i < oldTokens.length) {\n                    newTokens.push(oldTokens[i]);\n                    i++;\n                }\n                this.lines[startRow] = newTokens;\n            }\n            else {\n                this.lines[startRow] = getDefaultTokens(startRow, this.doc);\n            }\n        }\n        else if (delta.action === 'remove') { // 範囲削除\n            this.lines.splice(startRow, endRow - startRow + 1, getDefaultTokens(startRow, this.doc));\n        }\n        else { // 行の挿入\n            this.lines.splice(startRow, 1, ...Array(endRow - startRow + 1).fill(null).map((_, i) => getDefaultTokens(i + startRow, this.doc)));\n        }\n    }\n    /**\n       * tokenizerの出力を返す。文字入力したときに呼ばれる。\n       * @param {number} row\n       */\n    getTokens(row) {\n        // IME入力中はthis.lines[row]に自動的にnullが設定される。その場合新しく行のトークン列を生成して返さなければならない。\n        // 返した配列には自動的にIMEの入力用のテキストボックスであるcomposition_placeholderが挿入される。\n        if (!this.lines[row]) {\n            let ok = false;\n            if (this.enabled) {\n                // tokenizeは非常に遅いため、キャッシュを使えるならそれを使う。\n                const code = this.doc.getAllLines().join('\\n');\n                if (this.cache !== null && this.cache.code === code) {\n                    ok = true;\n                }\n                else {\n                    try {\n                        const lines = tokenize(this.doc.getAllLines(), this.nako3, this.underlineJosi);\n                        this.cache = { code, lines: JSON.stringify(lines.editorTokens) };\n                        ok = true;\n                    }\n                    catch (e) {\n                        if (!(e instanceof _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoError)) {\n                            console.error(e);\n                        }\n                    }\n                }\n            }\n            if (ok && this.cache !== null) {\n                this.lines[row] = JSON.parse(this.cache.lines)[row];\n            }\n            else {\n                this.lines[row] = getDefaultTokens(row, this.doc);\n            }\n        }\n        return this.lines[row];\n    }\n    // ace側から呼ばれるが無視するメソッド\n    // @ts-ignore\n    start(startRow) { }\n    // @ts-ignore\n    fireUpdateEvent(firstRow, lastRow) { }\n    // @ts-ignore\n    setDocument(doc) { }\n    scheduleStart() { }\n    // @ts-ignore\n    setTokenizer(tokenizer) { }\n    stop() { }\n    // @ts-ignore\n    getState(row) { return 'start'; }\n}\n/**\n * シンタックスハイライト以外のエディタの挙動の定義。\n */\nclass LanguageFeatures {\n    /**\n       * @param {TypeofAceRange} AceRange\n       * @param {NakoCompiler} nako3\n       */\n    constructor(AceRange, nako3) {\n        this.AceRange = AceRange;\n        this.nako3 = nako3;\n    }\n    /**\n       * Ctrl + / の動作の定義。\n       * @param {string} state\n       * @param {Session} session\n       * @param {number} startRow\n       * @param {number} endRow\n       */\n    static toggleCommentLines(state, { doc }, startRow, endRow) {\n        const prepare = _core_src_nako_prepare_mjs__WEBPACK_IMPORTED_MODULE_3__.NakoPrepare.getInstance();\n        /**\n             * @param {string} line\n             * @returns {{ type: 'blank' | 'code' } | { type: 'comment', start: number, len: number }}\n             */\n        const parseLine = (line) => {\n            // 先頭の空白を消す\n            const indent = getIndent(line);\n            if (indent === line) {\n                return { type: 'blank' };\n            }\n            line = line.substring(indent.length);\n            // 先頭がコメントの開始文字かどうか確認する\n            const ch2 = line.substring(0, 2).split('').map((c) => prepare.convert1ch(c)).join('');\n            if (ch2.substring(0, 1) === '#') {\n                return { type: 'comment', start: indent.length, len: 1 + (line.charAt(1) === ' ' ? 1 : 0) };\n            }\n            if (ch2 === '//') {\n                return { type: 'comment', start: indent.length, len: 2 + (line.charAt(2) === ' ' ? 1 : 0) };\n            }\n            return { type: 'code' };\n        };\n        /** @type {number[]} */\n        const rows = [];\n        for (let i = startRow; i <= endRow; i++) {\n            rows.push(i);\n        }\n        // 全ての行が空白行ならコメントアウト、全ての行が行コメントで始まるか空白行ならアンコメント、そうでなければコメントアウト。\n        if (!rows.every((row) => parseLine(doc.getLine(row)).type === 'blank') &&\n            rows.every((row) => parseLine(doc.getLine(row)).type !== 'code')) {\n            // アンコメント\n            for (const row of rows) {\n                // 行コメントで始まる行ならアンコメントする。\n                // 行コメントの直後にスペースがあるなら、それも1文字だけ削除する。\n                const line = parseLine(doc.getLine(row));\n                if (line.type === 'comment') {\n                    doc.removeInLine(row, line.start, line.start + line.len);\n                }\n            }\n        }\n        else {\n            // 最もインデントの低い行のインデント数を数える\n            const minIndent = Math.min(...rows.map((row) => countIndent(doc.getLine(row))));\n            // コメントアウトする\n            for (const row of rows) {\n                const line = doc.getLine(row);\n                let column = line.length;\n                for (let i = 0; i < line.length; i++) {\n                    if (countIndent(line.slice(0, i)) >= minIndent) {\n                        column = i;\n                        break;\n                    }\n                }\n                doc.insertInLine({ row, column }, '// ');\n            }\n        }\n    }\n    /**\n       * 文字を入力するたびに呼ばれる。trueを返すとautoOutdentが呼ばれる。\n       * @param {string} state\n       * @param {string} line\n       * @param {string} input\n       * @returns {boolean}\n       */\n    static checkOutdent(state, line, input) {\n        // 特定のキーワードの入力が終わったタイミングでインデントを自動修正する。\n        // '違えば'のautoOutdentは「もし」と「条件分岐」のどちらのものか見分けが付かないため諦める。\n        // 「ここ|ま」（縦線がカーソル）の状態で「で」を打つとtrueになってしまう問題があるが、修正するには引数が足りない。\n        // eslint-disable-next-line no-irregular-whitespace\n        return /^[ 　・\\t]*ここまで$/.test(line + input);\n    }\n    /**\n       * checkOutdentがtrueを返したときに呼ばれる。\n       * @param {string} state\n       * @param {Session} session\n       * @param {number} row\n       * @returns {void}\n       */\n    autoOutdent(state, { doc }, row) {\n        // 1行目なら何もしない\n        if (row === 0) {\n            return;\n        }\n        const prevLine = doc.getLine(row - 1);\n        let indent;\n        if (LanguageFeatures.isBlockStart(prevLine)) {\n            // 1つ前の行が「〜ならば」などのブロック開始行なら、その行に合わせる。\n            indent = getIndent(prevLine);\n        }\n        else {\n            // そうでなければ、1つ前の行のインデントから1段階outdentした位置に合わせる。\n            const s = this.getBlockStructure(doc.getAllLines().join('\\n'));\n            const parent = s.parents[row];\n            indent = parent !== null ? s.spaces[parent] : '';\n        }\n        // 置換する\n        const oldIndent = getIndent(doc.getLine(row));\n        doc.replace(new this.AceRange(row, 0, row, oldIndent.length), indent);\n    }\n    /**\n       * エンターキーを押して行が追加されたときに挿入する文字列を指定する。\n       * @param {string} state\n       * @param {string} line 改行前にカーソルがあった行の文字列\n       * @param {string} tab タブ文字（デフォルトでは \"    \"）\n       */\n    static getNextLineIndent(state, line, tab) {\n        // ●で始まるか、特定のキーワードで終わる場合にマッチする。\n        if (this.isBlockStart(line)) {\n            return getIndent(line) + tab;\n        }\n        return getIndent(line);\n    }\n    /** @param {string} line */\n    static isBlockStart(line) {\n        // eslint-disable-next-line no-irregular-whitespace\n        return /^[ 　・\\t]*●|(ならば|なければ|ここから|条件分岐|違えば|回|繰り返(す|し)|の間|反復|とは|には|エラー監視|エラーならば|実行速度優先)、?\\s*$/.test(line);\n    }\n    /**\n       * オートコンプリート\n       * @param {number} row\n       * @param {string} prefix getCompletionPrefixの出力\n       * @param {NakoCompiler} nako3\n       * @param {BackgroundTokenizer} backgroundTokenizer\n       */\n    static getCompletionItems(row, prefix, nako3, backgroundTokenizer) {\n        /**\n             * keyはcaption。metaは候補の横に薄く表示されるテキスト。\n             * @type {Map<string, { value: string, meta: Set<string>, score: number }>}\n             */\n        const result = new Map();\n        /** 引数のリストを含まない、関数名だけのリスト @type {Set<string>} */\n        const values = new Set();\n        /**\n             * オートコンプリートの項目を追加する。すでに存在するならマージする。\n             * @param {string} caption @param {string} value @param {string} meta\n             */\n        const addItem = (caption, value, meta) => {\n            const item = result.get(caption);\n            if (item) {\n                item.meta.add(meta);\n            }\n            else {\n                // 日本語の文字数は英語よりずっと多いため、ただ一致する文字数を数えるだけで十分。\n                const score = prefix.split('').filter((c) => value.includes(c)).length;\n                result.set(caption, { value, meta: new Set([meta]), score });\n                values.add(value);\n            }\n        };\n        // プラグイン関数\n        for (const name of Object.keys(nako3.__varslist[0])) {\n            if (name.startsWith('!')) { // 「!PluginBrowser:初期化」などを除外\n                continue;\n            }\n            const f = nako3.funclist[name];\n            if (typeof f !== 'object' || f === null) {\n                continue;\n            }\n            const pluginName = findPluginName(name, nako3) || 'プラグイン';\n            if (f.type === 'func') {\n                addItem(createParameterDeclaration(f.josi) + name, name, pluginName);\n            }\n            else {\n                addItem(name, name, pluginName);\n            }\n        }\n        // 依存ファイルが定義した関数名\n        for (const [file, { funclist }] of Object.entries(nako3.dependencies)) {\n            for (const [name, f] of Object.entries(funclist)) {\n                const josi = (f && f.type === 'func') ? createParameterDeclaration(f.josi) : '';\n                addItem(josi + name, name, file);\n            }\n        }\n        // 現在のファイル内に存在する名前\n        if (backgroundTokenizer.lastLexerOutput !== null) {\n            for (const token of backgroundTokenizer.lastLexerOutput.tokens) {\n                const name = token.value + '';\n                // 同じ行のトークンの場合、自分自身にマッチしている可能性が高いため除外する。\n                // すでに定義されている場合も、定義ではなく参照の可能性が高いため除外する。\n                if (token.line === row || values.has(name)) {\n                    continue;\n                }\n                if (token.type === 'word') {\n                    addItem(name, name, '変数');\n                }\n                else if (token.type === 'func') {\n                    const f = nako3.funclist[name];\n                    const josi = (f && f.type === 'func') ? createParameterDeclaration(f.josi) : '';\n                    addItem(josi + name, name, '関数');\n                }\n            }\n        }\n        return Array.from(result.entries()).map(([caption, data]) => ({ caption, ...data, meta: Array.from(data.meta).join(', ') }));\n    }\n    /**\n       * スニペット\n       */\n    /** @param {string} text */\n    static getSnippets(text) {\n        // インデント構文が有効化されているなら「ここまで」を消す\n        const indentSyntax = isIndentSyntaxEnabled(text);\n        /** @param {string} en @param {string} jp @param {string} snippet */\n        const item = (en, jp, snippet) => indentSyntax\n            ? { caption: en, meta: `\\u21E5 ${jp}`, score: 1, snippet: snippet.replace(/\\t*ここまで(\\n|$)/g, '').replace(/\\t/g, '    ') }\n            : { caption: en, meta: `\\u21E5 ${jp}`, score: 1, snippet: snippet.replace(/\\t/g, '    ') };\n        return [\n            item('if', 'もし〜ならば', 'もし${1:1=1}ならば\\n\\t${2:1を表示}\\n違えば\\n\\t${3:2を表示}\\nここまで\\n'),\n            item('times', '〜回', '${1:3}回\\n\\t${2:1を表示}\\nここまで\\n'),\n            item('for', '繰り返す', '${1:N}で${2:1}から${3:3}まで繰り返す\\n\\t${4:Nを表示}\\nここまで\\n'),\n            item('while', '〜の間', '${1:N<2の間}\\n\\tN=N+1\\nここまで\\n'),\n            item('foreach', '〜を反復', '${1:[1,2,3]}を反復\\n\\t${2:対象を表示}\\nここまで\\n'),\n            item('switch', '〜で条件分岐', '${1:N}で条件分岐\\n\\t${2:1}ならば\\n\\t\\t${3:1を表示}\\n\\tここまで\\n\\t${4:2}ならば\\n\\t\\t${5:2を表示}\\n\\tここまで\\n\\t違えば\\n\\t\\t${6:3を表示}\\n\\tここまで\\nここまで\\n'),\n            item('function', '●〜とは', '●（${1:AとBを}）${2:足す}とは\\n\\t${3:A+Bを戻す}\\nここまで\\n'),\n            item('test', '●テスト:〜とは', '●テスト:${2:足す}とは\\n\\t1と2を足す\\n\\tそれと3がASSERT等しい\\nここまで\\n'),\n            item('try', 'エラー監視', 'エラー監視\\n\\t${1:1のエラー発生}\\nエラーならば\\n\\t${2:2を表示}\\nここまで\\n')\n        ];\n    }\n    /**\n       * @param {string} line\n       * @param {NakoCompiler} nako3\n       */\n    static getCompletionPrefix(line, nako3) {\n        /** @type {ReturnType<NakoCompiler['lex']>[\"tokens\"] | null} */\n        let tokens = null;\n        // ひらがなとアルファベットとカタカナと漢字のみオートコンプリートする。\n        if (line.length === 0 || !/[ぁ-んa-zA-Zァ-ヶー\\u3005\\u4E00-\\u9FCF]/.test(line[line.length - 1])) {\n            return '';\n        }\n        // 現在の行のカーソルより前の部分をlexerにかける。速度を優先して1行だけ処理する。\n        try {\n            nako3.reset();\n            tokens = withoutLogger(nako3, () => nako3.lex(line, 'completion.nako3', undefined, true)).tokens\n                .filter((t) => t.type !== 'eol' && t.type !== 'eof');\n        }\n        catch (e) {\n            if (!(e instanceof _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoError)) {\n                console.error(e);\n            }\n        }\n        if (tokens === null || tokens.length === 0 || !tokens[tokens.length - 1].value) {\n            return '';\n        }\n        const prefix = tokens[tokens.length - 1].value + '';\n        // 単語の先頭がひらがなではなく末尾がひらがなのとき、助詞を打っている可能性が高いためオートコンプリートしない。\n        if (/[ぁ-ん]/.test(prefix[prefix.length - 1]) && !/[ぁ-ん]/.test(prefix[0])) {\n            return '';\n        }\n        // 最後のトークンの値を、オートコンプリートで既に入力した部分とする。\n        return prefix;\n    }\n    /**\n       * 文字を打つたびに各行についてこの関数が呼ばれる。'start'を返した行はfold可能な範囲の先頭の行になる。\n       * @param {Session} session\n       * @param {string} foldStyle\n       * @param {number} row\n       * @returns {'start' | ''}\n       */\n    getFoldWidget({ doc }, foldStyle, row) {\n        // 速度が重要なため正規表現でマッチする。\n        return LanguageFeatures.isBlockStart(doc.getLine(row)) ? 'start' : '';\n    }\n    /**\n       * getFoldWidgetが'start'を返した行に設置されるfold用のボタンが押されたときに呼ばれる。\n       * @param {Session} session\n       * @param {string} foldStyle\n       * @param {number} row\n       * @returns {AceRange | null} foldする範囲\n       */\n    getFoldWidgetRange({ doc }, foldStyle, row) {\n        const pair = this.getBlockStructure(doc.getAllLines().join('\\n')).pairs.find((v) => v[0] === row);\n        if (pair !== undefined) {\n            return new this.AceRange(pair[0], doc.getLine(pair[0]).length, pair[1] - 1, doc.getLine(pair[1] - 1).length);\n        }\n        return null;\n    }\n    /**\n       * @param {AceDocument} doc\n       * @returns {CodeLens[]}\n       */\n    static getCodeLens(doc) {\n        const results = [];\n        for (const [row, line] of Array.from(doc.getAllLines().entries())) {\n            // eslint-disable-next-line no-irregular-whitespace\n            const matches = /^[ 　・\\t]*●テスト:(.+?)(?:とは|$)/.exec(line);\n            if (matches !== null) {\n                results.push({\n                    start: { row },\n                    command: { title: 'テストを実行', id: 'runTest', arguments: [matches[1]] }\n                });\n            }\n        }\n        return results;\n    }\n    /**\n       * @param {string} code\n       * @returns {ReturnType<getBlockStructure>}\n       * @private\n       */\n    getBlockStructure(code) {\n        // キャッシュ\n        if (!this.blockStructure || this.blockStructure.code !== code) {\n            // @ts-ignore\n            this.blockStructure = { code, data: getBlockStructure(code) };\n        }\n        return this.blockStructure.data;\n    }\n}\n/**\n * 複数ファイルを表示するための最低限のAPIを提供する。\n * @typedef {{ content: string, cursor: { range: AceRange, reversed: boolean }, scroll: { top: number, left: number }, undoManger: any }} EditorTabState\n */\nclass EditorTabs {\n    /**\n       * @param {AceEditor} editor\n       * @param {TypeofAceRange} AceRange\n       * @param {any} UndoManager\n       */\n    constructor(editor, AceRange, UndoManager) {\n        this.editor = editor;\n        this.AceRange = AceRange;\n        this.UndoManager = UndoManager;\n    }\n    /** @param {string} content @returns {EditorTabState} */\n    newTab(content) {\n        return {\n            content,\n            cursor: { range: new this.AceRange(0, 0, 0, 0), reversed: false },\n            scroll: { left: 0, top: 0 },\n            undoManger: new this.UndoManager()\n        };\n    }\n    /** @returns {EditorTabState} */\n    getTab() {\n        return {\n            content: this.editor.getValue(),\n            cursor: { range: this.editor.session.selection.getRange(), reversed: this.editor.session.selection.isBackwards() },\n            scroll: { left: this.editor.session.getScrollLeft(), top: this.editor.session.getScrollTop() },\n            undoManger: this.editor.session.getUndoManager()\n        };\n    }\n    /** @param {EditorTabState} state */\n    setTab(state) {\n        this.editor.setValue(state.content);\n        this.editor.session.selection.setRange(state.cursor.range, state.cursor.reversed);\n        this.editor.session.setScrollLeft(state.scroll.left);\n        this.editor.session.setScrollTop(state.scroll.top);\n        this.editor.session.setUndoManager(state.undoManger);\n    }\n}\nclass Options {\n    /** @param {AceEditor} editor */\n    static save(editor) {\n        try {\n            /** @type {any} */\n            const obj = {};\n            for (const key of ['syntaxHighlighting', 'keyboardHandler', 'theme', 'fontSize', 'wrap', 'useSoftTabs', 'tabSize', 'showInvisibles', 'enableLiveAutocompletion', 'indentedSoftWrap', 'underlineJosi']) {\n                obj[key] = editor.getOption(key);\n            }\n            localStorage.setItem('nako3EditorOptions', JSON.stringify(obj));\n        }\n        catch (e) {\n            // JSON.stringify のエラー、localStorageのエラーなど\n            console.error(e);\n            return null;\n        }\n    }\n    /** @param {AceEditor} editor */\n    static load(editor) {\n        try {\n            if (!window.localStorage) {\n                return null;\n            }\n            const text = window.localStorage.getItem('nako3EditorOptions');\n            if (text === null) {\n                return null;\n            }\n            const json = JSON.parse(text);\n            if (['ace/keyboard/vscode', 'ace/keyboard/emacs', 'ace/keyboard/sublime', 'ace/keyboard/vim'].includes(json.keyboardHandler)) {\n                editor.setOption('keyboardHandler', json.keyboardHandler);\n            }\n            if (['ace/theme/xcode', 'ace/theme/monokai'].includes(json.theme)) {\n                editor.setOption('theme', json.theme);\n            }\n            if (typeof json.fontSize === 'number') {\n                editor.setOption('fontSize', Math.min(48, Math.max(6, json.fontSize)));\n            }\n            for (const key of ['syntaxHighlighting', 'wrap', 'useSoftTabs', 'showInvisibles', 'enableLiveAutocompletion', 'indentedSoftWrap', 'underlineJosi']) {\n                if (typeof json[key] === 'boolean') {\n                    editor.setOption(key, json[key]);\n                }\n            }\n            if (typeof json.tabSize === 'number') {\n                editor.setOption('tabSize', Math.min(16, Math.max(0, json.tabSize)));\n            }\n        }\n        catch (e) {\n            // JSONのパースエラー、localStorageのエラーなど\n            console.error(e);\n            return null;\n        }\n    }\n    /**\n       * OptionPanelクラスをなでしこ用に書き換える。\n       * @param {any} OptionPanel\n       * @param {AceEditor} editor\n       */\n    static initPanel(OptionPanel, editor) {\n        const panel = new OptionPanel(editor); // editorはエラーが飛ばなければ何でも良い\n        // ページ内で一度だけ呼ぶ\n        if (this.done) {\n            return;\n        }\n        this.done = true;\n        // renderメソッドを呼ぶとrenderOptionGroupにoptionGroups.Main、optionGroups.More が順に渡されることを利用して、optionGroupsを書き換える。\n        let isMain = true;\n        panel.renderOptionGroup = (group) => {\n            if (isMain) { // Main\n                for (const key of Object.keys(group)) {\n                    delete group[key];\n                }\n                // スマートフォンでも見れるように、文字数は最小限にする\n                group['シンタックスハイライト'] = {\n                    path: 'syntaxHighlighting'\n                };\n                group['キーバインド'] = {\n                    path: 'keyboardHandler',\n                    type: 'select',\n                    items: [\n                        { caption: 'VSCode', value: 'ace/keyboard/vscode' },\n                        { caption: 'Emacs', value: 'ace/keyboard/emacs' },\n                        { caption: 'Sublime', value: 'ace/keyboard/sublime' },\n                        { caption: 'Vim', value: 'ace/keyboard/vim' }\n                    ]\n                };\n                group['カラーテーマ'] = {\n                    path: 'theme',\n                    type: 'select',\n                    items: [\n                        { caption: 'ライト', value: 'ace/theme/xcode' },\n                        { caption: 'ダーク', value: 'ace/theme/monokai' }\n                    ]\n                };\n                group['文字サイズ'] = {\n                    path: 'fontSize',\n                    type: 'number',\n                    defaultValue: 16\n                };\n                group['行の折り返し'] = {\n                    path: 'wrap',\n                    type: 'select',\n                    items: [\n                        { caption: 'なし', value: 'off' },\n                        { caption: 'あり', value: 'free' }\n                    ]\n                };\n                group['ソフトタブ'] = [{\n                        path: 'useSoftTabs'\n                    }, {\n                        ariaLabel: 'Tab Size',\n                        path: 'tabSize',\n                        type: 'number',\n                        values: [2, 3, 4, 8, 16]\n                    }];\n                group['空白文字を表示'] = {\n                    path: 'showInvisibles'\n                };\n                group['常に自動補完'] = {\n                    path: 'enableLiveAutocompletion'\n                };\n                group['折り返した行をインデント'] = {\n                    path: 'indentedSoftWrap'\n                };\n                group['助詞に下線を引く'] = {\n                    path: 'underlineJosi'\n                };\n                isMain = false;\n            }\n            else { // More\n                for (const key of Object.keys(group)) {\n                    delete group[key];\n                }\n            }\n        };\n        panel.render();\n        // 設定メニューは ace/ext/settings_menu.js の showSettingsMenu 関数によって開かれる。\n        // showSettingsMenu 関数は new OptionPanel(editor).render() で新しい設定パネルのインスタンスを生成するため、\n        // renderメソッドを上書きすることで、生成されたインスタンスにアクセスできる。\n        const render = OptionPanel.prototype.render;\n        const self = globalThis;\n        OptionPanel.prototype.render = function (...args) {\n            render.apply(this, ...args); // 元の処理\n            // OptionPanel.setOption() で発火される setOption イベントをキャッチする\n            this.on('setOption', () => {\n                console.log('設定を保存しました。');\n                self.save(this.editor);\n            });\n        };\n    }\n}\n/**\n * ace/ext/language_tools の設定がグローバル変数で保持されているため、こちら側でもグローバル変数で管理しないと、エディタが複数あるときに正しく動かない。\n * - captionはオートコンプリートの候補として表示されるテキスト\n * - metaはcaptionのテキストの右に薄く表示されるテキスト\n * - docHTMLはその更に右に独立したウィンドウで表示されるHTMLによる説明\n * - valueは決定したときに実際に挿入される文字列。プレースホルダーを配置するなら代わりにsnippetに値を設定する。\n *\n * @typedef {{\n *     getCompletions(\n *         editor: any,\n *         session: Session,\n *         pos: { row: number, column: number },\n *         prefix: any,\n *         callback: (\n *             a: null,\n *             b: { meta: string, caption: string, value?: string, score: number, docHTML?: string, snippet?: string }[]\n *         ) => void\n *     ): void\n *     getDocTooltip?(item: any): void\n * }} Completer\n * @type {Completer[]}\n */\nconst completers = [];\nlet editorIdCounter = 0;\n/**\n * 指定したidのHTML要素をなでしこ言語のエディタにする。\n *\n * - ace editor がグローバルに読み込まれている必要がある。\n * - wnako3_editor.css を読み込む必要がある。\n * - readonly にするには data-nako3-readonly=\"true\" を設定する。\n * - エラー位置の表示を無効化するには data-nako3-disable-marker=\"true\" を設定する。\n * - 縦方向にリサイズ可能にするには nako3-resizable=\"true\" を設定する。\n * - デバイスが遅いときにシンタックスハイライトを無効化する機能を切るには nako3-force-syntax-highlighting=\"true\" を設定する。\n *\n * @param {string | Element} idOrElement HTML要素\n * @param {import('./wnako3')} nako3\n * @param {any} ace\n */\nfunction setupEditor(idOrElement, nako3, ace) {\n    /** @type {AceEditor} */\n    const editor = ace.edit(idOrElement);\n    const element = typeof idOrElement === 'string' ? document.getElementById(idOrElement) : idOrElement;\n    if (element === null) {\n        throw new Error(`idが ${idOrElement} のHTML要素は存在しません。`);\n    }\n    /** @type {TypeofAceRange} */\n    const AceRange = ace.require('ace/range').Range;\n    const editorMarkers = new EditorMarkers(editor.session, editor.session.bgTokenizer.doc, AceRange, !!element.dataset.nako3DisableMarker);\n    if (element.classList.contains('nako3_ace_mounted')) {\n        // 同じエディタを誤って複数回初期化すると、ace editor の挙動を書き換えているせいで\n        // 意図しない動作をしたため、すでにエディタとして使われていないことを確認する。\n        throw new Error('なでしこ言語のエディタの初期化処理を同一のHTML要素に対して複数回適用しました。');\n    }\n    // lang=\"ja\" があると表示がずれる問題の修正 #839\n    element.setAttribute('lang', 'en');\n    // 以前のバージョンではnako3_editorをhtmlに直接付けていたため、互換性のためnako3_editorとは別のクラス名を使用する。\n    element.classList.add('nako3_ace_mounted');\n    element.classList.add('nako3_editor'); // CSSのため\n    const readonly = element.dataset.nako3Readonly;\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!readonly) {\n        element.classList.add('readonly');\n        editor.setReadOnly(true);\n    }\n    editor.setFontSize(16);\n    /** @param {Session} session */\n    const resetEditorTokens = (session) => {\n        // 一旦テキスト全体を消してから、元に戻す\n        /** @type {AceDocument} */\n        const doc = session.doc;\n        const lines = doc.getAllLines();\n        const range = session.selection.getRange();\n        doc.removeFullLines(0, doc.getLength());\n        doc.insert({ row: 0, column: 0 }, lines.join('\\n'));\n        session.selection.setRange(range, false);\n    };\n    ace.require('ace/config').defineOptions(editor.constructor.prototype, 'editor', {\n        syntaxHighlighting: {\n            /** @type {(this: AceEditor, value: boolean) => void} */\n            set: function (value) {\n                this.session.bgTokenizer.enabled = value;\n                resetEditorTokens(this.session);\n            },\n            initialValue: true\n        },\n        underlineJosi: {\n            /** @type {(this: AceEditor, value: boolean) => void} */\n            set: function (value) {\n                this.session.bgTokenizer.underlineJosi = value;\n                resetEditorTokens(this.session);\n            },\n            initialValue: true\n        }\n    });\n    editor.setOptions({\n        wrap: 'free',\n        indentedSoftWrap: false,\n        showPrintMargin: false\n    });\n    ace.require('ace/keybindings/vscode');\n    editor.setKeyboardHandler('ace/keyboard/vscode');\n    // ドキュメントのホバー\n    const Tooltip = ace.require('ace/tooltip').Tooltip;\n    const tooltip = new Tooltip(editor.container);\n    const event = ace.require('ace/lib/event');\n    event.addListener(editor.renderer.content, 'mouseout', () => {\n        // マウスカーソルがエディタの外に出たら、tooltipを隠す\n        tooltip.hide();\n    });\n    editor.on('mousemove', (e) => {\n        // マウスカーソルがトークンに重なったときにtooltipを表示する。モバイル端末の場合はトークンにカーソルが当たったときに表示される。\n        const pos = e.getDocumentPosition();\n        // getTokenAtはcolumnが行末より大きいとき行末のトークンを返してしまう。\n        if (pos.column >= e.editor.session.getLine(pos.row).length) {\n            tooltip.hide();\n            return;\n        }\n        // getTokenAtは実際よりも1文字右のトークンを取得してしまうため、columnに1を足している。\n        /** @type {EditorToken} */\n        const token = e.editor.session.getTokenAt(pos.row, pos.column + 1);\n        if (token === null || !token.docHTML) {\n            // ドキュメントが存在しないトークンならtooltipを表示しない\n            tooltip.hide();\n            return;\n        }\n        tooltip.setHtml(token.docHTML);\n        tooltip.show(null, e.clientX, e.clientY);\n    });\n    editor.session.on('change', () => {\n        // モバイル端末でドキュメントが存在するトークンを編集するときにツールチップが消えない問題を解消するために、文字を打ったらtooltipを隠す。\n        tooltip.hide();\n        // 文字入力したらマーカーを消す\n        editorMarkers.clear();\n    });\n    const forceSyntaxHighlighting = !!element.dataset.nako3ForceSyntaxHighlighting;\n    let isFirstTime = true;\n    const oldBgTokenizer = editor.session.bgTokenizer;\n    const backgroundTokenizer = new BackgroundTokenizer(editor.session.bgTokenizer.doc, nako3, (firstRow, lastRow, ms) => {\n        oldBgTokenizer._signal('update', { data: { first: firstRow, last: lastRow } });\n        // 処理が遅い場合シンタックスハイライトを無効化する。\n        if (ms > 220 && editor.getOption('syntaxHighlighting') && !readonly && !forceSyntaxHighlighting && isFirstTime) {\n            isFirstTime = false;\n            slowSpeedMessage.classList.add('visible');\n            editor.setOption('syntaxHighlighting', false);\n            setTimeout(() => {\n                slowSpeedMessage.classList.remove('visible');\n            }, 13000);\n        }\n    }, (code, err) => { editorMarkers.addByError(code, err, 'error'); }, \n    /** @type {boolean} */ (editor.getOption('underlineJosi')));\n    // オートコンプリートを有効化する\n    editor.setOptions({\n        enableBasicAutocompletion: true,\n        enableSnippets: true,\n        enableLiveAutocompletion: true\n    });\n    const editorId = editorIdCounter++;\n    editor.wnako3EditorId = editorId;\n    // オートコンプリートのcompleterを設定する\n    completers.push({\n        getCompletions(editor, session, pos, prefix, callback) {\n            if (editor.wnako3EditorId !== editorId) {\n                callback(null, []);\n            }\n            else {\n                const items = LanguageFeatures.getCompletionItems(pos.row, prefix, nako3, backgroundTokenizer);\n                // 完全に一致する候補があればオートコンプリートしない。（Aceエディタでの挙動が微妙なため。）\n                if (items.some((v) => v.value === prefix)) {\n                    callback(null, []);\n                    return;\n                }\n                callback(null, items);\n            }\n        }\n    }, { getCompletions(editor, session, pos, prefix, callback) { callback(null, (editor.wnako3EditorId !== editorId) ? [] : LanguageFeatures.getSnippets(editor.session.doc.getAllLines().join('\\n'))); } });\n    ace.require('ace/ext/language_tools').setCompleters(completers);\n    // オートコンプリートの単語の区切りが日本語に対応していないため、メソッドを上書きして対応させる。\n    // 文字を入力するたびに呼ばれ、''以外を返すとその文字列をもとにしてautocompletionが始まる。\n    ace.require('ace/autocomplete/util').getCompletionPrefix = (/** @type {AceEditor} */ editor) => {\n        const pos = editor.getCursorPosition();\n        return LanguageFeatures.getCompletionPrefix(editor.session.doc.getLine(pos.row).slice(0, pos.column), nako3);\n    };\n    // エディタの挙動の設定\n    const languageFeatures = new LanguageFeatures(AceRange, nako3);\n    const oop = ace.require('ace/lib/oop');\n    const TextMode = ace.require('ace/mode/text').Mode;\n    const Mode = function () {\n        this.HighlightRules = new TextMode().HighlightRules;\n        this.foldingRules = {\n            getFoldWidget: languageFeatures.getFoldWidget.bind(languageFeatures),\n            getFoldWidgetRange: languageFeatures.getFoldWidgetRange.bind(languageFeatures)\n        };\n    };\n    oop.inherits(Mode, TextMode);\n    Mode.prototype.toggleCommentLines = LanguageFeatures.toggleCommentLines.bind(LanguageFeatures);\n    Mode.prototype.getNextLineIndent = LanguageFeatures.getNextLineIndent.bind(LanguageFeatures);\n    Mode.prototype.checkOutdent = LanguageFeatures.checkOutdent.bind(LanguageFeatures);\n    Mode.prototype.autoOutdent = languageFeatures.autoOutdent.bind(languageFeatures);\n    editor.session.setMode(new Mode());\n    // tokenizer （シンタックスハイライト）の上書き\n    editor.session.bgTokenizer.stop();\n    editor.session.bgTokenizer = backgroundTokenizer;\n    editor.setTheme('ace/theme/xcode');\n    // 設定メニューの上書き\n    // なでしこ用に上書きした設定の削除やテキストの和訳をする。\n    Options.load(editor);\n    const OptionPanel = ace.require('ace/ext/options').OptionPanel;\n    Options.initPanel(OptionPanel, editor);\n    // 右下のボタン全体を囲むdiv\n    const buttonContainer = document.createElement('div');\n    buttonContainer.classList.add('button-container');\n    editor.container.appendChild(buttonContainer);\n    // 遅い端末へのメッセージのボタン\n    const slowSpeedMessage = document.createElement('span');\n    slowSpeedMessage.classList.add('slow-speed-message');\n    slowSpeedMessage.innerHTML = '<span>エディタの|応答速度が|低下したため|シンタックス|ハイライトを|無効化|しました。</span>'.replace(/\\|/g, '</span><span>');\n    buttonContainer.appendChild(slowSpeedMessage);\n    // テストの定義の上に「テストを実行」ボタンを表示する\n    /** @type {{ name: 'test', callback: (testName: string | undefined) => void }[]} */\n    const codeLensListeners = [];\n    try {\n        const CodeLens = ace.require('ace/ext/code_lens');\n        editor.setOption('enableCodeLens', true);\n        editor.commands.addCommand({\n            name: 'runTest',\n            exec: (/** @type {AceEditor} */ editor, /** @type {any[]} */ args) => {\n                codeLensListeners\n                    .filter((v) => v.name === 'test')\n                    .forEach((f) => f.callback(args[0]));\n            }\n        });\n        CodeLens.registerCodeLensProvider(editor, {\n            provideCodeLenses: (/** @type {Session} */ session, /** @type {(_: null, arr: CodeLens[]) => void} */ callback) => {\n                callback(null, codeLensListeners.some((v) => v.name === 'test') ? LanguageFeatures.getCodeLens(session.doc) : []);\n            }\n        });\n    }\n    catch (e) {\n        console.error(e); // ext/code_lens のscriptタグが読み込まれていない場合など。\n    }\n    // 「全画面表示」ボタン\n    const exitFullscreen = () => {\n        editor.container.classList.remove('fullscreen');\n        editor.renderer.setScrollMargin(0, 0, 0, 0); // marginを元に戻す\n    };\n    const fullscreenButton = document.createElement('span');\n    fullscreenButton.classList.add('editor-button');\n    fullscreenButton.innerText = '全画面表示';\n    fullscreenButton.addEventListener('click', (e) => {\n        if (editor.container.classList.contains('fullscreen')) {\n            exitFullscreen();\n        }\n        else {\n            editor.container.classList.add('fullscreen');\n            editor.renderer.setScrollMargin(20, 20, 0, 0); // 上下に少し隙間を開ける\n        }\n        e.preventDefault();\n    });\n    buttonContainer.appendChild(fullscreenButton);\n    // 「設定を開く」ボタン\n    const settingsButton = document.createElement('span');\n    settingsButton.classList.add('editor-button');\n    settingsButton.innerText = '設定を開く';\n    settingsButton.addEventListener('click', (e) => {\n        exitFullscreen();\n        editor.execCommand('showSettingsMenu');\n        e.preventDefault();\n    });\n    buttonContainer.appendChild(settingsButton);\n    // 複数ファイルの切り替え\n    const UndoManager = ace.require('ace/undomanager').UndoManager;\n    const editorTabs = new EditorTabs(editor, AceRange, UndoManager);\n    // リサイズ可能にする\n    const resizable = element.dataset.nako3Resizable;\n    if (resizable) {\n        new MutationObserver(() => { editor.resize(); }).observe(editor.container, { attributes: true });\n        editor.renderer.setScrollMargin(4, 0, 4, 0);\n        editor.container.classList.add('resizable');\n    }\n    const retokenize = () => { backgroundTokenizer.dirty = true; };\n    /**\n       * プログラムを実行して、エラーがあればエディタ上に波線を表示する。出力はoutputContainerに表示する。\n       * methodが'test'のとき、testNameを指定すると1つのテストだけ実行できる。\n       * @param {{\n       *     outputContainer?: HTMLElement\n       *     file?: string\n       *     preCode?: string\n       *     localFiles?: Record<string, string>\n       *     method?: 'run' | 'test' | 'compile'\n       *     testName?: string\n       * }} opts\n       */\n    const run = (opts) => {\n        const code = editor.getValue();\n        const preCode = opts.preCode || ''; // プログラムの前に自動的に挿入されるコード\n        // loggerを新しいインスタンスに置き換える。そうしないとどのエディタで起きたエラー（や警告や出力）なのかが分からない。\n        const logger = nako3.replaceLogger();\n        if (opts.outputContainer) {\n            const c = opts.outputContainer;\n            logger.addListener('info', ({ html }) => {\n                if (!c) {\n                    console.log(html);\n                }\n                c.style.display = 'block';\n                c.innerHTML += html;\n            });\n            opts.outputContainer.classList.add('nako3-output-container');\n        }\n        let filename = opts.file || 'main.nako3';\n        // 警告とエラーをエディタ上に表示する。\n        logger.addListener('info', ({ position, noColor, level }) => {\n            if (position && (position.file === filename && (level === 'warn' || level === 'error'))) {\n                editorMarkers.addByError(code, { ...position, message: noColor }, level);\n            }\n        });\n        // 依存ファイルを読み込む。\n        const promise = nako3.loadDependencies(preCode + code, filename, preCode, opts.localFiles || {})\n            .then(() => {\n            // プログラムを実行する。\n            if (!filename) {\n                filename = 'main.nako3';\n            }\n            if (opts.method === 'test') {\n                return nako3.test(preCode + code, filename, preCode, opts.testName);\n            }\n            else if (opts.method === 'compile') {\n                return nako3.compile(preCode + code, filename, false, preCode);\n            }\n            else {\n                const opt = { resetEnv: true, resetAll: true };\n                return nako3.runEx(preCode + code, filename, opt, preCode);\n            }\n        })\n            .catch((err) => {\n            // エラーはloggerに送られるため何もしなくて良い\n            // しかし念のため console.error で出力\n            console.error('[wnako3_editor]', err);\n        })\n            .then(async (res) => {\n            // 読み込んだ依存ファイルの情報を使って再度シンタックスハイライトする。\n            retokenize();\n            // シンタックスハイライトが終わるのを待つ\n            while (backgroundTokenizer.dirty) {\n                await new Promise((resolve) => setTimeout(resolve, 0));\n            }\n            return res;\n        })\n            .catch((err) => {\n            console.error('[wnako3_editor::run::promise::catch]', err);\n        });\n        return { promise, logger, code };\n    };\n    return { editor, editorMarkers, editorTabs, retokenize, run, codeLensListeners };\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    tokenize,\n    setupEditor,\n    LanguageFeatures,\n    EditorMarkers,\n    BackgroundTokenizer\n});\n\n\n//# sourceURL=webpack://nadesiko3/./src/wnako3_editor.mjs?")},"./src/wnako3mod.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebNakoCompiler\": function() { return /* binding */ WebNakoCompiler; }\n/* harmony export */ });\n/* harmony import */ var _core_src_nako3_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/src/nako3.mjs */ \"./core/src/nako3.mjs\");\n/* harmony import */ var _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/src/nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _wnako3_editor_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wnako3_editor.mjs */ \"./src/wnako3_editor.mjs\");\n/* harmony import */ var _nako_version_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nako_version.mjs */ \"./src/nako_version.mjs\");\n/* harmony import */ var _plugin_browser_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugin_browser.mjs */ \"./src/plugin_browser.mjs\");\n// wnako3mod - nadesiko for web browser\n// - wnako3 から wnako3mod を取り込む。\n// - このファイルはモジュールとして別のファイルから取り込み可能。\n\n\n\n\n\nconst NAKO_SCRIPT_RE = /^(なでしこ|nako|nadesiko)3?$/;\nclass WebNakoCompiler extends _core_src_nako3_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoCompiler {\n    constructor() {\n        super({ useBasicPlugin: true });\n        this.wnakoVersion = _nako_version_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        // プラグインを追加\n        this.addPluginObject('PluginBrowser', _plugin_browser_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n        // 必要な定数を設定\n        this.addListener('beforeRun', (g) => {\n            g.__varslist[0]['ナデシコ種類'] = 'wnako3';\n            g.__varslist[0]['ナデシコバージョン'] = _nako_version_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].version;\n        });\n    }\n    /**\n     * ブラウザでtype=\"なでしこ\"というスクリプトを得て実行する\n     */\n    async runNakoScript() {\n        // スクリプトタグの中身を得る\n        let nakoScriptCount = 0;\n        const scripts = document.querySelectorAll('script');\n        for (let i = 0; i < scripts.length; i++) {\n            const script = scripts[i];\n            if (script.type.match(NAKO_SCRIPT_RE)) {\n                nakoScriptCount++;\n                // URLからスクリプト名を見つける\n                const url = (typeof (window.location) === 'object') ? window.location.href : 'url_unknown';\n                const fname = `${url}#script${nakoScriptCount}.nako3`;\n                const code = script.text;\n                // 依存するライブラリをロード\n                await this.loadDependencies(code, fname);\n                // プログラムを実行\n                await this.runAsync(script.text, fname);\n            }\n        }\n        if (nakoScriptCount > 1) {\n            console.log('実行したなでしこの個数=', nakoScriptCount);\n        }\n    }\n    /**\n     * @this {WebNakoCompiler}\n     * @param {string} code\n     * @param {string} filename\n     * @param {string} [preCode]\n     * @param {Record<string, string>} [localFiles]\n     * @returns {Promise<unknown>}\n     */\n    async loadDependencies(code, filename, preCode = '', localFiles = {}) {\n        return this._loadDependencies(code, filename, preCode, {\n            readJs: (filePath, token) => {\n                if (Object.prototype.hasOwnProperty.call(localFiles, filePath)) {\n                    return {\n                        task: (async () => () => {\n                            // eslint-disable-next-line no-new-func\n                            Function(localFiles[filePath])();\n                            return {};\n                        })()\n                    };\n                }\n                return {\n                    task: (async () => {\n                        const res = await fetch(filePath);\n                        if (!res.ok) {\n                            throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`ファイル『${filePath}』のダウンロードに失敗しました: ${res.status} ${res.statusText}`, token.file, token.line);\n                        }\n                        const text = await res.text();\n                        if (!text.includes('navigator.nako3.addPluginObject')) {\n                            throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`ファイル ${filePath} の中に文字列 \"navigator.nako3.addPluginObject\" が存在しません。現在、ブラウザ版のなでしこ言語v3は自動登録するプラグインのみをサポートしています。`, token.file, token.line);\n                        }\n                        // textの例: `navigator.nako3.addPluginObject('PluginRequireTest', { requiretest: { type: 'var', value: 100 } })`\n                        return () => {\n                            // プラグインの自動登録は navigator.nako3 を参照するため、 navigator.nako3 を一時的に現在のインスタンスにする。\n                            const globalNavigator = navigator;\n                            const globalNako3 = globalNavigator.nako3;\n                            globalNavigator.nako3 = this;\n                            try {\n                                // eslint-disable-next-line no-new-func\n                                Function(text)();\n                            }\n                            catch (err) {\n                                throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`プラグイン ${filePath} の取り込みに失敗: ${err instanceof Error ? err.message : err + ''}`, token.file, token.line);\n                            }\n                            finally {\n                                globalNavigator.nako3 = globalNako3;\n                            }\n                            return {};\n                        };\n                    })()\n                };\n            },\n            readNako3: (filePath, token) => {\n                if (Object.prototype.hasOwnProperty.call(localFiles, filePath)) {\n                    return {\n                        task: (() => {\n                            return (new Promise((resolve, reject) => {\n                                const s = localFiles[filePath];\n                                resolve(s);\n                            }));\n                        })()\n                    };\n                }\n                return {\n                    task: (async () => {\n                        const res = await fetch(filePath);\n                        if (!res.ok) {\n                            throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`ファイル ${filePath} のダウンロードに失敗しました: ${res.status} ${res.statusText}`, token.file, token.line);\n                        }\n                        return await res.text();\n                    })()\n                };\n            },\n            resolvePath: (name, token, fromFile) => {\n                let pathname = name;\n                // http から始まっていれば解決は不要\n                if (pathname.startsWith('http://') || pathname.startsWith('https://')) {\n                    // fullpath\n                }\n                else {\n                    // ローカルにファイルが存在するならそれを使う。そうでなければURLとして解釈する。\n                    if (!Object.prototype.hasOwnProperty.call(localFiles, name)) {\n                        try {\n                            pathname = new URL(name).pathname;\n                        }\n                        catch (e) {\n                            // 単純にパスに変換できなければ、location.hrefを参考にパスを組み立てる\n                            try {\n                                let baseDir = dirname(fromFile);\n                                if (baseDir === '') {\n                                    // https://2/3/4.html\n                                    const a = window.location.href.split('/');\n                                    baseDir = '/' + a.slice(3, a.length - 1).join('/');\n                                }\n                                pathname = resolveURL(baseDir, name);\n                            }\n                            catch (e) {\n                                throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`取り込み文の引数でパスが解決できません。https:// か http:// で始まるアドレスを指定してください。\\n${e}`, token.file, token.line);\n                            }\n                        }\n                    }\n                    else {\n                        pathname = localFiles[name];\n                    }\n                }\n                // .js および .mjs なら JSプラグイン\n                if (pathname.endsWith('.js') || pathname.endsWith('.js.txt') || pathname.endsWith('.mjs') || pathname.endsWith('.mjs.txt')) {\n                    return { filePath: pathname, type: 'js' };\n                }\n                // .nako3 なら なでしこ3プラグイン\n                if (pathname.endsWith('.nako3') || pathname.endsWith('.nako3.txt')) {\n                    return { filePath: pathname, type: 'nako3' };\n                }\n                // ファイル拡張子が未指定の場合\n                throw new _core_src_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoImportError(`ファイル『${name}』は拡張子が(.nako3|.js|.js.txt|.mjs|.mjs.txt)以外なので取り込めません。`, token.file, token.line);\n            }\n        });\n    }\n    /**\n     * type=なでしこ のスクリプトを自動実行するべきかどうかを返す\n     * @returns type=なでしこ のスクリプトを自動実行するべきかどうか\n     */\n    checkScriptTagParam() {\n        const scripts = document.querySelectorAll('script');\n        for (let i = 0; i < scripts.length; i++) {\n            const script = scripts[i];\n            const src = script.src || '';\n            if (src.indexOf('wnako3.js?run') >= 0 ||\n                src.indexOf('wnako3.js&run') >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * 指定したidのHTML要素をなでしこ言語のエディタにする。\n     * @param {string | Element} idOrElement HTML要素\n     * @see {setupEditor}\n     */\n    setupEditor(idOrElement) {\n        return (0,_wnako3_editor_mjs__WEBPACK_IMPORTED_MODULE_2__.setupEditor)(idOrElement, this, window.ace);\n    }\n}\nfunction dirname(s) {\n    const a = s.split('/');\n    if (a && a.length > 1) {\n        return a.slice(0, a.length - 1).join('/');\n    }\n    return '';\n}\nfunction resolveURL(base, s) {\n    const baseA = base.split('/');\n    const sA = s.split('/');\n    for (const p of sA) {\n        if (p === '') {\n            continue;\n        }\n        if (p === '.') {\n            continue;\n        }\n        if (p === '..') {\n            baseA.pop();\n            continue;\n        }\n        baseA.push(p);\n    }\n    return baseA.join('/');\n}\n\n\n//# sourceURL=webpack://nadesiko3/./src/wnako3mod.mjs?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=function(n,e){for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},__webpack_require__.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/wnako3.mjs")})();