/*! For license information please see nako_gen_async.js.LICENSE.txt */
(function(){"use strict";var __webpack_modules__={"./core/src/nako_core_version.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n// 実際のバージョン定義 (自動生成されるので以下を編集しない)\nconst coreVersion = {\n    version: '3.3.52',\n    major: 3,\n    minor: 3,\n    patch: 52\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (coreVersion);\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_core_version.mjs?")},"./core/src/nako_errors.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InternalLexerError\": function() { return /* binding */ InternalLexerError; },\n/* harmony export */   \"NakoError\": function() { return /* binding */ NakoError; },\n/* harmony export */   \"NakoImportError\": function() { return /* binding */ NakoImportError; },\n/* harmony export */   \"NakoIndentError\": function() { return /* binding */ NakoIndentError; },\n/* harmony export */   \"NakoLexerError\": function() { return /* binding */ NakoLexerError; },\n/* harmony export */   \"NakoRuntimeError\": function() { return /* binding */ NakoRuntimeError; },\n/* harmony export */   \"NakoSyntaxError\": function() { return /* binding */ NakoSyntaxError; }\n/* harmony export */ });\n/* harmony import */ var _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_core_version.mjs */ \"./core/src/nako_core_version.mjs\");\n\n/**\n * なでしこ言語が投げる全てのエラーが継承するクラス\n */\nclass NakoError extends Error {\n    /**\n     * @param {string} tag\n     * @param {string} msg\n     * @param {string | undefined} file\n     * @param {number | undefined} line\n     */\n    constructor(tag, msg, file = undefined, line = undefined) {\n        // エラー位置を分かりやすく日本語に変換\n        const positionJa = `${file || ''}${line === undefined ? '' : `(${line + 1}行目): `}`;\n        // #1223 エラーメッセージに「main__関数名」と表示されるので、main__は省略して表示\n        msg = msg.replace(/『main__(.+?)』/g, '『$1』');\n        // 親のErrorを呼ぶ\n        super(`[${tag}]${positionJa}${msg}\\n[バージョン] ${_nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].version}`);\n        // エラーの種類を設定\n        this.name = 'NakoError';\n        this.type = 'NakoError';\n        this.tag = '[' + tag + ']';\n        this.positionJa = positionJa;\n        this.msg = msg;\n    }\n}\nclass NakoIndentError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number} line\n     * @param {string} file\n     */\n    constructor(msg, line, file) {\n        super('インデントエラー', msg, file, line);\n        this.type = 'NakoIndentError';\n        this.line = line;\n        this.file = file;\n    }\n}\n// コンパイラの内部でのみ使うエラー。投げられたらtryでキャッチしてLexerErrorへ変更する。\nclass InternalLexerError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number} preprocessedCodeStartOffset\n     * @param {number} preprocessedCodeEndOffset\n     * @param {number | undefined} [line]\n     * @param {string | undefined} [file]\n     */\n    constructor(msg, preprocessedCodeStartOffset, preprocessedCodeEndOffset, line, file) {\n        super('字句解析エラー（内部エラー）', msg, file, line);\n        this.type = 'InternalLexerError';\n        this.preprocessedCodeStartOffset = preprocessedCodeStartOffset;\n        this.preprocessedCodeEndOffset = preprocessedCodeEndOffset;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoLexerError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number | null} startOffset\n     * @param {number | null} endOffset,\n     * @param {number | undefined} line\n     * @param {string | undefined} file\n     */\n    constructor(msg, startOffset, endOffset, line, file) {\n        super('字句解析エラー', msg, file, line);\n        this.type = 'NakoLexerError';\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoSyntaxError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {number | undefined} line\n     * @param {number | undefined} startOffset\n     * @param {number | undefined} endOffset\n     * @param {string | undefined} file\n     */\n    constructor(msg, line, startOffset, endOffset, file) {\n        super('文法エラー', msg, file, line);\n        this.type = 'NakoSyntaxError';\n        this.file = file;\n        this.line = line;\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n    }\n    /**\n     * @param {string} msg\n     * @param {Ast} first\n     * @param {Ast} [last]\n     */\n    static fromNode(msg, first, last = undefined) {\n        if (!first) {\n            return new NakoSyntaxError(msg, undefined, undefined, undefined, undefined);\n        }\n        const startOffset = typeof first.startOffset === 'number' ? first.startOffset : undefined;\n        const endOffset = (last && typeof last.endOffset === 'number')\n            ? last.endOffset\n            : (typeof first.endOffset === 'number' ? first.endOffset : undefined);\n        return new NakoSyntaxError(msg, first.line, startOffset, endOffset, first.file);\n    }\n}\nclass NakoRuntimeError extends NakoError {\n    /**\n     * @param error エラー\n     * @param lineNo 発生行\n     */\n    constructor(error, lineNo) {\n        let msg = 'unknown';\n        if (typeof error === 'string') {\n            msg = error;\n        }\n        else {\n            if (error instanceof NakoRuntimeError) {\n                msg = error.msg;\n            }\n            else if (error instanceof NakoError) {\n                msg = error.msg;\n            }\n            else if (error instanceof Error) {\n                if (error.name === 'Error') {\n                    msg = error.message;\n                }\n                else {\n                    msg = `${error.name}: ${error.message}`;\n                }\n            }\n        }\n        // 行番号を表す文字列をパースする。\n        let line;\n        let file;\n        let matches;\n        if (lineNo === undefined) {\n            line = undefined;\n            file = undefined;\n            // eslint-disable-next-line no-cond-assign\n        }\n        else if (matches = /^l(-?\\d+):(.*)$/.exec(lineNo)) {\n            line = parseInt(matches[1]);\n            file = matches[2];\n            // eslint-disable-next-line no-cond-assign\n        }\n        else if (matches = /^l(-?\\d+)$/.exec(lineNo)) {\n            line = parseInt(matches[1]);\n            file = 'main.nako3';\n        }\n        else {\n            line = 0;\n            file = lineNo;\n        }\n        super('実行時エラー', msg, file, line);\n        this.type = 'NakoRuntimeError';\n        this.lineNo = lineNo;\n        this.line = line;\n        this.file = file;\n    }\n}\nclass NakoImportError extends NakoError {\n    /**\n     * @param {string} msg\n     * @param {string} file\n     * @param {number} line\n     */\n    constructor(msg, file, line) {\n        super('取り込みエラー', msg, file, line);\n        this.file = file;\n        this.line = line;\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_errors.mjs?")},"./core/src/nako_gen.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoGen\": function() { return /* binding */ NakoGen; },\n/* harmony export */   \"NakoGenOptions\": function() { return /* binding */ NakoGenOptions; },\n/* harmony export */   \"generateJS\": function() { return /* binding */ generateJS; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_lexer.mjs */ \"./core/src/nako_lexer.mjs\");\n/**\n * パーサーが生成した中間オブジェクトを実際のJavaScriptのコードに変換する。\n * なお速度優先で忠実にJavaScriptのコードを生成する。\n */\n\n\n// なでしこで定義した関数の開始コードと終了コード\nconst topOfFunction = '(function(){\\n';\nconst endOfFunction = '})';\nconst topOfFunctionAsync = '(async function(){\\n';\n/** コード生成オプション */\nclass NakoGenOptions {\n    constructor(isTest = false, importFiles = [], codeStandalone = '', convEnv = '') {\n        this.isTest = isTest;\n        this.codeStandalone = codeStandalone;\n        this.codeEnv = convEnv;\n        this.importFiles = ['plugin_system.mjs', 'plugin_math.mjs', 'plugin_csv.mjs', 'plugin_promise.mjs', 'plugin_test.mjs'];\n        for (const fname of importFiles) {\n            this.importFiles.push(fname);\n        }\n    }\n}\n/**\n * 構文木からJSのコードを生成するクラス\n */\nclass NakoGen {\n    /** constructor\n     * @param com コンパイラのインスタンス\n     */\n    constructor(com) {\n        /**\n         * 出力するJavaScriptコードのヘッダー部分で定義する必要のある関数。fnはjsのコード。\n         * プラグイン関数は含まれない。\n         */\n        this.nakoFuncList = { ...com.getNakoFuncList() };\n        /**\n         * なでしこで定義したテストの一覧\n         */\n        this.nakoTestFuncs = {};\n        /**\n         * プログラム内で参照された関数のリスト。プラグインの命令を含む。\n         * JavaScript単体で実行するとき、このリストにある関数の定義をJavaScriptコードの先頭に付け足す。\n         */\n        this.usedFuncSet = new Set();\n        /**\n         * ループ時の一時変数が被らないようにIDで管理\n         */\n        this.loopId = 1;\n        /**\n         * 非同関数を何回使ったか\n         */\n        this.numAsyncFn = 0;\n        /**\n         * 関数定義の際、関数の中でasyncFn=trueの関数を呼び出したかどうかを調べる @see convDefFuncCommon\n         */\n        this.usedAsyncFn = false;\n        /** 変換中の処理が、ループの中かどうかを判定する */\n        this.flagLoop = false;\n        this.__self = com;\n        /** コードジェネレータの種類 */\n        this.genMode = 'sync';\n        /** 行番号とファイル名が分かるときは `l123:main.nako3`、行番号だけ分かるときは `l123`、そうでなければ任意の文字列。 */\n        this.lastLineNo = null;\n        /** スタック */\n        this.varslistSet = com.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        /** スタックトップ */\n        this.varsSet = { isFunction: false, names: new Set(), readonly: new Set() };\n        this.varslistSet[2] = this.varsSet;\n        // 1以上のとき高速化する。\n        // 実行速度優先ブロック内で1増える。\n        this.speedMode = {\n            lineNumbers: 0,\n            implicitTypeCasting: 0,\n            invalidSore: 0,\n            forcePure: 0 // 全てのシステム命令をpureとして扱う。命令からローカル変数への参照が出来なくなる。\n        };\n        // 1以上のとき測定をinjectする。\n        // パフォーマンスモニタのブロック内で1増える。\n        this.performanceMonitor = {\n            userFunction: 0,\n            systemFunction: 0,\n            systemFunctionBody: 0,\n            mumeiId: 0\n        };\n        /**\n         * 未定義の変数の警告を行う\n         */\n        this.warnUndefinedVar = true;\n        // 暫定変数\n        this.warnUndefinedReturnUserFunc = 1;\n        this.warnUndefinedCallingUserFunc = 1;\n        this.warnUndefinedCallingSystemFunc = 1;\n        this.warnUndefinedCalledUserFuncArgs = 1;\n    }\n    static isValidIdentifier(name) {\n        // TODO: いらなそうな部分は削る\n        // https://stackoverflow.com/a/9337047\n        // eslint-disable-next-line no-misleading-character-class\n        return /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/.test(name);\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} forceUpdate\n     */\n    convLineno(node, forceUpdate = false) {\n        if (this.speedMode.lineNumbers > 0) {\n            return '';\n        }\n        let lineNo;\n        if (typeof node.line !== 'number') {\n            lineNo = 'unknown';\n        }\n        else if (typeof node.file !== 'string') {\n            lineNo = `l${node.line}`;\n        }\n        else {\n            lineNo = `l${node.line}:${node.file}`;\n        }\n        // 強制的に行番号をアップデートするか\n        if (!forceUpdate) {\n            if (lineNo === this.lastLineNo) {\n                return '';\n            }\n            this.lastLineNo = lineNo;\n        }\n        // 例: __v0.line='l1:main.nako3'\n        return `__v0.line=${JSON.stringify(lineNo)};`;\n    }\n    /**\n     * ローカル変数のJavaScriptコードを生成する。\n     * @param {string} name\n     */\n    varname(name) {\n        if (this.varslistSet.length === 3) {\n            // グローバル\n            return `__varslist[${2}][${JSON.stringify(name)}]`;\n        }\n        else {\n            // 関数内\n            if (NakoGen.isValidIdentifier(name)) {\n                return name;\n            }\n            else {\n                return `__vars[${JSON.stringify(name)}]`;\n            }\n        }\n    }\n    /**\n     * @param {string} name\n     * @returns {string}\n    */\n    static getFuncName(name) {\n        if (name.indexOf('__') >= 0) { // スコープがある場合\n            const a = name.split('__');\n            const scope = a[0];\n            const name3 = NakoGen.getFuncName(a[1]);\n            return `${scope}__${name3}`;\n        }\n        let name2 = name.replace(/[ぁ-ん]+$/, '');\n        if (name2 === '') {\n            name2 = name;\n        }\n        return name2;\n    }\n    /** @param {Ast} node */\n    static convPrint(node) {\n        return `__print(${node});`;\n    }\n    /** @param {Ast} node */\n    convRequire(node) {\n        const moduleName = node.value;\n        return this.convLineno(node, false) +\n            `__module['${moduleName}'] = require('${moduleName}');\\n`;\n    }\n    /**\n     * プログラムの実行に必要な関数定義を書き出す(グローバル領域)\n     * convGenの結果を利用するため、convGenの後に呼び出すこと。\n     * @param com\n     * @param opt\n     */\n    getDefFuncCode(com, opt) {\n        let code = '';\n        // よく使う変数のショートカット\n        code += `const nakoVersion = { version: ${JSON.stringify(com.version)} }\\n`;\n        code += 'const __self = self;\\n';\n        code += 'self.__self = self;\\n';\n        code += 'const __varslist = self.__varslist;\\n';\n        code += 'const __module = self.__module;\\n';\n        code += 'const __v0 = self.__v0 = self.__varslist[0];\\n';\n        code += 'const __v1 = self.__v1 = self.__varslist[1];\\n';\n        code += 'const __vars = self.__vars = self.__varslist[2];\\n';\n        // なでしこの関数定義を行う\n        let nakoFuncCode = '';\n        for (const key in this.nakoFuncList) {\n            const f = this.nakoFuncList[key].fn;\n            const isAsync = this.nakoFuncList[key].asyncFn ? 'true' : 'false';\n            nakoFuncCode += '' +\n                `//[DEF_FUNC name='${key}' asyncFn=${isAsync}]\\n` +\n                `self.__varslist[1][\"${key}\"]=${f};\\n;` +\n                `//[/DEF_FUNC name='${key}']\\n`;\n        }\n        if (nakoFuncCode !== '') {\n            code += '__v0.line=\\'関数の定義\\';\\n' + nakoFuncCode;\n        }\n        // テストの定義を行う\n        if (opt.isTest) {\n            let testCode = 'const __tests = [];\\n';\n            for (const key in this.nakoTestFuncs) {\n                const f = this.nakoTestFuncs[key].fn;\n                testCode += `${f};\\n;`;\n            }\n            if (testCode !== '') {\n                code += '__v0.line=\\'テストの定義\\';\\n';\n                code += testCode + '\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プラグイン・オブジェクトを追加\n     * @param po プラグイン・オブジェクト\n     */\n    addPlugin(po) {\n        return this.__self.addPlugin(po);\n    }\n    /**\n     * プラグイン・オブジェクトを追加(ブラウザ向け)\n     * @param name オブジェクト名\n     * @param po 関数リスト\n     */\n    addPluginObject(name, po) {\n        this.__self.addPluginObject(name, po);\n    }\n    /**\n     * プラグイン・ファイルを追加(Node.js向け)\n     * @param objName オブジェクト名\n     * @param path ファイルパス\n     * @param po 登録するオブジェクト\n     */\n    addPluginFile(objName, path, po) {\n        this.__self.addPluginFile(objName, path, po);\n    }\n    /**\n     * 関数を追加する\n     * @param key 関数名\n     * @param josi 助詞\n     * @param fn 関数\n     */\n    addFunc(key, josi, fn) {\n        this.__self.addFunc(key, josi, fn);\n    }\n    /**\n     * プラグイン関数を参照する\n     * @param key プラグイン関数の関数名\n     * @returns プラグイン・オブジェクト\n     */\n    getFunc(key) {\n        return this.__self.getFunc(key);\n    }\n    /**\n     * 関数を先に登録してしまう\n     */\n    registerFunction(ast) {\n        if (ast.type !== 'block') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('構文解析に失敗しています。構文は必ずblockが先頭になります', ast);\n        }\n        /** 関数一覧 */\n        const funcList = [];\n        // なでしこ関数を定義して this.nako_func[name] に定義する\n        const registFunc = (node) => {\n            if (!node.block) {\n                return;\n            }\n            const blockList = (node.block instanceof Array) ? node.block : [node.block];\n            for (let i = 0; i < blockList.length; i++) {\n                const t = blockList[i];\n                if (t.type === 'def_func') {\n                    if (!t.name) {\n                        throw new Error('[System Error] 関数の定義で関数名が指定されていない');\n                    }\n                    const name = t.name.value;\n                    this.usedFuncSet.add(name);\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    this.__self.__varslist[1][name] = function () { }; // 事前に適当な値を設定\n                    this.varslistSet[1].names.add(name); // global\n                    const meta = (t.name).meta; // todo: 強制変換したが正しいかチェック\n                    this.nakoFuncList[name] = {\n                        josi: meta.josi,\n                        // eslint-disable-next-line @typescript-eslint/no-empty-function\n                        fn: () => { },\n                        type: 'func',\n                        asyncFn: t.asyncFn\n                    };\n                    funcList.push({ name, node: t });\n                    // eslint-disable-next-line brace-style\n                }\n                // 実行速度優先 などのオプションが付いている場合の処理\n                else if (t.type === 'speed_mode') {\n                    if (!t.block) {\n                        continue;\n                    }\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n                else if (t.type === 'performance_monitor') {\n                    if (!t.block) {\n                        continue;\n                    }\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n            }\n        };\n        // 関数の登録\n        registFunc(ast);\n        // __self.__varslistの変更を反映\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: false, names: initialNames, readonly: new Set() };\n        this.varslistSet = this.__self.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        this.varslistSet[2] = this.varsSet;\n    }\n    /**\n     * @param node\n     * @param opt\n     */\n    convGen(node, opt) {\n        const result = this.convLineno(node, false) + this._convGen(node, true);\n        if (opt.isTest) {\n            return '';\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    _convGen(node, isExpression) {\n        if (!node) {\n            return '';\n        }\n        let code = '';\n        if (node instanceof Array) {\n            for (let i = 0; i < node.length; i++) {\n                const n = node[i];\n                code += this._convGen(n, isExpression);\n            }\n            return code;\n        }\n        if (node === null) {\n            return 'null';\n        }\n        if (node === undefined) {\n            return 'undefined';\n        }\n        if (typeof (node) !== 'object') {\n            return '' + node;\n        }\n        // switch\n        switch (node.type) {\n            case 'nop':\n                break;\n            case 'block':\n                // eslint-disable-next-line no-case-declarations\n                const modName = _nako_lexer_mjs__WEBPACK_IMPORTED_MODULE_1__.NakoLexer.filenameToModName(node.file || '');\n                code += `;__self.__modName='${modName}';\\n`;\n                if (!node.block) {\n                    return code;\n                }\n                // eslint-disable-next-line no-case-declarations\n                const blocks = (node.block instanceof Array) ? node.block : [node.block];\n                for (let i = 0; i < blocks.length; i++) {\n                    const b = blocks[i];\n                    code += this._convGen(b, false);\n                }\n                break;\n            case 'comment':\n            case 'eol':\n                code += this.convComment(node);\n                break;\n            case 'break':\n                code += this.convCheckLoop(node, 'break');\n                break;\n            case 'continue':\n                code += this.convCheckLoop(node, 'continue');\n                break;\n            case 'end':\n                code += '__varslist[0][\\'終\\']();';\n                break;\n            case 'number':\n                code += node.value;\n                break;\n            case 'string':\n                code += this.convString(node);\n                break;\n            case 'def_local_var':\n                code += this.convDefLocalVar(node);\n                break;\n            case 'def_local_varlist':\n                code += this.convDefLocalVarlist(node);\n                break;\n            case 'let':\n                code += this.convLet(node);\n                break;\n            case 'inc':\n                code += this.convInc(node);\n                break;\n            case 'word':\n            case 'variable':\n                code += this.convGetVar(node);\n                break;\n            case 'op':\n            case 'calc':\n                code += this.convOp(node);\n                break;\n            case 'renbun':\n                code += this.convRenbun(node);\n                break;\n            case 'not':\n                code += '((' + this._convGen(node.value, true) + ')?0:1)';\n                break;\n            case 'func':\n            case 'func_pointer':\n            case 'calc_func':\n                code += this.convCallFunc(node, isExpression);\n                break;\n            case 'if':\n                code += this.convIf(node);\n                break;\n            case 'tikuji':\n                code += this.convTikuji(node);\n                break;\n            case 'for':\n                code += this.convFor(node);\n                break;\n            case 'foreach':\n                code += this.convForeach(node);\n                break;\n            case 'repeat_times':\n                code += this.convRepeatTimes(node);\n                break;\n            case 'speed_mode':\n                code += this.convSpeedMode(node, isExpression);\n                break;\n            case 'performance_monitor':\n                code += this.convPerformanceMonitor(node, isExpression);\n                break;\n            case 'while':\n                code += this.convWhile(node);\n                break;\n            case 'atohantei':\n                code += this.convAtohantei(node);\n                break;\n            case 'switch':\n                code += this.convSwitch(node);\n                break;\n            case 'let_array':\n                code += this.convLetArray(node);\n                break;\n            case '配列参照':\n                code += this.convRefArray(node);\n                break;\n            case 'json_array':\n                code += this.convJsonArray(node);\n                break;\n            case 'json_obj':\n                code += this.convJsonObj(node);\n                break;\n            case 'func_obj':\n                code += this.convFuncObj(node);\n                break;\n            case 'bool':\n                code += (node.value) ? 'true' : 'false';\n                break;\n            case 'null':\n                code += 'null';\n                break;\n            case 'def_test':\n                code += this.convDefTest(node);\n                break;\n            case 'def_func':\n                code += this.convDefFunc(node);\n                break;\n            case 'return':\n                code += this.convReturn(node);\n                break;\n            case 'try_except':\n                code += this.convTryExcept(node);\n                break;\n            case 'require':\n                code += this.convRequire(node);\n                break;\n            default:\n                throw new Error('System Error: unknown_type=' + node.type);\n        }\n        return code;\n    }\n    /** 変数を検索 */\n    findVar(name) {\n        // __vars ? (ローカル変数)\n        if (this.varslistSet.length > 3 && this.varsSet.names.has(name)) {\n            return { i: this.varslistSet.length - 1, name, isTop: true, js: this.varname(name) };\n        }\n        // __varslist ?\n        for (let i = 2; i >= 0; i--) {\n            if (this.varslistSet[i].names.has(name)) {\n                // ユーザーの定義したグローバル変数 (__varslist[2]) は、変数展開されている（そのままの名前で定義されている）可能性がある。\n                // それ以外の変数は、必ず__varslistに入っている。\n                return { i, name, isTop: false, js: `__varslist[${i}][${JSON.stringify(name)}]` };\n            }\n        }\n        return null;\n    }\n    /**\n     * 定義済みの変数の参照\n     * @param {string} name\n     * @param {Ast} position\n     */\n    genVar(name, position) {\n        const res = this.findVar(name);\n        const lno = position.line;\n        if (res === null) {\n            // 定義されていない名前の参照は変数の定義とみなす。\n            // 多くの場合はundefined値を持つ変数であり分かりづらいバグを引き起こすが、\n            // 「ナデシコする」などの命令の中で定義された変数の参照の場合があるため警告に留める。\n            // ただし、自動的に定義される変数『引数』『それ』などは例外 #952\n            if (name === '引数' || name === 'それ' || name === '対象' || name === '対象キー') {\n                // デフォルト定義されている変数名\n            }\n            else {\n                if (this.warnUndefinedVar) {\n                    // main__は省略して表示するように。 #1223\n                    const dispName = name.replace(/^main__(.+)$/, '$1');\n                    this.__self.getLogger().warn(`変数『${dispName}』は定義されていません。`, position);\n                }\n            }\n            this.varsSet.names.add(name);\n            return this.varname(name);\n        }\n        const i = res.i;\n        // システム関数・変数の場合\n        if (i === 0) {\n            const pv = this.__self.getNakoFunc(name);\n            if (!pv) {\n                return `${res.js}/*err:${lno}*/`;\n            }\n            if (pv.type === 'const' || pv.type === 'var') {\n                return res.js;\n            }\n            if (pv.type === 'func') {\n                if (!pv.josi || pv.josi.length === 0) {\n                    return `(${res.js}())`;\n                }\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』が複文で使われました。単文で記述してください。(v1非互換)`, position);\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』は関数であり参照できません。`, position);\n        }\n        return res.js;\n    }\n    convGetVar(node) {\n        const name = node.value;\n        return this.genVar(name, node);\n    }\n    convComment(node) {\n        let commentSrc = String(node.value);\n        commentSrc = commentSrc.replace(/\\n/g, '¶');\n        const lineNo = this.convLineno(node, false);\n        if (commentSrc === '' && lineNo === '') {\n            return ';';\n        }\n        if (commentSrc === '') {\n            return ';' + lineNo + '\\n';\n        }\n        return ';' + lineNo + '//' + commentSrc + '\\n';\n    }\n    convReturn(node) {\n        // 関数の中であれば利用可能\n        if (this.varsSet.names.has('!関数')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『戻る』がありますが、関数定義内のみで使用可能です。', node);\n        }\n        const lno = this.convLineno(node, false);\n        let value;\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        else if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        else {\n            return lno + 'return;';\n        }\n        if (this.warnUndefinedReturnUserFunc === 0) {\n            return lno + `return ${value};`;\n        }\n        else {\n            return lno + `return (function(a){if(a===undefined){__self.logger.warn('ユーザ関数からundefinedが返されています',{file:'${node.file}',line:${node.line}});};return a;})(${value});`;\n        }\n    }\n    convCheckLoop(node, cmd) {\n        // ループの中であれば利用可能\n        if (!this.flagLoop) {\n            const cmdj = (cmd === 'continue') ? '続ける' : '抜ける';\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${cmdj}』文がありますが、それは繰り返しの中で利用してください。`, node);\n        }\n        return this.convLineno(node) + cmd + ';';\n    }\n    convDefFuncCommon(node, name) {\n        // パフォーマンスモニタ:ユーザ関数のinjectの定義\n        let performanceMonitorInjectAtStart = '';\n        let performanceMonitorInjectAtEnd = '';\n        if (this.performanceMonitor.userFunction !== 0) {\n            let key = name;\n            if (!key) {\n                if (typeof this.performanceMonitor.mumeiId === 'undefined') {\n                    this.performanceMonitor.mumeiId = 0;\n                }\n                this.performanceMonitor.mumeiId++;\n                key = `anous_${this.performanceMonitor.mumeiId}`;\n            }\n            performanceMonitorInjectAtStart = 'const performanceMonitorEnd = (function (key, type) {\\n' +\n                'const uf_start = performance.now() * 1000;\\n' +\n                'return function () {\\n' +\n                'const el_time = performance.now() * 1000 - uf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: el_time, min_usec: el_time, max_usec: el_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: el_time, min_usec: el_time, max_usec: el_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=el_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>el_time){__self.__performance_monitor[key].min_usec=el_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<el_time){__self.__performance_monitor[key].max_usec=el_time;}\\n' +\n                `}};})('${key}', 'user');` +\n                'try {\\n';\n            performanceMonitorInjectAtEnd = '} finally { performanceMonitorEnd(); }\\n';\n        }\n        let variableDeclarations = '';\n        const popStack = '';\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: true, names: initialNames, readonly: new Set() };\n        // ローカル変数をPUSHする\n        this.varslistSet.push(this.varsSet);\n        // JSの引数と引数をバインド\n        variableDeclarations += '  var 引数 = arguments;\\n';\n        // ローカル変数を生成\n        variableDeclarations += '  var __vars = {};\\n';\n        // 宣言済みの名前を保存\n        const varsDeclared = Array.from(this.varsSet.names.values());\n        let code = '';\n        // 引数をローカル変数に設定\n        const meta = (!name) ? node.meta : node.name.meta;\n        for (let i = 0; i < meta.varnames.length; i++) {\n            const word = meta.varnames[i];\n            if (this.warnUndefinedCalledUserFuncArgs === 0) {\n                code += `  ${this.varname(word)} = arguments[${i}];\\n`;\n            }\n            else if (name) {\n                code += `  ${this.varname(word)} = (function(a){if(a===undefined){__self.logger.warn('ユーザ関数(${name})の引数(${this.varname(word)})にundefinedが渡されました',{file:'${node.file}',line:${node.line}});};return a;})(arguments[${i}]);\\n`;\n            }\n            else {\n                code += `  ${this.varname(word)} = (function(a){if(a===undefined){__self.logger.warn('匿名関数の引数(${this.varname(word)})にundefinedが渡されました',{file:'${node.file}',line:${node.line}});};return a;})(arguments[${i}]);\\n`;\n            }\n            this.varsSet.names.add(word);\n        }\n        // 関数定義は、グローバル領域で。\n        if (name) {\n            this.usedFuncSet.add(name);\n            this.varslistSet[1].names.add(name);\n            if (this.nakoFuncList[name] === undefined) {\n                // 既に generate で作成済みのはず(念のため)\n                this.nakoFuncList[name] = {\n                    josi: node.name.meta.josi,\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    fn: () => { },\n                    type: 'func',\n                    asyncFn: false\n                };\n            }\n        }\n        // ブロックを解析\n        const oldUsedAsyncFn = this.usedAsyncFn;\n        this.usedAsyncFn = false;\n        const block = this._convGen(node.block, false);\n        code += block.split('\\n').map((line) => '  ' + line).join('\\n') + '\\n';\n        // 関数の最後に、変数「それ」をreturnするようにする\n        if (this.speedMode.invalidSore === 0) {\n            code += `  return (${this.varname('それ')});\\n`;\n        }\n        // パフォーマンスモニタ:ユーザ関数のinject\n        code += performanceMonitorInjectAtEnd;\n        // ブロックでasyncFnを使ったか\n        if (name && this.usedAsyncFn) {\n            this.nakoFuncList[name].asyncFn = true;\n        }\n        // 関数の末尾に、ローカル変数をPOP\n        // 関数内で定義されたローカル変数の宣言\n        for (const name of Array.from(this.varsSet.names.values())) {\n            if (!varsDeclared.includes(name)) {\n                if (NakoGen.isValidIdentifier(name)) {\n                    variableDeclarations += `  var ${name};\\n`;\n                }\n            }\n        }\n        if (this.speedMode.invalidSore === 0) {\n            if (NakoGen.isValidIdentifier('それ')) {\n                variableDeclarations += '  var それ = \\'\\';\\n';\n            }\n            else {\n                variableDeclarations += `  ${this.varname('それ')} = '';`;\n            }\n        }\n        // usedAsyncFnの値に応じて関数定義の方法を変更\n        const tof = (this.usedAsyncFn) ? topOfFunctionAsync : topOfFunction;\n        // 関数コード全体を構築\n        code = tof + performanceMonitorInjectAtStart + variableDeclarations + code + popStack;\n        code += endOfFunction;\n        // 名前があれば、関数を登録する\n        if (name) {\n            this.nakoFuncList[name].fn = code;\n            this.nakoFuncList[name].asyncFn = this.usedAsyncFn;\n            meta.asyncFn = this.usedAsyncFn;\n        }\n        this.usedAsyncFn = oldUsedAsyncFn; // 以前の値を戻す\n        this.varslistSet.pop();\n        this.varsSet = this.varslistSet[this.varslistSet.length - 1];\n        if (name) {\n            this.__self.__varslist[1][name] = code;\n        }\n        return code;\n    }\n    convDefTest(node) {\n        const name = node.name.value;\n        let code = `__tests.push({ name: '${name}', f: () => {\\n`;\n        // ブロックを解析\n        const block = this._convGen(node.block, false);\n        code += `   ${block}\\n` +\n            '}});';\n        this.nakoTestFuncs[name] = {\n            josi: node.name.meta.josi,\n            fn: code,\n            type: 'test_func'\n        };\n        // ★この時点ではテストコードを生成しない★\n        // プログラム冒頭でコード生成時にテストの定義を行う\n        return '';\n    }\n    convDefFunc(node) {\n        // ※ [関数定義のメモ]\n        // ※ 関数の定義はプログラムの冒頭に移される。\n        // ※ そのため、生成されたコードはここでは返さない\n        // ※ registerFunction を参照\n        if (!node.name) {\n            return '';\n        }\n        const name = NakoGen.getFuncName(node.name.value);\n        this.convDefFuncCommon(node, name);\n        return '';\n    }\n    convFuncObj(node) {\n        return this.convDefFuncCommon(node, '');\n    }\n    convJsonObj(node) {\n        const list = node.value;\n        const codelist = list.map((e) => {\n            const key = this._convGen(e.key, true);\n            const val = this._convGen(e.value, true);\n            return `${key}:${val}`;\n        });\n        return '{' + codelist.join(',') + '}';\n    }\n    convJsonArray(node) {\n        const list = node.value;\n        const codelist = list.map((e) => {\n            return this._convGen(e, true);\n        });\n        return '[' + codelist.join(',') + ']';\n    }\n    convRefArray(node) {\n        const name = this._convGen(node.name, true);\n        const list = node.index;\n        let code = name;\n        if (!list) {\n            return code;\n        }\n        for (let i = 0; i < list.length; i++) {\n            const idx = this._convGen(list[i], true);\n            code += '[' + idx + ']';\n        }\n        return code;\n    }\n    convLetArray(node) {\n        const name = this._convGen(node.name, true);\n        const list = node.index || [];\n        let codeInit = '';\n        let code = name;\n        let codeArray = '';\n        // codeInit?\n        if (node.checkInit) {\n            const arrayDefCode = '[0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0]';\n            codeInit += `\\n/*配列初期化*/if (!(${name} instanceof Array)) { ${name} = ${arrayDefCode}; console.log('初期化:${name}') };`;\n            for (let i = 0; i < list.length - 1; i++) {\n                const idx = this._convGen(list[i], true);\n                codeArray += `[${idx}]`;\n                codeInit += `\\n/*配列初期化${i}*/if (!(${name}${codeArray} instanceof Array)) { ${name}${codeArray} = ${arrayDefCode}; };`;\n                // codeInit += `\\n/*配列初期化${i}*/if (!(${name}${codeArray} instanceof Array)) { ${name}${codeArray} = ${arrayDefCode}; console.log('初期化:${i}:${name}${codeArray}',JSON.stringify(${name})) }; `\n            }\n            codeInit += '\\n';\n        }\n        // array\n        for (let i = 0; i < list.length; i++) {\n            const idx = this._convGen(list[i], true);\n            code += '[' + idx + ']';\n        }\n        const value = this._convGen(node.value, true);\n        code += ' = ' + value + ';\\n';\n        // generate code\n        const src = this.convLineno(node, false) + codeInit + code;\n        return src;\n    }\n    convGenLoop(node) {\n        const tmpflag = this.flagLoop;\n        this.flagLoop = true;\n        try {\n            return this._convGen(node, false);\n        }\n        finally {\n            this.flagLoop = tmpflag;\n        }\n    }\n    convFor(node) {\n        // ループ変数について\n        let word;\n        if (node.word !== null) { // ループ変数を使う時\n            const varName = node.word.value; // todo: Forの最初のパラメータが Token か Astか確認\n            this.varsSet.names.add(varName);\n            word = this.varname(varName);\n        }\n        else {\n            this.varsSet.names.add('dummy');\n            word = this.varname('dummy');\n        }\n        const idLoop = this.loopId++;\n        const varI = `$nako_i${idLoop}`;\n        // ループ条件を確認\n        const kara = this._convGen(node.from, true);\n        const made = this._convGen(node.to, true);\n        let inc = '1';\n        if (node.inc !== null || node.inc === undefined || node.inc === 'null') {\n            inc = this._convGen(node.inc, true);\n        }\n        // ループ内のブロック内容を得る\n        const block = this.convGenLoop(node.block);\n        // ループ条件を変数に入れる用\n        const varFrom = `$nako_from${idLoop}`;\n        const varTo = `$nako_to${idLoop}`;\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `\\n//[FOR id=${idLoop}]\\n` +\n            `const ${varFrom} = ${kara};\\n` +\n            `const ${varTo} = ${made};\\n` +\n            `if (${varFrom} <= ${varTo}) { // up\\n` +\n            `  for (let ${varI} = ${varFrom}; ${varI} <= ${varTo}; ${varI}+= ${inc}) {\\n` +\n            `    ${sorePrefex}${word} = ${varI};\\n` +\n            `    ${block}\\n` +\n            '  };\\n' +\n            '} else { // down\\n' +\n            `  for (let ${varI} = ${varFrom}; ${varI} >= ${varTo}; ${varI}-= ${inc}) {\\n` +\n            `    ${sorePrefex}${word} = ${varI};` + '\\n' +\n            `    ${block}\\n` +\n            '  };\\n' +\n            `};\\n//[/FOR id=${idLoop}]\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    convForeach(node) {\n        let target;\n        if (node.target === null) {\n            if (this.speedMode.invalidSore === 0) {\n                target = this.varname('それ');\n            }\n            else {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『反復』の対象がありません。', node);\n            }\n        }\n        else {\n            target = this._convGen(node.target, true);\n        }\n        // blockより早く変数を定義する必要がある\n        let nameS = '__v0[\"対象\"]';\n        if (node.name) {\n            nameS = this.varname(node.name.value);\n            this.varsSet.names.add(node.name.value);\n        }\n        const block = this.convGenLoop(node.block);\n        const id = this.loopId++;\n        const key = '__v0[\"対象キー\"]';\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `let $nako_foreach_v${id}=${target};\\n` +\n            `for (let $nako_i${id} in $nako_foreach_v${id})` + '{\\n' +\n            `  if ($nako_foreach_v${id}.hasOwnProperty($nako_i${id})) {\\n` +\n            `    ${nameS} = ${sorePrefex}$nako_foreach_v${id}[$nako_i${id}];` + '\\n' +\n            `    ${key} = $nako_i${id};\\n` +\n            `    ${block}\\n` +\n            '  }\\n' +\n            '};\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convRepeatTimes(node) {\n        const id = this.loopId++;\n        const value = this._convGen(node.value, true);\n        const block = this.convGenLoop(node.block);\n        const kaisu = '__v0[\"回数\"]';\n        let sorePrefex = '';\n        if (this.speedMode.invalidSore === 0) {\n            sorePrefex = `${this.varname('それ')} = `;\n        }\n        const code = `let $nako_times_v${id} = ${value};\\n` +\n            `for(var $nako_i${id} = 1; $nako_i${id} <= $nako_times_v${id}; $nako_i${id}++)` + '{\\n' +\n            `  ${sorePrefex}${kaisu} = $nako_i${id};` + '\\n' +\n            '  ' + block + '\\n}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convSpeedMode(node, isExpression) {\n        if (!node.options) {\n            return '';\n        }\n        const prev = { ...this.speedMode };\n        if (node.options['行番号無し']) {\n            this.speedMode.lineNumbers++;\n        }\n        if (node.options['暗黙の型変換無し']) {\n            this.speedMode.implicitTypeCasting++;\n        }\n        if (node.options['強制ピュア']) {\n            this.speedMode.forcePure++;\n        }\n        if (node.options['それ無効']) {\n            this.speedMode.invalidSore++;\n        }\n        try {\n            return this._convGen(node.block, isExpression);\n        }\n        finally {\n            this.speedMode = prev;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convPerformanceMonitor(node, isExpression) {\n        const prev = { ...this.performanceMonitor };\n        if (!node.options) {\n            return '';\n        }\n        if (node.options['ユーザ関数']) {\n            this.performanceMonitor.userFunction++;\n        }\n        if (node.options['システム関数本体']) {\n            this.performanceMonitor.systemFunctionBody++;\n        }\n        if (node.options['システム関数']) {\n            this.performanceMonitor.systemFunction++;\n        }\n        try {\n            return this._convGen(node.block, isExpression);\n        }\n        finally {\n            this.performanceMonitor = prev;\n        }\n    }\n    convWhile(node) {\n        const cond = this._convGen(node.cond, true);\n        const block = this.convGenLoop(node.block);\n        const code = `while (${cond})` + '{\\n' +\n            `  ${block}` + '\\n' +\n            '}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convAtohantei(node) {\n        const id = this.loopId++;\n        const varId = `$nako_i${id}`;\n        const cond = this._convGen(node.cond, true);\n        const block = this.convGenLoop(node.block);\n        const code = 'for(;;) {\\n' +\n            `  ${block}\\n` +\n            `  let ${varId} = ${cond};\\n` +\n            `  if (${varId}) { continue } else { break }\\n` +\n            '}\\n\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convSwitch(node) {\n        const value = this._convGen(node.value, true);\n        const cases = node.cases || [];\n        let body = '';\n        for (let i = 0; i < cases.length; i++) {\n            const cvalue = cases[i][0];\n            const cblock = this.convGenLoop(cases[i][1]);\n            if (cvalue.type === '違えば') {\n                body += '  default:\\n';\n            }\n            else {\n                const cvalueCode = this._convGen(cvalue, true);\n                body += `  case ${cvalueCode}:\\n`;\n            }\n            body += `    ${cblock}\\n` +\n                '    break\\n';\n        }\n        const code = `switch (${value})` + '{\\n' +\n            `${body}` + '\\n' +\n            '}\\n';\n        return this.convLineno(node, false) + code;\n    }\n    convIf(node) {\n        const expr = this._convGen(node.expr, true);\n        const block = this._convGen(node.block, false);\n        const falseBlock = (node.false_block === null)\n            ? ''\n            : 'else {' + this._convGen(node.false_block, false) + '};\\n';\n        return this.convLineno(node, false) +\n            `if (${expr}) {\\n  ${block}\\n}` + falseBlock + ';\\n';\n    }\n    convTikuji(node) {\n        const pid = this.loopId++;\n        // gen tikuji blocks\n        const curName = `__tikuji${pid}`;\n        let code = `const ${curName} = []\\n`;\n        const blocks = (node.blocks) ? node.blocks : [];\n        for (let i = 0; i < blocks.length; i++) {\n            const block = this._convGen(blocks[i], false).replace(/\\s+$/, '') + '\\n';\n            const blockLineNo = this.convLineno(blocks[i], true);\n            const blockCode = `${curName}.push(function(resolve, reject) {\\n` +\n                '  __self.resolve = resolve;\\n' +\n                '  __self.reject = reject;\\n' +\n                '  __self.resolveCount = 0;\\n' +\n                `  ${blockLineNo}\\n` +\n                `  ${block}` +\n                '  if (__self.resolveCount === 0) resolve();\\n' +\n                // eslint-disable-next-line no-template-curly-in-string\n                '}); // end of tikuji__${pid}[{$i}]\\n';\n            code += blockCode;\n        }\n        code += `// end of ${curName} \\n`;\n        // gen error block\n        let errorCode = `  ${curName}.splice(0);\\n` + // clear\n            '  __v0[\"エラーメッセージ\"]=errMsg;\\n';\n        if (node.errorBlock != null) {\n            const errBlock = this._convGen(node.errorBlock, false).replace(/\\s+$/, '') + '\\n';\n            errorCode += errBlock;\n        }\n        code += `const ${curName}__reject = function(errMsg){\\n${errorCode}};\\n`;\n        // gen run block\n        code += '__self.resolve = undefined;\\n';\n        code += `const ${curName}__resolve = function(){\\n`;\n        code += '  setTimeout(function(){\\n';\n        code += `    if (${curName}.length == 0) {return}\\n`;\n        code += `    const f = ${curName}.shift()\\n`;\n        code += `    f(${curName}__resolve, ${curName}__reject);\\n`;\n        code += '  }, 0);\\n';\n        code += '};\\n';\n        code += `${curName}__resolve()\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    convFuncGetArgsCalcType(_funcName, _func, node) {\n        const args = [];\n        const opts = {};\n        const nodeArgs = (node.args) ? node.args : [];\n        for (let i = 0; i < nodeArgs.length; i++) {\n            const arg = nodeArgs[i];\n            if (i === 0 && arg === null && this.speedMode.invalidSore === 0) {\n                args.push(this.varname('それ'));\n                opts.sore = true;\n            }\n            else {\n                args.push(this._convGen(arg, true));\n            }\n        }\n        return [args, opts];\n    }\n    getPluginList() {\n        const r = [];\n        for (const name in this.__self.__module) {\n            r.push(name);\n        }\n        return r;\n    }\n    /**\n     * 関数の呼び出し\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     * @returns string コード\n     */\n    convCallFunc(node, isExpression) {\n        const funcName = NakoGen.getFuncName(node.name);\n        const res = this.findVar(funcName);\n        if (res === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`関数『${funcName}』が見当たりません。有効プラグイン=[` + this.getPluginList().join(', ') + ']', node);\n        }\n        // どの関数を呼び出すのか関数を特定する\n        let func;\n        if (res.i === 0) { // plugin function\n            func = this.__self.getFunc(funcName);\n            if (!func) {\n                throw new Error(`[System Error] 関数「${funcName}」NakoCompiler.nakoFuncList の不整合があります。`);\n            }\n            if (func.type !== 'func') {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${funcName}』は関数ではありません。`, node);\n            }\n        }\n        else {\n            func = this.nakoFuncList[funcName];\n            // 無名関数の可能性\n            if (func === undefined) {\n                func = { return_none: false };\n            }\n        }\n        // 関数の参照渡しか？\n        if (node.type === 'func_pointer') {\n            return res.js;\n        }\n        // 関数の参照渡しでない場合\n        // 関数定義より助詞を一つずつ調べる\n        const argsInfo = this.convFuncGetArgsCalcType(funcName, func, node);\n        const args = argsInfo[0];\n        const argsOpts = argsInfo[1];\n        // function\n        this.usedFuncSet.add(funcName);\n        // 関数呼び出しで、引数の末尾にthisを追加する-システム情報を参照するため\n        args.push('__self');\n        let funcDef = 'function';\n        let funcBegin = '';\n        let funcEnd = '';\n        // setter?\n        if (node.setter) {\n            funcBegin += ';__self.isSetter = true;\\n';\n            funcEnd += ';__self.isSetter = false;\\n';\n        }\n        // 関数内 (__varslist.length > 3) からプラグイン関数 (res.i === 0) を呼び出すとき、 そのプラグイン関数がpureでなければ\n        // 呼び出しの直前に全てのローカル変数をthis.__localsに入れる。\n        if (res.i === 0 && this.varslistSet.length > 3 && func.pure !== true && this.speedMode.forcePure === 0) { // undefinedはfalseとみなす\n            // 展開されたローカル変数の列挙\n            const localVars = [];\n            for (const name of Array.from(this.varsSet.names.values())) {\n                if (NakoGen.isValidIdentifier(name)) {\n                    localVars.push({ str: JSON.stringify(name), js: this.varname(name) });\n                }\n            }\n            // --- 実行前 ---\n            // 全ての展開されていないローカル変数を __self.__locals にコピーする\n            funcBegin += '__self.__locals = __vars;\\n';\n            // 全ての展開されたローカル変数を __self.__locals に保存する\n            for (const v of localVars) {\n                funcBegin += `__self.__locals[${v.str}] = ${v.js};\\n`;\n            }\n            // --- 実行後 ---\n            // 全ての展開されたローカル変数を __self.__locals から受け取る\n            // 「それ」は関数の実行結果を受け取るために使うためスキップ。\n            for (const v of localVars) {\n                if (v.js !== 'それ') {\n                    funcEnd += `${v.js} = __self.__locals[${v.str}];\\n`;\n                }\n            }\n        }\n        // 変数「それ」が補完されていることをヒントとして出力\n        if (argsOpts.sore) {\n            funcBegin += '/*[sore]*/';\n        }\n        const indent = (text, n) => {\n            let result = '';\n            for (const line of text.split('\\n')) {\n                if (line !== '') {\n                    result += '  '.repeat(n) + line + '\\n';\n                }\n            }\n            return result;\n        };\n        // 関数呼び出しコードの構築\n        let argsCode;\n        if ((this.warnUndefinedCallingUserFunc === 0 && res.i !== 0) || (this.warnUndefinedCallingSystemFunc === 0 && res.i === 0)) {\n            argsCode = args.join(',');\n        }\n        else {\n            argsCode = '';\n            args.forEach((arg) => {\n                if (arg === '__self') {\n                    argsCode += `,${arg}`;\n                }\n                else {\n                    if (res.i === 0) {\n                        argsCode += `,(function(a){if(a===undefined){__self.logger.warn('命令『${funcName}』の引数にundefinedを渡しています。',{file:'${node.file}',line:${node.line}});};return a;})(${arg})`;\n                    }\n                    else {\n                        argsCode += `,(function(a){if(a===undefined){__self.logger.warn('ユーザ関数『${funcName}』の引数にundefinedを渡しています。',{file:'${node.file}',line:${node.line}});};return a;})(${arg})`;\n                    }\n                }\n            });\n            argsCode = argsCode.substring(1);\n        }\n        let funcCall = `${res.js}(${argsCode})`;\n        if (func.asyncFn) {\n            funcDef = `async ${funcDef}`;\n            funcCall = `await ${funcCall}`;\n            this.numAsyncFn++;\n            this.usedAsyncFn = true;\n        }\n        if (res.i === 0 && this.performanceMonitor.systemFunctionBody !== 0) {\n            let key = funcName;\n            if (!key) {\n                if (typeof this.performanceMonitor.mumeiId === 'undefined') {\n                    this.performanceMonitor.mumeiId = 0;\n                }\n                this.performanceMonitor.mumeiId++;\n                key = `anous_${this.performanceMonitor.mumeiId}`;\n            }\n            funcCall = `(${funcDef} (key, type) {\\n` +\n                'const sbf_start = performance.now() * 1000;\\n' +\n                'try {\\n' +\n                'return ' + funcCall + ';\\n' +\n                '} finally {\\n' +\n                'const sbl_time = performance.now() * 1000 - sbf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sbl_time, min_usec: sbl_time, max_usec: sbl_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sbl_time, min_usec: sbl_time, max_usec: sbl_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=sbl_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>sbl_time){__self.__performance_monitor[key].min_usec=sbl_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<sbl_time){__self.__performance_monitor[key].max_usec=sbl_time;}\\n' +\n                `}}})('${funcName}_body', 'sysbody')\\n`;\n        }\n        let code = '';\n        if (func.return_none) {\n            // 戻り値のない関数の場合\n            if (funcEnd === '') {\n                if (funcBegin === '') {\n                    code = `${funcCall};\\n`;\n                }\n                else {\n                    code = `${funcBegin} ${funcCall};\\n`;\n                }\n            }\n            else {\n                code = `${funcBegin}try {\\n${indent(funcCall, 1)};\\n} finally {\\n${indent(funcEnd, 1)}}\\n`;\n            }\n        }\n        else {\n            // 戻り値のある関数の場合\n            let sorePrefex = '';\n            if (this.speedMode.invalidSore === 0) {\n                sorePrefex = `${this.varname('それ')} = `;\n            }\n            if (funcBegin === '' && funcEnd === '') {\n                code = `(${sorePrefex}${funcCall})`;\n            }\n            else {\n                if (funcEnd === '') {\n                    code = `(${funcDef}(){\\n${indent(`${funcBegin};\\nreturn ${sorePrefex} ${funcCall}`, 1)}}).call(this)`;\n                }\n                else {\n                    code = `(${funcDef}(){\\n${indent(`${funcBegin}try {\\n${indent(`return ${sorePrefex}${funcCall};`, 1)}\\n} finally {\\n${indent(funcEnd, 1)}}`, 1)}}).call(this)`;\n                }\n            }\n            // ...して\n            if (node.josi === 'して' || (node.josi === '' && !isExpression)) {\n                code += ';\\n';\n            }\n        }\n        if (res.i === 0 && this.performanceMonitor.systemFunction !== 0) {\n            code = '(function (key, type) {\\n' +\n                'const sf_start = performance.now() * 1000;\\n' +\n                'try {\\n' +\n                'return ' + code + ';\\n' +\n                '} finally {\\n' +\n                'const sl_time = performance.now() * 1000 - sf_start;\\n' +\n                'if (!__self.__performance_monitor) {\\n' +\n                '__self.__performance_monitor={};\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sl_time, min_usec: sl_time, max_usec: sl_time, type: type };\\n' +\n                '} else if (!__self.__performance_monitor[key]) {\\n' +\n                '__self.__performance_monitor[key] = { called:1, totel_usec: sl_time, min_usec: sl_time, max_usec: sl_time, type: type };\\n' +\n                '} else {\\n' +\n                '__self.__performance_monitor[key].called++;\\n' +\n                '__self.__performance_monitor[key].totel_usec+=sl_time;\\n' +\n                'if(__self.__performance_monitor[key].min_usec>sl_time){__self.__performance_monitor[key].min_usec=sl_time;}\\n' +\n                'if(__self.__performance_monitor[key].max_usec<sl_time){__self.__performance_monitor[key].max_usec=sl_time;}\\n' +\n                `}}})('${funcName}_sys', 'system')\\n`;\n        }\n        return code;\n    }\n    convRenbun(node) {\n        const right = this._convGen(node.right, true);\n        const left = this._convGen(node.left, false);\n        return `(function(){${left}; return ${right}}).call(this)`;\n    }\n    convOp(node) {\n        const OP_TBL = {\n            '&': '+\"\"+',\n            eq: '==',\n            noteq: '!=',\n            '===': '===',\n            '!==': '!==',\n            gt: '>',\n            lt: '<',\n            gteq: '>=',\n            lteq: '<=',\n            and: '&&',\n            or: '||',\n            shift_l: '<<',\n            shift_r: '>>',\n            shift_r0: '>>>',\n            '÷': '/'\n        };\n        let op = node.operator || ''; // 演算子\n        let right = this._convGen(node.right, true);\n        let left = this._convGen(node.left, true);\n        if (op === '+' && this.speedMode.implicitTypeCasting === 0) {\n            if (node.left && node.left.type !== 'number') {\n                left = `parseFloat(${left})`;\n            }\n            if (node.right && node.right.type !== 'number') {\n                right = `parseFloat(${right})`;\n            }\n        }\n        // 階乗\n        if (op === '^') {\n            return `(Math.pow(${left}, ${right}))`;\n        }\n        // 整数の割り算 #1152\n        if (op === '÷÷') {\n            return `(Math.floor(${left} / ${right}))`;\n        }\n        // 一般的なオペレータに変換\n        if (OP_TBL[op]) {\n            op = OP_TBL[op];\n        }\n        //\n        return `(${left} ${op} ${right})`;\n    }\n    convInc(node) {\n        // もし値が省略されていたら、変数「それ」に代入する\n        let value = null;\n        if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        if (value == null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('加算する先の変数名がありません。', node);\n        }\n        // 変数名\n        const name = node.name.value;\n        let res = this.findVar(name);\n        let code = '';\n        if (res === null) {\n            this.varsSet.names.add(name);\n            res = this.findVar(name);\n            if (!res) {\n                throw new Error('『増』または『減』で変数が見当たりません。');\n            }\n        }\n        const jsName = res.js;\n        // 自動初期化するか\n        code += `if (typeof(${jsName}) === 'undefined') { ${jsName} = 0; }`;\n        code += `${jsName} += ${value}`;\n        return ';' + this.convLineno(node, false) + code + '\\n';\n    }\n    convLet(node) {\n        // もし値が省略されていたら、変数「それ」に代入する\n        let value = null;\n        if (this.speedMode.invalidSore === 0) {\n            value = this.varname('それ');\n        }\n        if (node.value) {\n            value = this._convGen(node.value, true);\n        }\n        if (value == null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('代入する先の変数名がありません。', node);\n        }\n        // 変数名\n        const name = node.name.value;\n        const res = this.findVar(name);\n        let code = '';\n        if (res === null) {\n            this.varsSet.names.add(name);\n            code = `${this.varname(name)} = ${value};`;\n        }\n        else {\n            // 定数ならエラーを出す\n            if (this.varslistSet[res.i].readonly.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`定数『${name}』は既に定義済みなので、値を代入することはできません。`, node);\n            }\n            code = `${res.js} = ${value};`;\n        }\n        return ';' + this.convLineno(node, false) + code + '\\n';\n    }\n    convDefLocalVar(node) {\n        const value = (node.value === null) ? 'null' : this._convGen(node.value, true);\n        const name = node.name.value;\n        const vtype = node.vartype; // 変数 or 定数\n        // 二重定義？\n        if (this.varsSet.names.has(name)) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n        }\n        //\n        this.varsSet.names.add(name);\n        if (vtype === '定数') {\n            this.varsSet.readonly.add(name);\n        }\n        const code = `${this.varname(name)}=${value};\\n`;\n        return this.convLineno(node, false) + code;\n    }\n    // #563 複数変数への代入\n    convDefLocalVarlist(node) {\n        let code = '';\n        const vtype = node.vartype; // 変数 or 定数\n        const value = (node.value === null) ? 'null' : this._convGen(node.value, true);\n        this.loopId++;\n        const varI = `$nako_i${this.loopId}`;\n        code += `${varI}=${value}\\n`;\n        code += `if (!(${varI} instanceof Array)) { ${varI}=[${varI}] }\\n`;\n        const names = (node.names) ? node.names : [];\n        for (let i = 0; i < names.length; i++) {\n            const nameObj = names[i];\n            const name = nameObj.value;\n            // 二重定義？\n            if (this.varsSet.names.has(name)) {\n                // 複数変数文では、二重定義も許容する #1027\n                // throw NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node)\n            }\n            this.varsSet.names.add(name);\n            if (vtype === '定数') {\n                this.varsSet.readonly.add(name);\n            }\n            const vname = this.varname(name);\n            code += `${vname}=${varI}[${i}];\\n`;\n        }\n        return this.convLineno(node, false) + code;\n    }\n    convString(node) {\n        let value = '' + node.value;\n        const mode = node.mode;\n        value = value.replace(/\\\\/g, '\\\\\\\\');\n        value = value.replace(/\"/g, '\\\\\"');\n        value = value.replace(/\\r/g, '\\\\r');\n        value = value.replace(/\\n/g, '\\\\n');\n        if (mode === 'ex') {\n            const rf = (a, name) => {\n                return '\"+' + this.genVar(name, node) + '+\"';\n            };\n            value = value.replace(/\\{(.+?)\\}/g, rf);\n            value = value.replace(/｛(.+?)｝/g, rf);\n        }\n        return '\"' + value + '\"';\n    }\n    convTryExcept(node) {\n        const block = this._convGen(node.block, false);\n        const errBlock = this._convGen(node.errBlock, false);\n        return this.convLineno(node, false) +\n            `try {\\n${block}\\n} catch (e) {\\n` +\n            '  __v0[\"エラーメッセージ\"] = e.message;\\n' +\n            ';\\n' +\n            `${errBlock}}\\n`;\n    }\n    getUsedFuncSet() {\n        return this.usedFuncSet;\n    }\n    getPluginInitCode() {\n        // プラグインの初期化関数を実行する\n        let code = '';\n        let pluginCode = '';\n        for (const name in this.__self.__module) {\n            const initkey = `!${name}:初期化`;\n            if (this.varslistSet[0].names.has(initkey)) {\n                this.usedFuncSet.add(`!${name}:初期化`);\n                pluginCode += `__v0[\"!${name}:初期化\"](__self);\\n`;\n            }\n        }\n        if (pluginCode !== '') {\n            code += '__v0.line=\\'l0:プラグインの初期化\\';\\n' + pluginCode;\n        }\n        return code;\n    }\n}\n/**\n * @param com\n * @param ast\n * @param opt\n */\nfunction generateJS(com, ast, opt) {\n    const gen = new NakoGen(com);\n    // ※ [関数定義に関するコード生成のヒント]\n    // ※ 関数の名前だけを(1)で登録して、(2)で実際に関数のコードを生成する。\n    // ※ ただし(2)では生成するだけなので、(3)でプログラム冒頭に関数定義のコードを記述する。\n    // この順番を変えることはできない (グローバル変数が認識できなくなったり、関数定義のタイミングがずれる)\n    // (1) ユーザー定義関数をシステムに登録する\n    gen.registerFunction(ast);\n    // (2) JSコードを生成する\n    let js = gen.convGen(ast, opt);\n    // (3) JSコードを実行するための事前ヘッダ部分の生成\n    const jsInit = gen.getDefFuncCode(com, opt);\n    // テストの実行\n    if (js && opt.isTest) {\n        js += '\\n__self._runTests(__tests);\\n';\n    }\n    // async method\n    if (gen.numAsyncFn > 0) {\n        const asyncMain = '__nako3async' + (new Date()).getTime() + '_' + ('' + Math.random()).replace('.', '_') + '__';\n        js = `\n// --------------------------------------------------\n// <nadesiko3::gen::async times=\"${gen.numAsyncFn}\">\nasync function ${asyncMain}(self) {\n${jsInit}\n${js}\n} // end of ${asyncMain}\n${asyncMain}.call(self, self).catch(err => {\n  self.numFailures++\n  throw new NakoRuntimeError(err, self.__v0.line) // エラー位置を認識\n})\n// <nadesiko3::gen::async>\n// --------------------------------------------------\n`;\n    }\n    else {\n        js = `\n// --------------------------------------------------\ntry {\n  ${jsInit}\n  ${js}\n} catch (err) {\n  self.numFailures++\n  throw new NakoRuntimeError(err, self.__v0.line) // エラー位置を認識\n}\n// --------------------------------------------------\n`;\n    }\n    // デバッグメッセージ\n    com.getLogger().trace('--- generate ---\\n' + js);\n    let codeImportFiles = '';\n    const importNames = [];\n    for (const f of opt.importFiles) {\n        if (f === 'nako_errors.mjs') {\n            continue;\n        }\n        const ff = 'nako3runtime_' + f.replace(/\\.(js|mjs)$/, '').replace(/[^a-zA-Z0-9_]/g, '_');\n        importNames.push(ff);\n        codeImportFiles += `import ${ff} from './nako3runtime/${f}'\\n`;\n    }\n    const standaloneJSCode = `\\\n// <standaloneCode>\nimport path from 'path'\nimport { NakoRuntimeError } from './nako3runtime/nako_errors.mjs'\n${codeImportFiles}\nconst self = {}\nself.coreVersion = '${com.coreVersion}'\nself.version = '${com.version}'\nself.logger = {\n  error: (message) => { console.error(message) },\n  warn: (message) => { console.warn(message) },\n  send: (level, message) => { console.log(message) },\n};\nself.__varslist = [{}, {}, {}]\nself.__v0 = self.__varslist[0]\nself.initFuncList = []\nself.clearFuncList = []\n// Copy module functions\nfor (const mod of [${importNames.join(', ')}]) {\n  for (const funcName in mod) {\n    if (funcName === '初期化') {\n      self.initFuncList.push(mod[funcName].fn)\n      continue\n    }\n    if (funcName === '!クリア') {\n      self.clearFuncList.push(mod[funcName].fn)\n      continue\n    }\n    self.__varslist[0][funcName] = mod[funcName].fn\n  }\n}\nself.__vars = self.__varslist[2];\nself.__module = {};\nself.__locals = {};\nself.__genMode = 'sync';\n\n// プラグインの初期化コードを実行\nself.initFuncList.map(f => f(self))\n\ntry {\n${opt.codeStandalone}\n// <JS:standalone>\n${js}\n// </JS:standalone>\n  // standaloneCodeでは、即時プラグインのクリアコードを実行\n  self.clearFuncList.map(f => f(self))\n} catch (err) {\n  self.logger.error(err);\n  throw err;\n}\n// </standaloneCode>\n`;\n    // ---\n    const initCode = gen.getPluginInitCode();\n    const runtimeEnvCode = `\n// runtimeEnv\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoError.toString()}\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError.toString()}\nconst self = this\n${opt.codeEnv}\n${jsInit}\n${initCode}\n${js}\n// end of runtimeEnv\n`;\n    return {\n        // なでしこの実行環境ありの場合(thisが有効)\n        runtimeEnv: runtimeEnvCode,\n        // JavaScript単体で動かす場合\n        standalone: standaloneJSCode,\n        // コード生成に使ったNakoGenのインスタンス\n        gen\n    };\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_gen.mjs?")},"./core/src/nako_gen_async.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoGenASync\": function() { return /* binding */ NakoGenASync; }\n/* harmony export */ });\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n/* harmony import */ var _nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_core_version.mjs */ \"./core/src/nako_core_version.mjs\");\n/* harmony import */ var _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_gen.mjs */ \"./core/src/nako_gen.mjs\");\n/**\n * file: nako_gen_async\n * パーサーが生成した中間オブジェクトを実際のJavaScriptのコードに変換する。\n * なお、扱いやすさ優先で、なでしこの一文を一つの関数として生成し、非同期実行する。\n */\n\n\n\n/**\n * なでしこのインタプリタコード\n */\nconst NakoCodeNop = 'NOP';\nconst NakoCodeLabel = 'LBL';\nconst NakoCodeEOL = 'EOL';\nconst NakoCodeJump = 'JMP'; // JUMP addr\nconst NakoCodeJumpIfTrue = 'JMP_T'; // pop and jump addr\nconst NakoCodeJumpIfFalse = 'JMP_F'; // pop and jump addr\nconst NakoCodeCall = 'CALL'; // call addr\nconst NakoCodeCallObj = 'CALL_OBJ'; // call addr\nconst NakoCodeReturn = 'RET';\nconst NakoCodeTry = 'TRY';\nconst NakoCodeCode = 'CODE';\nconst NakoCodeTagIsFuncpoint = 0x0F;\n/**\n * なでしこのインタプリタが用いる簡易コードを表現するクラス\n */\nclass NakoCode {\n    /**\n     * @param type\n     * @param value\n     */\n    constructor(type, value) {\n        /** Codeのタイプ\n         * @type {string}\n         */\n        this.type = type;\n        /** Codeの値 / ラベルならラベル名\n         * @type {string}\n         */\n        this.value = value;\n        /** ラベルならジャンプ先\n         * @type {number}\n         */\n        this.no = -1;\n        /** タグ\n         * @type {number}\n         */\n        this.tag = 0;\n    }\n}\n/**\n * 構文木からJSのコードを生成するクラス\n */\nclass NakoGenASync {\n    /**\n     * @param com コンパイラのインスタンス\n     */\n    constructor(com) {\n        this.com = com;\n        /**\n         * 出力するJavaScriptコードのヘッダー部分で定義する必要のある関数。fnはjsのコード。\n         * プラグイン関数は含まれない。\n         */\n        this.nakoFuncList = { ...com.getNakoFuncList() };\n        /**\n         * なでしこで定義したテストの一覧\n         * @type {Record<string, { josi: string[][], fn: string, type: 'test_func' }>}\n         */\n        this.nakoTestList = {};\n        /**\n         * プログラム内で参照された関数のリスト。プラグインの命令を含む。\n         * JavaScript単体で実行するとき、このリストにある関数の定義をJavaScriptコードの先頭に付け足す。\n         * @type {Set<string>}\n         */\n        this.usedFuncSet = new Set();\n        /**\n         * ループ時の一時変数が被らないようにIDで管理\n         * @type {number}\n         */\n        this.loopId = 1;\n        /**\n         * 変換中の処理が、ループの中かどうかを判定する\n         * @type {boolean}\n         */\n        this.flagLoop = false;\n        /**\n         * 変換後のコード管理番号\n         * @type {number}\n         */\n        this.codeId = 0;\n        /**\n         * 変換後のコードを保持する配列\n         * @type {Array<NakoCode>}\n         */\n        this.codeArray = [];\n        /** @type {NakoCode | null} */\n        this.labelContinue = null;\n        /** @type {NakoCode | null} */\n        this.labelBreak = null;\n        /**\n         * ジャンプ先を表現するラベル\n         * @type {Object<string, number>}\n         */\n        this.labels = {};\n        // コンパイラのインスタンス\n        this.__self = com;\n        /**\n         * コードジェネレータの種類\n         * @type {string}\n         */\n        this.genMode = '非同期モード';\n        /**\n         * 行番号とファイル名が分かるときは `l123:main.nako3`、行番号だけ分かるときは `l123`、そうでなければ任意の文字列。\n         * @type {string | null}\n         */\n        this.lastLineNo = null;\n        /**\n         * スタック\n         * @type {{ isFunction: boolean, names: Set<string>, readonly: Set<string> }[]}\n         */\n        this.varslistSet = com.__varslist.map((v) => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        /**\n         * スタックトップ\n         * @type {{ isFunction: boolean, names: Set<string>, readonly: Set<string> }}\n         */\n        this.varsSet = { isFunction: false, names: new Set(), readonly: new Set() };\n        this.varslistSet[2] = this.varsSet;\n        // 1以上のとき高速化する。\n        // 実行速度優先ブロック内で1増える。\n        this.speedMode = {\n            lineNumbers: 0,\n            implicitTypeCasting: 0,\n            invalidSore: 0,\n            forcePure: 0 // 全てのシステム命令をpureとして扱う。命令からローカル変数への参照が出来なくなる。\n        };\n        // 1以上のとき測定をinjectする。\n        // パフォーマンスモニタのブロック内で1増える。\n        this.performanceMonitor = {\n            userFunction: 0,\n            systemFunction: 0,\n            systemFunctionBody: 0 // システム関数(呼び出しコードを除く)\n        };\n    }\n    /**\n     * @param com\n     * @param {Ast} ast\n     * @param {boolean | string} isTest 文字列なら1つのテストだけを実行する\n     */\n    static generate(com, ast, isTest) {\n        const gen = new NakoGenASync(com);\n        // ユーザー定義関数をシステムに登録する\n        gen.registerFunction(ast);\n        // JSコードを生成する\n        let js = gen.convGen(ast, !!isTest);\n        // JSコードを実行するための事前ヘッダ部分の生成\n        js = gen.getDefFuncCode(isTest) + js;\n        com.getLogger().trace('--- generate(非同期モード) ---\\n' + js);\n        // テストの実行\n        if (js && isTest) {\n            js += '\\n__self._runTests(__tests);\\n';\n        }\n        return {\n            // なでしこの実行環境ありの場合\n            runtimeEnv: js,\n            // JavaScript単体で動かす場合\n            standalone: `\\\nconst nakoVersion = ${JSON.stringify(_nako_core_version_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])};\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoError.toString()}\n${_nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoRuntimeError.toString()}\nthis.logger = {\n  error(message) { console.error(message) },\n  send(level, message) { console.log(message) },\n};\nthis.__varslist = [{}, {}, {}];\nthis.__vars = this.__varslist[2];\nthis.__module = {};\nthis.__locals = {};\nthis.__labels = {};\nthis.__code = [];\nthis.__callstack = [];\nthis.__stack = [];\nthis.__genMode = '非同期モード';\ntry {\n  ${gen.getVarsCode()}\n  ${js}\n} catch (err) {\n  if (!(err instanceof NakoRuntimeError)) {\n    err = new NakoRuntimeError(err, this.__varslist[0].line);\n  }\n  this.logger.error(err);\n  throw err;\n}`,\n            gen // コード生成に使ったNakoGenのインスタンス\n        };\n    }\n    /**\n     * @param {import(\"./nako3\").Ast} node\n     * @param {boolean} forceUpdate\n     */\n    convLineno(node, forceUpdate) {\n        if (this.speedMode.lineNumbers > 0) {\n            return '';\n        }\n        /** @type {string} */\n        let lineNo;\n        if (typeof node.line !== 'number') {\n            lineNo = 'unknown';\n        }\n        else if (typeof node.file !== 'string') {\n            lineNo = `l${node.line}`;\n        }\n        else {\n            lineNo = `l${node.line}:${node.file}`;\n        }\n        // 強制的に行番号をアップデートするか\n        if (!forceUpdate) {\n            if (lineNo === this.lastLineNo) {\n                return '';\n            }\n            this.lastLineNo = lineNo;\n        }\n        // 例: __v0.line='l1:main.nako3'\n        return `__v0.line=${JSON.stringify(lineNo)};`;\n    }\n    /**\n     * ローカル変数のJavaScriptコードを生成する。\n     * 基本的に取得のために利用\n     * @param {string} name\n     */\n    varname(name) {\n        const keys = JSON.stringify(name);\n        return `sys.__vars[${keys}]`;\n    }\n    /**\n     * プログラムの実行に必要な関数を書き出す(システム領域)\n     * @returns {string}\n     */\n    getVarsCode() {\n        let code = '';\n        // プログラム中で使った関数を列挙して書き出す\n        for (const key of Array.from(this.usedFuncSet.values())) {\n            const f = this.__self.__varslist[0][key];\n            const name = `this.__varslist[0][\"${key}\"]`;\n            if (typeof (f) === 'function') {\n                code += name + '=' + f.toString() + ';\\n';\n            }\n            else {\n                code += name + '=' + JSON.stringify(f) + ';\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プログラムの実行に必要な関数定義を書き出す(グローバル領域)\n     * convGenの結果を利用するため、convGenの後に呼び出すこと。\n     * @param {boolean | string} isTest テストかどうか。stringの場合は1つのテストのみ。\n     * @returns {string}\n     */\n    getDefFuncCode(isTest) {\n        let code = '';\n        // よく使う変数のショートカット\n        code += 'const __self = this.__self = this;\\n';\n        code += 'const __varslist = this.__varslist;\\n';\n        code += 'const __module = this.__module;\\n';\n        code += 'const __v0 = this.__v0 = this.__varslist[0];\\n';\n        code += 'const __v1 = this.__v1 = this.__varslist[1];\\n';\n        code += 'const __vars = this.__vars = this.__varslist[2];\\n';\n        code += 'const __code = this.__code;\\n';\n        // なでしこの関数定義を行う\n        let nakoFuncCode = '';\n        for (const key in this.nakoFuncList) {\n            const f = this.nakoFuncList[key].fn;\n            nakoFuncCode += '' +\n                `//[DEF_FUNC name='${key}']\\n` +\n                `__v1[\"${key}\"]=${f};\\n;` +\n                `//[/DEF_FUNC name='${key}']\\n`;\n        }\n        if (nakoFuncCode !== '') {\n            code += '__v0.line=\\'関数の定義\\';\\n' + nakoFuncCode;\n        }\n        // プラグインの初期化関数を実行する\n        let pluginCode = '';\n        for (const name in this.__self.__module) {\n            const initkey = `!${name}:初期化`;\n            if (this.varslistSet[0].names.has(initkey)) {\n                this.usedFuncSet.add(`!${name}:初期化`);\n                pluginCode += `__v0[\"!${name}:初期化\"](__self);\\n`;\n            }\n        }\n        if (pluginCode !== '') {\n            code += '__v0.line=\\'プラグインの初期化\\';\\n' + pluginCode;\n        }\n        // テストの定義を行う\n        if (isTest) {\n            let testCode = 'const __tests = [];\\n';\n            for (const key in this.nakoTestList) {\n                if (isTest === true || (typeof isTest === 'string' && isTest === key)) {\n                    const f = this.nakoTestList[key].fn;\n                    testCode += `${f};\\n;`;\n                }\n            }\n            if (testCode !== '') {\n                code += '__v0.line=\\'テストの定義\\';\\n';\n                code += testCode + '\\n';\n            }\n        }\n        return code;\n    }\n    /**\n     * プラグイン・オブジェクトを追加\n     * @param po プラグイン・オブジェクト\n     */\n    addPlugin(po) {\n        return this.__self.addPlugin(po);\n    }\n    /**\n     * プラグイン・オブジェクトを追加(ブラウザ向け)\n     * @param name オブジェクト名\n     * @param po 関数リスト\n     */\n    addPluginObject(name, po) {\n        this.__self.addPluginObject(name, po);\n    }\n    /**\n     * プラグイン・ファイルを追加(Node.js向け)\n     * @param objName オブジェクト名\n     * @param path ファイルパス\n     * @param po 登録するオブジェクト\n     */\n    addPluginFile(objName, path, po) {\n        this.__self.addPluginFile(objName, path, po);\n    }\n    /**\n     * 関数を追加する\n     * @param key 関数名\n     * @param josi 助詞\n     * @param fn 関数\n     */\n    addFunc(key, josi, fn) {\n        this.__self.addFunc(key, josi, fn);\n    }\n    /**\n     * プラグイン関数を参照する\n     * @param key プラグイン関数の関数名\n     * @returns プラグイン・オブジェクト\n     */\n    getFunc(key) {\n        return this.__self.getFunc(key);\n    }\n    /**\n     * 関数を先に登録してしまう\n     */\n    registerFunction(ast) {\n        if (ast.type !== 'block') {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('構文解析に失敗しています。構文は必ずblockが先頭になります', ast);\n        }\n        const registFunc = (node) => {\n            for (let i = 0; i < node.block.length; i++) {\n                const t = node.block[i];\n                if (t.type === 'def_func') {\n                    const name = t.name.value;\n                    this.usedFuncSet.add(name);\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    this.__self.__varslist[1][name] = function () { }; // 事前に適当な値を設定\n                    this.nakoFuncList[name] = {\n                        josi: t.name.meta.josi,\n                        fn: '',\n                        type: 'func'\n                    };\n                }\n                else if (t.type === 'speed_mode') {\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n                else if (t.type === 'performance_monitor') {\n                    if (t.block.type === 'block') {\n                        registFunc(t.block);\n                    }\n                    else {\n                        registFunc(t);\n                    }\n                }\n            }\n        };\n        registFunc(ast);\n        // __self.__varslistの変更を反映\n        const initialNames = new Set();\n        if (this.speedMode.invalidSore === 0) {\n            initialNames.add('それ');\n        }\n        this.varsSet = { isFunction: false, names: initialNames, readonly: new Set() };\n        this.varslistSet = this.__self.__varslist.map(v => ({ isFunction: false, names: new Set(Object.keys(v)), readonly: new Set() }));\n        this.varslistSet[2] = this.varsSet;\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isTest\n     */\n    convGen(node, isTest) {\n        // convert\n        this._convGen(node, true);\n        // ラベルアドレスの解決が必要なコード一覧\n        const needToFixAddr = new Set([\n            NakoCodeJump, NakoCodeJumpIfTrue, NakoCodeJumpIfFalse, NakoCodeCall, NakoCodeTry\n        ]);\n        // コードの最適化をするか?\n        const optimization = true;\n        let codes = this.codeArray;\n        //\n        if (optimization) {\n            // NOPを削除\n            codes = codes.filter((code) => {\n                return code.type !== NakoCodeNop;\n            });\n            // 未参照のラベルを探す - ただし関数呼び出しは削除しない\n            const usedLabels = new Set();\n            codes.forEach((code) => {\n                if (needToFixAddr.has(code.type)) {\n                    usedLabels.add(code.value);\n                }\n            });\n            // 未参照のラベルを削除\n            codes = codes.filter((code) => {\n                if (code.type !== NakoCodeLabel) {\n                    return true;\n                }\n                if (code.tag === NakoCodeTagIsFuncpoint) {\n                    return true;\n                }\n                return usedLabels.has(code.value);\n            });\n            // EOLが連続していたら削除する\n            let i = 0;\n            while (i < codes.length - 1) {\n                if (codes[i].type === NakoCodeEOL && codes[i + 1].type === NakoCodeEOL) {\n                    codes.splice(i + 1, 1);\n                    continue;\n                }\n                i++;\n            }\n            this.codeArray = codes;\n        }\n        // ラベルアドレスの解決\n        codes.forEach((code, index) => {\n            if (code.type === NakoCodeLabel) {\n                this.labels[code.value] = index;\n            }\n        });\n        codes.forEach((code) => {\n            if (needToFixAddr.has(code.type)) {\n                if (code.no < 0) {\n                    code.no = this.labels[code.value];\n                }\n            }\n        });\n        let result = '';\n        // コードの生成\n        codes.forEach((code, index) => {\n            switch (code.type) {\n                case NakoCodeNop:\n                    result += `case ${index}: break; // [NOP] ${code.value}\\n`;\n                    break;\n                case NakoCodeLabel:\n                    result += `case ${index}: break; // [LABEL] ${code.value}\\n`;\n                    break;\n                case NakoCodeEOL:\n                    result += `case ${index}: ${code.value}; break; // [EOL]\\n`;\n                    break;\n                case NakoCodeJump:\n                    result += `case ${index}: sys.nextIndex = ${code.no}; break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeJumpIfTrue:\n                    result += `case ${index}: if (sys.__stack.pop()) { sys.nextIndex = ${code.no};} break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeJumpIfFalse:\n                    result += `case ${index}: if (!sys.__stack.pop()) { sys.nextIndex = ${code.no}} break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeReturn:\n                    result += `case ${index}: sys.__return(sys); break;\\n`;\n                    break;\n                case NakoCodeCall:\n                    result += `case ${index}: sys.__call(${code.no}, sys); break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeCallObj:\n                    result += `case ${index}: sys.__callObj('${code.value}', ${index}, sys); break; // ${code.value}\\n`;\n                    break;\n                case NakoCodeTry:\n                    result += `case ${index}: sys.tryIndex = ${code.no}; break; // TRY \\n`;\n                    break;\n                case NakoCodeCode:\n                    {\n                        // trim last\n                        const s = code.value.replace(/\\s+$/, '');\n                        result += `case ${index}: {\\n${s}\\n};break;\\n`;\n                        break;\n                    }\n                default:\n                    throw new Error('invalid code type');\n            }\n        });\n        result = `\n    //-------------------------\n    // main_code\n    this.__labels = ${JSON.stringify(this.labels)};\n    this.nextAsync = (sys) => {\n      if (sys.index >= sys.codeSize || sys.index < 0) {return}\n      const __v0 = sys.__v0\n      try {\n        sys.inLoop = true\n        while (sys.index < sys.codeSize && sys.index >= 0) {\n          // console.log('@@[run]', sys.index)\n          switch (sys.index) {\n            // --- CODE.BEGIN ---\n            ${result}\n            // --- CODE.END ---\n            default:\n              sys.inLoop = false\n              console.log(sys.index, sys.__stack)\n              throw new Error('Invalid sys.index:' + sys.index)\n              break\n          }\n          // check next\n          if (sys.nextIndex >= 0) {\n            sys.index = sys.nextIndex\n            sys.nextIndex = -1\n          } else {\n            sys.index++\n          }\n          if (sys.async) {\n            sys.__saveSysenv(sys)\n            sys.async = false\n            break\n          }\n        } // end of while\n        sys.inLoop = false\n      } catch (e) {\n        sys.__errorAsync(e, sys)\n      }\n    }\n    this.__errorAsync = (e, sys) => { // エラーが起きた時呼び出す\n      sys.__v0[\"エラーメッセージ\"] = e.message;\n      if (e.message == '__終わる__') {\n        sys.__stopAsync(sys)\n        return\n      }\n      if (sys.tryIndex >= 0) {\n        sys.index = sys.tryIndex;\n        setTimeout(() => {sys.nextAsync(sys)}, 1)\n      } else {\n        throw e\n      }\n    }\n    this.__call = (no, sys) => {\n      const info = {lastVars:sys.__vars, backNo: this.index + 1}\n      sys.__callstack.push(info);\n      sys.__vars = {\"それ\":\"\"}\n      sys.__varslist.push(sys.__vars)\n      sys.nextIndex = no;\n    }\n    this.__return = sys => {\n      if (sys.__callstack.length === 0) {\n        sys.__destroySysenv(sys, sys.curSysenv.envid)\n        sys.index = -2\n        sys.nextIndex = -1\n        return\n      }\n      const sore = sys.__vars['それ'];\n      sys.__varslist.pop();\n      const info = sys.__callstack.pop();\n      sys.nextIndex = info.backNo;\n      sys.__vars = info.lastVars;\n      sys.__vars['それ'] = sore\n      sys.__stack.push(sore);\n    }\n    this.__resetAsync = sys => {\n      sys.index = 0\n      sys.codeSize = ${codes.length};\n      sys.async = false\n      sys.nextIndex = -1\n      sys.tryIndex = -1\n    }\n    this.__stopAsync = sys => {\n      sys.__resetAsync(sys)\n      sys.index = -1 // force stop!!\n    }\n    this.__callNakoCode = (no, backNo, sys) => {\n      this.__call(backNo, sys)\n      sys.nextIndex = no\n      const sysenv = sys.setAsync(sys)\n      setTimeout(() => {\n        // console.log('//__callNakoCode, back=', backNo, 'no=', no)\n        sys.compAsync(sys, sysenv)\n      } ,1)\n    }\n    this.__callNakoCodeEntry = (no, sys) => {\n      sys.__saveSysenv(sys)\n      sys.curSysenv = sys.__generateSysenv(sys)\n      sys.__restoreSysenv(sys)\n      sys.__vars = {\"それ\":\"\"}\n      sys.__varslist.push(sys.__vars)\n      sys.index = no;\n      sys.nextAsync(sys)\n    }\n    this.__callObj = (vname, curNo, sys) => {\n      if (sys.__vars[vname]) {\n        const fname = sys.__vars[vname]\n        // console.log(sys.__labels)\n        if (fname && sys.__labels[fname]) {\n          const no = sys.__labels[fname]\n          sys.__call(no, sys)\n          return\n        } else {\n          console.log('vname=', vname, 'label=', fname)\n        }\n      }\n      throw new Error('async error in __callObj::', vname)\n    }\n    this.__generateSysenv = sys => {\n      sys.envid = ( sys.envid == null ? 0 : sys.envid ) + 1\n      const sysenv = {\n        callstack: [],\n        varstack: [],\n        varslist: [sys.__varslist[0], sys.__varslist[1], sys.__varslist[2]],\n        index: -1,\n        nextIndex: -1,\n        tryIndex: -1,\n        envid: sys.envid\n      }\n      sysenv.vars = sysenv.varslist[2]\n      if (sys.sysenvs == null) { sys.sysenvs={} }\n      sys.sysenvs[sys.envid] = sysenv\n      // console.log('generete envid '+sys.envid)\n      return sysenv\n    }\n    this.__destroySysenv = (sys, envid) => {\n      delete sys.sysenvs[envid]\n      // console.log('destroy envid '+envid)\n    }\n    this.__saveSysenv = sys => {\n      const sysenv = sys.curSysenv\n      sysenv.callstack = sys.__callstack\n      sysenv.varstack = sys.__stack\n      sysenv.varslist = sys.__varslist\n      sysenv.vars = sys.__vars\n      sysenv.index = sys.index\n      sysenv.nextIndex = sys.nextIndex\n      sysenv.tryIndex = sys.tryIndex\n    }\n    this.__restoreSysenv = sys => {\n      const sysenv = sys.curSysenv\n      sys.__callstack = sysenv.callstack\n      sys.__stack = sysenv.varstack\n      sys.__varslist = sysenv.varslist\n      sys.__vars = sysenv.vars\n      ___vars = sys.__vars\n      sys.index = sysenv.index\n      sys.nextIndex = sysenv.nextIndex\n      sys.tryIndex = sysenv.tryIndex\n    }\n    this.setAsync = sys => {\n      sys.async = true\n      return sys.curSysenv\n    }\n    this.compAsync = (sys,sysenv) => {\n      if (sys.async && sys.curSysenv != null && sysenv != null && sys.curSysenv.envid === sysenv.envid) {\n        sys.async = false\n      } else {\n        if (sys.curSysenv == null || sysenv == null || sys.curSysenv.envid !== sysenv.envid) {\n          sys.__saveSysenv(sys)\n          const envid = sys.curSysenv.envid\n          sys.curSysenv = sysenv\n          sys.__restoreSysenv(sys)\n          // console.log('switch envid '+envid+' to '+sys.curSysenv.envid)\n        }\n        sys.nextAsync(sys)\n      }\n    }\n\n    this.__resetAsync(this)\n    this.curSysenv = this.__generateSysenv(this)\n    this.nextAsync(this)\n    //-------------------------\n    `;\n        if (isTest) {\n            return '';\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    _convGen(node, isExpression) {\n        let code = '';\n        if (node instanceof Array) {\n            for (let i = 0; i < node.length; i++) {\n                const n = node[i];\n                code += this._convGen(n, isExpression);\n            }\n            return code;\n        }\n        if (node === null) {\n            return 'null';\n        }\n        if (node === undefined) {\n            return 'undefined';\n        }\n        if (typeof (node) !== 'object') {\n            return '' + node;\n        }\n        // switch\n        switch (node.type) {\n            // === NOP ===\n            case 'nop':\n                break;\n            case 'comment':\n                if (!node.value) {\n                    node.value = '';\n                }\n                this.addCode(new NakoCode(NakoCodeNop, node.value));\n                break;\n            case 'eol':\n                this.addCode(new NakoCode(NakoCodeEOL, this.convLineno(node, true)));\n                break;\n            // === 単純なコード変換 ===\n            case 'number':\n                this.addCodeStr(`sys.__stack.push(${node.value});//number`);\n                break;\n            case 'string':\n                this.convString(node);\n                break;\n            case 'word':\n            case 'variable':\n                this.convGetVar(node);\n                break;\n            case 'op':\n            case 'calc':\n                this.convOp(node);\n                break;\n            case 'renbun':\n                this.convRenbun(node);\n                break;\n            case 'not':\n                this._convGen(node.value, true);\n                this.addCodeStr('if (sys.__stack.length==0) throw new Error(\\'NOTでスタックに値がありません\\');' +\n                    'sys.__stack[sys.__stack.length-1] = (sys.__stack[sys.__stack.length-1]) ? 0:1');\n                break;\n            case '配列参照':\n                this.convRefArray(node);\n                break;\n            case 'json_array':\n                this.convJsonArray(node);\n                break;\n            case 'json_obj':\n                this.convJsonObj(node);\n                break;\n            case 'bool':\n                {\n                    const b = (node.value) ? 'true' : 'false';\n                    this.addCodeStr(`sys.__stack.push(${b})`);\n                    break;\n                }\n            case 'null':\n                this.addCodeStr('sys.__stack.push(null)');\n                break;\n            case 'func':\n            case 'func_pointer':\n            case 'calc_func':\n                this.convFunc(node, isExpression); // 関数の呼び出し\n                break;\n            // === 文の変換 ===\n            case 'let':\n                this.convLet(node);\n                break;\n            case 'let_array':\n                this.convLetArray(node);\n                break;\n            case 'block':\n                for (let i = 0; i < node.block.length; i++) {\n                    const b = node.block[i];\n                    this._convGen(b, false);\n                }\n                break;\n            case 'if':\n                this.convIf(node);\n                break;\n            case 'repeat_times':\n                this.convRepeatTimes(node);\n                break;\n            case 'break':\n                this.addCodeStr(this.convCheckLoop(node, 'break'));\n                break;\n            case 'continue':\n                this.addCodeStr(this.convCheckLoop(node, 'continue'));\n                break;\n            case 'for':\n                this.convFor(node);\n                break;\n            case 'foreach':\n                this.convForeach(node);\n                break;\n            case 'while':\n                this.convWhile(node);\n                break;\n            case 'switch':\n                this.convSwitch(node);\n                break;\n            case 'return':\n                this.convReturn(node);\n                break;\n            case 'end':\n                code += this.addCodeStr('__varslist[0][\\'終\\']();');\n                break;\n            case 'def_local_var':\n                this.convDefLocalVar(node);\n                break;\n            case 'def_local_varlist':\n                code += this.addCodeStr(this.convDefLocalVarlist(node));\n                break;\n            case 'tikuji':\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('「逐次実行」構文は「!非同期モード」では使えません。', node);\n            case 'speed_mode':\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('「速度有線」構文は「!非同期モード」では使えません。', node);\n            case 'performance_monitor':\n                this.convPerformanceMonitor(node, isExpression);\n                break;\n            case 'func_obj':\n                this.convFuncObj(node);\n                break;\n            case 'def_test':\n                this.convDefTest(node);\n                break;\n            case 'def_func':\n                code += this.addCodeStr(this.convDefFunc(node));\n                break;\n            // TODO\n            case 'try_except':\n                code += this.convTryExcept(node);\n                break;\n            case 'require':\n                code += this.convRequire(node);\n                break;\n            default:\n                throw new Error('System Error: unknown_type=' + node.type);\n        }\n        return code;\n    }\n    convRequire(node) {\n        const gen = new _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen(this.com);\n        this.addCodeStr(gen.convRequire(node));\n        return '';\n    }\n    /**\n     * add code to array\n     * @param {string} codeStr\n     * @returns {string}\n     */\n    addCodeStr(codeStr) {\n        if (codeStr === '') {\n            return '';\n        }\n        const a = codeStr.split('\\n');\n        const a2 = a.map((row) => '  ' + row.replace(/\\s+$/, ''));\n        const c = new NakoCode(NakoCodeCode, a2.join('\\n'));\n        return this.addCode(c);\n    }\n    /**\n     * add code to array\n     * @param {NakoCode} code\n     * @returns {string}\n     */\n    addCode(code) {\n        this.codeArray[this.codeId] = code;\n        this.codeId++;\n        return '';\n    }\n    /**\n     * make label for jump\n     * @param {string} name\n     * @returns {NakoCode}\n     */\n    makeLabel(name) {\n        const uniqLabel = name + '_' + (this.loopId++);\n        return this.makeLabelDirectly(uniqLabel);\n    }\n    /**\n     * make label for function\n     * @param {string} labelName\n     * @returns {NakoCode}\n     */\n    makeLabelDirectly(labelName) {\n        const c = new NakoCode(NakoCodeLabel, labelName);\n        this.labels[labelName] = -1;\n        return c;\n    }\n    /**\n     * make Jump\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJump(label) {\n        return new NakoCode(NakoCodeJump, label.value);\n    }\n    /**\n     * make Jump if true\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJumpIfTrue(label) {\n        return new NakoCode(NakoCodeJumpIfTrue, label.value);\n    }\n    /**\n     * make Jump if false\n     * @param {NakoCode} label\n     * @returns {NakoCode}\n     */\n    makeJumpIfFalse(label) {\n        return new NakoCode(NakoCodeJumpIfFalse, label.value);\n    }\n    /**\n     * @param {Ast} node\n     */\n    convIf(node) {\n        const labelBegin = this.makeLabel('もし:ここから');\n        const labelEnd = this.makeLabel('もし:ここまで');\n        const labelIfFalse = this.makeLabel('もし:違えば');\n        //\n        this.addCode(labelBegin);\n        this._convGen(node.expr, true);\n        this.addCode(this.makeJumpIfFalse(labelIfFalse));\n        this._convGen(node.block, false);\n        this.addCode(this.makeJump(labelEnd));\n        this.addCode(labelIfFalse);\n        if (node.falseBlock) {\n            this._convGen(node.falseBlock, false);\n        }\n        this.addCode(labelEnd);\n        return '';\n    }\n    convRepeatTimes(node) {\n        this.flagLoop = true;\n        this.varsSet.names.add('回数');\n        this.varsSet.readonly.add('回数');\n        // ループ管理変数を作成\n        const loopVar = `sys.__tmp_i${this.loopId}`;\n        this.loopId++;\n        // ループ回数を取得\n        const loopCount = `sys.__tmp_count${this.loopId}`;\n        this.loopId++;\n        this._convGen(node.value, true);\n        this.addCodeStr(`${loopCount} = sys.__stack.pop(); ${loopVar} = 0;`);\n        const labelCheck = this.makeLabel('回:条件チェック');\n        this.addCode(labelCheck);\n        const labelEnd = this.makeLabel('回:ここまで');\n        this.labelBreak = labelEnd;\n        this.labelContinue = labelCheck;\n        // 繰り返し判定\n        const kaisu = 'sys.__vars[\"回数\"]';\n        const cond = `${kaisu} = ++${loopVar}\\n` +\n            `sys.__stack.push(${loopVar} > ${loopCount})\\n`;\n        this.addCodeStr(cond);\n        this.addCode(this.makeJumpIfTrue(labelEnd));\n        this.convGenLoop(node.block); // read block\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    /**\n     * @param {string} name\n     * @returns {{i: number, name: string, isTop: boolean, js: string} | null}\n     */\n    findVar(name) {\n        // __vars ? (ローカル変数)\n        if (this.varsSet.names.has(name)) {\n            return { i: this.varslistSet.length - 1, name, isTop: true, js: `sys.__vars[${JSON.stringify(name)}]` };\n        }\n        // __varslist ?\n        for (let i = 2; i >= 0; i--) {\n            if (this.varslistSet[i].names.has(name)) {\n                return { i, name, isTop: false, js: `sys.__varslist[${i}][${JSON.stringify(name)}]` };\n            }\n        }\n        return null;\n    }\n    /**\n     * 定義済みの変数の参照\n     * @param {string} name\n     * @param {Ast} position\n     */\n    genVar(name, position) {\n        const res = this.findVar(name);\n        const lno = position.line;\n        if (res === null) {\n            // 定義されていない名前の参照は変数の定義とみなす。\n            // 多くの場合はundefined値を持つ変数であり分かりづらいバグを引き起こすが、\n            // 「ナデシコする」などの命令の中で定義された変数の参照の場合があるため警告に留める。\n            // ただし、自動的に定義される変数『引数』『それ』などは例外 #952\n            if (name === '引数' || name === 'それ' || name === '対象' || name === '対象キー' || name === '回数') {\n                // デフォルト定義されている変数名\n            }\n            else {\n                this.__self.getLogger().warn(`変数『${name}』は定義されていません。`, position);\n            }\n            this.varsSet.names.add(name);\n            return this.varname(name);\n        }\n        const i = res.i;\n        // システム関数・変数の場合\n        if (i === 0) {\n            const pv = this.__self.getFunc(name);\n            if (!pv) {\n                return `${res.js}/*err:${lno}*/`;\n            }\n            if (pv.type === 'const' || pv.type === 'var') {\n                return res.js;\n            }\n            if (pv.type === 'func') {\n                if (!pv.josi) {\n                    throw new Error('[System Error]');\n                }\n                if (pv.josi.length === 0) {\n                    return `(${res.js}())`;\n                }\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』が複文で使われました。単文で記述してください。(v1非互換)`, position);\n            }\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${name}』は関数であり参照できません。`, position);\n        }\n        return res.js;\n    }\n    convGetVar(node) {\n        const name = node.value;\n        let varName = `sys.__vars[${JSON.stringify(name)}]`;\n        const o = this.findVar(name);\n        if (o != null) {\n            varName = o.js;\n        }\n        this.addCodeStr(`sys.__stack.push(${varName});`);\n    }\n    convComment(node) {\n        let commentSrc = String(node.value);\n        commentSrc = commentSrc.replace(/\\n/g, '¶');\n        const lineNo = this.convLineno(node, false);\n        if (commentSrc === '' && lineNo === '') {\n            return ';';\n        }\n        if (commentSrc === '') {\n            return ';' + lineNo + '\\n';\n        }\n        return ';' + lineNo + '//' + commentSrc + '\\n';\n    }\n    convReturn(node) {\n        // 関数の中であれば利用可能\n        if (this.varsSet.names.has('!関数')) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『戻る』がありますが、関数定義内のみで使用可能です。', node);\n        }\n        if (node.value) {\n            this._convGen(node.value, true);\n            this.addCodeStr('sys.__vars[\"それ\"] = sys.__stack.pop()');\n        }\n        this.addCode(new NakoCode(NakoCodeReturn, ''));\n        return '';\n    }\n    convCheckLoop(node, cmd) {\n        // ループの中であれば利用可能\n        if (!this.flagLoop) {\n            const cmdj = (cmd === 'continue') ? '続ける' : '抜ける';\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${cmdj}』文がありますが、それは繰り返しの中で利用してください。`, node);\n        }\n        if (cmd === 'continue') {\n            if (this.labelContinue) {\n                this.addCode(this.makeJump(this.labelContinue));\n            }\n        }\n        else {\n            if (this.labelBreak) {\n                this.addCode(this.makeJump(this.labelBreak));\n            }\n        }\n        return '';\n    }\n    convDefFuncCommon(node, name) {\n        // deffunc_code\n        const isMumeiFunc = (name === '');\n        let funcName = name;\n        if (isMumeiFunc) {\n            funcName = `無名関数:${this.loopId++}`;\n        }\n        const labelEnd = this.makeLabel(`関数「${funcName}」:ここまで`);\n        this.addCode(this.makeJump(labelEnd));\n        const labelBegin = this.makeLabelDirectly(funcName);\n        labelBegin.tag = NakoCodeTagIsFuncpoint; // 削除対象からはずすため\n        this.addCode(labelBegin);\n        //\n        const initialNames = new Set();\n        this.varsSet = { isFunction: true, names: initialNames, readonly: new Set() };\n        this.varsSet.names.add('それ');\n        // ローカル変数をPUSHする\n        this.varslistSet.push(this.varsSet);\n        // JSの引数と引数をバインド\n        const meta = isMumeiFunc ? node.meta : node.name.meta;\n        let code = '';\n        let codeCall = '';\n        code += `//関数『${funcName}』の初期化処理\\n`;\n        // 宣言済みの名前を保存\n        // const varsDeclared = Array.from(this.varsSet.names.values())\n        // 引数をローカル変数に設定 (スタックの末尾から取得する必要があるので、逆順に値を得る)\n        code += '// 引数をローカル変数として登録\\n';\n        for (let i = meta.varnames.length - 1; i >= 0; i--) {\n            const word = meta.varnames[i];\n            code += `  ${this.varname(word)} = sys.__stack.pop();\\n`;\n            this.varsSet.names.add(word);\n            codeCall += ''; //  sys.__stack.push(arguments[${i}]);\\n\n        }\n        code += '// ここまで:引数をローカル変数として登録\\n';\n        this.addCodeStr(code);\n        // 関数定義は、グローバル領域で。\n        this.usedFuncSet.add(funcName);\n        this.varslistSet[1].names.add(funcName);\n        this.nakoFuncList[funcName] = {\n            josi: meta.josi,\n            fn: '(function(){\\n' +\n                '  const sys = (arguments.length > 0) ? arguments[arguments.length-1] : {}; \\n' +\n                '  if (sys.newenv) { \\n' +\n                '    sys.newenv = false\\n' +\n                `    sys.__callNakoCodeEntry(sys.__labels['${funcName}'], sys);` + '\\n' +\n                '  } else {\\n' +\n                '  ' + codeCall + '\\n' +\n                `    sys.__callNakoCode(sys.__labels['${funcName}'], sys.nextIndex, sys);` + '\\n' +\n                '    if (!sys.inLoop) { sys.nextAsync(sys) }\\n' +\n                '  }  })',\n            type: 'func'\n        };\n        // ブロックを解析\n        this._convGen(node.block, false);\n        this.varslistSet.pop();\n        this.varsSet = this.varslistSet[this.varslistSet.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this.__self.__varslist[1][funcName] = function () { };\n        this.addCode(new NakoCode(NakoCodeReturn, ''));\n        this.addCode(labelEnd);\n        // 無名関数の定義であれば無名関数をPUSH\n        if (!name) {\n            this.addCodeStr(`sys.__stack.push('${funcName}')`);\n        }\n        return '';\n    }\n    convDefTest(node) {\n        throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('テスト構文は!非同期モードでは使えません。', node);\n    }\n    convDefFunc(node) {\n        const name = _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen.getFuncName(node.name.value);\n        this.convDefFuncCommon(node, name);\n        // ★この時点では関数のコードを生成しない★\n        // プログラム冒頭でコード生成時に関数定義を行う\n        return '';\n    }\n    convFuncObj(node) {\n        return this.convDefFuncCommon(node, '');\n    }\n    convJsonObj(node) {\n        const list = node.value;\n        const objName = `sys.__tmp_obj${this.loopId++}`;\n        this.addCodeStr(objName + '={}; // convJsonObj::ここから');\n        list.forEach((e) => {\n            this._convGen(e.value, true);\n            this._convGen(e.key, true);\n            this.addCodeStr(`${objName}[sys.__stack.pop()]=sys.__stack.pop()`);\n        });\n        this.addCodeStr(`this.__stack.push(${objName}); delete $objName; // convJsonObj::ここまで`);\n        return '';\n    }\n    convJsonArray(node) {\n        const list = node.value;\n        this.addCode(this.makeLabel('convJsonArray::ここから'));\n        list.forEach((e) => this._convGen(e, true));\n        const size = list.length;\n        this.addCodeStr(`sys.__stack.push(sys.__stack.splice(sys.__stack.length-${size},${size}))`);\n        return '';\n    }\n    convRefArray(node) {\n        // 名前をPUSH\n        this._convGen(node.name, true);\n        const list = node.index;\n        for (let i = 0; i < list.length; i++) {\n            // push index\n            this._convGen(list[i], true);\n            // pop index & push value\n            this.addCodeStr('const idx = sys.__stack.pop();\\n' +\n                'const obj = sys.__stack.pop();\\n' +\n                'sys.__stack.push(obj[idx]);');\n        }\n        return '';\n    }\n    convLetArray(node) {\n        // 代入する値をPUSH\n        this._convGen(node.value, true);\n        // 変数を取得\n        this._convGen(node.name, true);\n        const list = node.index;\n        for (let i = 0; i < list.length; i++) {\n            this._convGen(list[i], true);\n            if (i === list.length - 1) { // 代入\n                this.addCodeStr('const idx = this.__stack.pop();' +\n                    'const obj = this.__stack.pop();' +\n                    'const val = this.__stack.pop();' +\n                    'obj[idx]=val;');\n                break;\n            }\n            // index アクセス\n            this.addCodeStr('const idx = sys.__stack.pop();\\n' +\n                'const obj = sys.__stack.pop();\\n' +\n                'sys.__stack.push(obj[idx]);');\n        }\n        return '';\n    }\n    convGenLoop(node) {\n        const tmpflag = this.flagLoop;\n        this.flagLoop = true;\n        try {\n            return this._convGen(node, false);\n        }\n        finally {\n            this.flagLoop = tmpflag;\n        }\n    }\n    convFor(node) {\n        this.flagLoop = true;\n        // ループ変数について\n        let word;\n        if (node.word !== null) { // ループ変数を使う時\n            const varName = node.word.value;\n            this.varsSet.names.add(varName);\n            word = this.varname(varName);\n        }\n        else {\n            this.varsSet.names.add('dummy');\n            word = this.varname('dummy');\n        }\n        const sore = this.varname('それ');\n        const idLoop = this.loopId++;\n        const varI = `sys.__tmp__i${idLoop}`;\n        // ループ条件を変数に入れる用\n        const varTo = `sys.__tmp__to${idLoop}`;\n        // ループ条件を確認\n        this._convGen(node.from, true);\n        this._convGen(node.to, true);\n        this.addCodeStr(`${varTo}=sys.__stack.pop();${varI}=sys.__stack.pop();`);\n        // ループ変数を初期化\n        this.addCodeStr(`${sore} = ${word} = ${varI}`);\n        // 繰り返し判定\n        const labelCheck = this.makeLabel('繰返:条件確認');\n        const labelInc = this.makeLabel('繰返:加算');\n        this.addCode(labelCheck);\n        const labelEnd = this.makeLabel('繰返:ここまで');\n        this.addCodeStr(`sys.__stack.push(${word} <= ${varTo})`);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        this.labelContinue = labelInc;\n        this.labelBreak = labelEnd;\n        // ループ内のブロック内容を得る\n        this.convGenLoop(node.block); // block\n        this.addCode(labelInc);\n        this.addCodeStr(`${sore} = ++${word};`);\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.addCodeStr(`delete ${varI};delete ${varTo};//繰返:掃除`);\n        this.flagLoop = false;\n        return '';\n    }\n    convForeach(node) {\n        this.flagLoop = true;\n        // 対象を用意する\n        let taisyo = '__v0[\"対象\"]';\n        const taisyoKey = '__v0[\"対象キー\"]';\n        if (node.name) {\n            taisyo = this.varname(node.name.value);\n            this.varsSet.names.add(node.name.value);\n        }\n        // 反復対象を調べる\n        const target = node.target;\n        if (target === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode('『反復』の対象がありません。', node);\n        }\n        const sore = this.varname('それ');\n        const targetArray = `sys.__tmp__target${this.loopId++}`;\n        const targetKeys = `sys.__tmp__keys${this.loopId++}`;\n        const loopVar = `sys.__tmp__i${this.loopId++}`;\n        const loopCount = `sys.__tmp__count${this.loopId++}`;\n        // 反復対象を評価\n        this._convGen(node.target, true);\n        // どのように反復するか判定\n        const initCode = '// 反復: 初期化\\n' +\n            `${targetArray} = sys.__stack.pop();\\n` +\n            `${loopVar} = 0;\\n` +\n            // 文字列や数値なら反復できるように配列に入れる\n            `if (typeof(${targetArray}) == 'string' || typeof(${targetArray}) == 'number') { ${targetArray} = [${targetArray}]; }\\n` +\n            // Objectならキー一覧を得る\n            `if (${targetArray} instanceof Array) { ${loopCount} = ${targetArray}.length; }\\n` +\n            'else { // キーの一覧を得る\\n' +\n            `  ${targetKeys} = Object.keys(${targetArray}); \\n` +\n            '  // hasOwnPropertyがfalseならばkeyを消す処理\\n' +\n            `  ${targetKeys} = ${targetKeys}.filter((key)=>{ return ${targetArray}.hasOwnProperty(key) })\\n` +\n            `  ${loopCount} = ${targetKeys}.length;\\n` +\n            '}\\n';\n        this.addCodeStr(initCode);\n        const labelCheck = this.makeLabel('反復:条件確認');\n        const labelInc = this.makeLabel('反復:加算');\n        const labelEnd = this.makeLabel('反復:ここまで');\n        this.labelBreak = labelEnd;\n        this.labelContinue = labelInc;\n        this.addCode(labelCheck);\n        const setTarget = `if (${targetArray} instanceof Array) {\\n` +\n            // eslint-disable-next-line no-irregular-whitespace\n            `  ${taisyo} = ${sore} = ${targetArray}[${loopVar}];　${taisyoKey} = ${loopVar};\\n` +\n            '} else {\\n' +\n            `  ${taisyoKey} = ${targetKeys}[${loopVar}]; ${taisyo} = ${sore} = ${targetArray}[${taisyoKey}];\\n` +\n            '}\\n';\n        this.addCodeStr(`${setTarget}\\nsys.__stack.push(${loopVar} < ${loopCount});`);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        // 反復ブロックを定義\n        this.convGenLoop(node.block); // block\n        // 加算\n        this.addCode(labelInc);\n        this.addCodeStr(`${loopVar}++`);\n        this.addCode(this.makeJump(labelCheck));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    convWhile(node) {\n        this.flagLoop = true;\n        const labelBegin = this.makeLabel('間:ここから');\n        const labelEnd = this.makeLabel('間:ここまで');\n        this.labelContinue = labelBegin;\n        this.labelBreak = labelEnd;\n        this.addCode(labelBegin);\n        // 条件をスタックに\n        this._convGen(node.cond, true);\n        this.addCode(this.makeJumpIfFalse(labelEnd));\n        // ブロックを追加\n        this.convGenLoop(node.block);\n        this.addCode(this.makeJump(labelBegin));\n        this.addCode(labelEnd);\n        this.flagLoop = false;\n        return '';\n    }\n    /**\n     * @param {Ast} _node\n     * @param {boolean} _isExpression\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    convSpeedMode(_node, _isExpression) {\n        return '';\n    }\n    /**\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     */\n    convPerformanceMonitor(node, isExpression) {\n        const prev = { ...this.performanceMonitor };\n        if (node.options['ユーザ関数']) {\n            this.performanceMonitor.userFunction++;\n        }\n        if (node.options['システム関数本体']) {\n            this.performanceMonitor.systemFunctionBody++;\n        }\n        if (node.options['システム関数']) {\n            this.performanceMonitor.systemFunction++;\n        }\n        this._convGen(node.block, isExpression);\n        this.performanceMonitor = prev;\n    }\n    convSwitch(node) {\n        // 値をPUSH\n        this._convGen(node.value, true);\n        const varValue = `sys.__tmp__i${this.loopId++}`;\n        this.addCodeStr(`${varValue} = sys.__stack.pop()`);\n        const labelEnd = this.makeLabel('条件分岐:ここまで');\n        const cases = node.cases;\n        for (let i = 0; i < cases.length; i++) {\n            const cvalue = cases[i][0];\n            if (cvalue.type === '違えば') {\n                this.convGenLoop(cases[i][1]);\n            }\n            else {\n                const nextLabel = this.makeLabel('条件分岐:次');\n                this._convGen(cvalue, true);\n                this.addCodeStr(`sys.__stack.push(sys.__stack.pop() == ${varValue})`);\n                this.addCode(this.makeJumpIfFalse(nextLabel));\n                this.convGenLoop(cases[i][1]);\n                this.addCode(this.makeJump(labelEnd));\n                this.addCode(nextLabel);\n            }\n        }\n        this.addCode(labelEnd);\n        this.addCodeStr(`delete ${varValue}//条件分岐:掃除`);\n        return '';\n    }\n    convFuncGetArgsCalcType(funcName, func, node) {\n        const opts = {};\n        for (let i = 0; i < node.args.length; i++) {\n            const arg = node.args[i];\n            if (i === 0 && arg === null) {\n                this.addCodeStr('sys.__stack.push(sys.__vars[\\'それ\\'])');\n                opts.sore = true;\n            }\n            else {\n                // 関数の引数を評価\n                this._convGen(arg, true);\n            }\n        }\n        return opts;\n    }\n    getPluginList() {\n        const r = [];\n        for (const name in this.__self.__module) {\n            r.push(name);\n        }\n        return r;\n    }\n    /**\n     * 関数の呼び出し\n     * @param {Ast} node\n     * @param {boolean} isExpression\n     * @returns string コード\n     */\n    convFunc(node, isExpression) {\n        let isJSFunc = false;\n        let isMumeiFunc = false;\n        const funcName = _nako_gen_mjs__WEBPACK_IMPORTED_MODULE_2__.NakoGen.getFuncName(node.name);\n        const res = this.findVar(funcName);\n        if (res === null) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`関数『${funcName}』が見当たりません。有効プラグイン=[` + this.getPluginList().join(', ') + ']', node);\n        }\n        let func;\n        if (res.i === 0) { // plugin function\n            func = this.__self.getFunc(funcName);\n            if (func.type !== 'func') {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`『${funcName}』は関数ではありません。`, node);\n            }\n            isJSFunc = true;\n        }\n        else {\n            func = this.nakoFuncList[funcName];\n            // 無名関数の可能性\n            if (func === undefined) {\n                isMumeiFunc = true;\n                func = { return_none: false };\n            }\n        }\n        // 関数の参照渡しか？\n        if (node.type === 'func_pointer') {\n            return res.js;\n        }\n        // 関数の参照渡しでない場合\n        // 関数定義より助詞を一つずつ調べる\n        const argsOpts = this.convFuncGetArgsCalcType(funcName, func, node);\n        // function\n        this.usedFuncSet.add(funcName);\n        let funcBegin = '';\n        let funcEnd = '';\n        // setter?\n        if (node.setter) {\n            funcBegin += ';__self.isSetter = true;\\n';\n            funcEnd += ';__self.isSetter = false;\\n';\n        }\n        // 変数「それ」が補完されていることをヒントとして出力\n        if (argsOpts.sore) {\n            funcBegin += '/*[sore]*/';\n        }\n        // 引数をスタックに積む\n        const arcCount = node.args.length;\n        // 必要な引数分だけスタックから下ろして呼び出す\n        let code = '';\n        if (isJSFunc) {\n            code += funcBegin;\n            code += `const args = sys.__stack.splice(sys.__stack.length - ${arcCount}, ${arcCount});\\n`;\n            // code += `console.log(\"call:${funcName}\", args, 'sys');\\n`\n            code += 'args.push(sys);\\n';\n            code += `const ret = ${res.js}.apply(sys, args);\\n`;\n            if (!func.return_none) {\n                code += 'sys.__vars[\\'それ\\'] = ret;\\n';\n                if (isExpression) {\n                    code += 'sys.__stack.push(ret);\\n';\n                }\n            }\n            code += funcEnd;\n            this.addCodeStr(code);\n        }\n        else {\n            if (isMumeiFunc) {\n                this.addCode(new NakoCode(NakoCodeCallObj, funcName));\n            }\n            else {\n                this.addCode(new NakoCode(NakoCodeCall, funcName));\n            }\n            if (!isExpression) {\n                this.addCodeStr('sys.__stack.pop();// 戻り値を利用しない関数呼出');\n            }\n        }\n    }\n    convRenbun(node) {\n        this._convGen(node.left, false);\n        this._convGen(node.right, true);\n    }\n    convOp(node) {\n        const OP_TBL = {\n            '&': '+\"\"+',\n            eq: '==',\n            noteq: '!=',\n            '===': '===',\n            '!==': '!==',\n            gt: '>',\n            lt: '<',\n            gteq: '>=',\n            lteq: '<=',\n            and: '&&',\n            or: '||',\n            shift_l: '<<',\n            shift_r: '>>',\n            shift_r0: '>>>',\n            '÷': '/'\n        };\n        const op = node.operator; // 演算子\n        // 値はスタックに載せられる\n        // left\n        this._convGen(node.left, true);\n        // right\n        this._convGen(node.right, true);\n        // calc\n        let code = 'const rv = sys.__stack.pop();\\n' +\n            'const lv = sys.__stack.pop();\\n';\n        if (op === '^') {\n            code += 'const v = (Math.pow(lv, rv))\\n';\n        }\n        else {\n            const op2 = OP_TBL[op] || op;\n            code += `const v = ((lv) ${op2} (rv));\\n`;\n        }\n        // code += `if (isNaN(v) && '${op}' != '&') { console.log('ERROR:${op}', lv, rv) }\\n`\n        code += `sys.__stack.push(v); //op:${op}\\n`;\n        this.addCodeStr(code);\n    }\n    convLet(node) {\n        let code = '';\n        // 値をスタックに載せる\n        if (node.value === null) {\n            // 値が省略されたら「それ」を載せる\n            this.addCodeStr('sys.__stack.push(sys.__vars[\\'それ\\'])');\n        }\n        else {\n            // 値がある場合\n            this._convGen(node.value, true);\n        }\n        // 変数名\n        const name = node.name.value;\n        const res = this.findVar(name);\n        if (res === null) {\n            this.varsSet.names.add(name);\n            code = `${this.varname(name)}=sys.__stack.pop();`;\n        }\n        else {\n            // 定数ならエラーを出す\n            if (this.varslistSet[res.i].readonly.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`定数『${name}』は既に定義済みなので、値を代入することはできません。`, node);\n            }\n            code = `${res.js}=sys.__stack.pop();`;\n        }\n        this.addCodeStr(code + '//let');\n    }\n    convDefLocalVar(node) {\n        if (node.value === null) {\n            this.addCodeStr('sys.__stack.push(null)');\n        }\n        else {\n            this._convGen(node.value, true);\n        }\n        const name = node.name.value;\n        const vtype = node.vartype; // 変数 or 定数\n        // 二重定義？\n        if (this.varsSet.names.has(name)) {\n            throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n        }\n        this.varsSet.names.add(name);\n        // 定数?\n        if (vtype === '定数') {\n            this.varsSet.readonly.add(name);\n        }\n        this.addCodeStr(`${this.varname(name)}=sys.__stack.pop()`);\n        return '';\n    }\n    // #563 複数変数への代入\n    convDefLocalVarlist(node) {\n        const vtype = node.vartype; // 変数 or 定数\n        if (node.value === null) {\n            this.addCodeStr('sys.__stack.push(null)');\n        }\n        else {\n            this._convGen(node.value, true);\n        }\n        const varI = `sys.__tmp_i${this.loopId}`;\n        this.loopId++;\n        this.addCodeStr(`${varI}=sys.__stack.pop();if (!(${varI} instanceof Array)) { ${varI}=[${varI}] }`);\n        for (const nameObj of node.names) {\n            const name = nameObj.value;\n            // 二重定義？\n            if (this.varsSet.names.has(name)) {\n                throw _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.NakoSyntaxError.fromNode(`${vtype}『${name}』の二重定義はできません。`, node);\n            }\n            //\n            this.varsSet.names.add(name);\n            if (vtype === '定数') {\n                this.varsSet.readonly.add(name);\n            }\n            const vname = this.varname(name);\n            this.addCodeStr(`${vname}=${varI}.pop()`);\n        }\n        this.addCodeStr(`delete ${varI}//複数代入:掃除`);\n        return '';\n    }\n    convString(node) {\n        let value = '' + node.value;\n        const mode = node.mode;\n        value = value.replace(/\\\\/g, '\\\\\\\\');\n        value = value.replace(/\"/g, '\\\\\"');\n        value = value.replace(/\\r/g, '\\\\r');\n        value = value.replace(/\\n/g, '\\\\n');\n        if (mode === 'ex') {\n            throw new Error('[システムエラー] ジェネレーターでの文字列の展開はサポートしていません');\n        }\n        this.addCodeStr(`sys.__stack.push(\"${value}\")//string`);\n        return '\"' + value + '\"';\n    }\n    convTryExcept(node) {\n        const labelExcept = this.makeLabel('エラー監視:ならば');\n        const labelEnd = this.makeLabel('エラー監視:ここまで');\n        // エラーをひっかけるように設定\n        this.addCode(new NakoCode(NakoCodeTry, labelExcept.value));\n        this._convGen(node.block, false);\n        this.addCode(this.makeJump(labelEnd));\n        this.addCode(labelExcept);\n        this._convGen(node.errBlock, false);\n        this.addCode(labelEnd);\n    }\n}\n// ブラウザに登録する\nif (typeof (navigator) === 'object' && typeof (navigator.nako3) === 'object') {\n    // Webブラウザの場合\n    const nako3 = navigator.nako3;\n    if (nako3.addCodeGenerator) {\n        nako3.addCodeGenerator('非同期モード', NakoGenASync);\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_gen_async.mjs?")},"./core/src/nako_josi_list.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"josiList\": function() { return /* binding */ josiList; },\n/* harmony export */   \"josiRE\": function() { return /* binding */ josiRE; },\n/* harmony export */   \"removeJosiList\": function() { return /* binding */ removeJosiList; },\n/* harmony export */   \"removeJosiMap\": function() { return /* binding */ removeJosiMap; },\n/* harmony export */   \"tararebaJosiList\": function() { return /* binding */ tararebaJosiList; },\n/* harmony export */   \"tararebaMap\": function() { return /* binding */ tararebaMap; }\n/* harmony export */ });\n/**\n * 助詞の一覧\n */\nconst josiList = [\n    'について', 'くらい', 'なのか', 'までを', 'までの', 'による',\n    'とは', 'から', 'まで', 'だけ', 'より', 'ほど', 'など',\n    'いて', 'えて', 'きて', 'けて', 'して', 'って', 'にて', 'みて',\n    'めて', 'ねて', 'では', 'には', 'は~', 'んで', 'ずつ',\n    'は', 'を', 'に', 'へ', 'で', 'と', 'が', 'の'\n];\n// 「もし」文で使う助詞\nconst tararebaJosiList = [\n    'でなければ', 'なければ', 'ならば', 'なら', 'たら', 'れば'\n];\n// 意味のない助詞(削除する) #936 #939 #974\nconst removeJosiList = [\n    'こと', 'である', 'です', 'します', 'でした'\n];\n/**\n * 「もし」文で使う「たら」「れば」などの一覧をプログラムで扱いやすいようマップに変換したもの\n */\nconst tararebaMap = {};\ntararebaJosiList.forEach(josi => {\n    josiList.push(josi);\n    tararebaMap[josi] = true;\n});\n/**\n * 意味のない助詞(削除する)をマップに変換したもの\n */\nconst removeJosiMap = {};\nremoveJosiList.forEach(josi => {\n    josiList.push(josi);\n    removeJosiMap[josi] = true;\n});\n// 文字数の長い順に並び替え\njosiList.sort((a, b) => b.length - a.length);\n// 正規表現で助詞をマッチできるようにする\nconst josiRE = new RegExp('^[\\\\t ]*(' + josiList.join('|') + ')');\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_josi_list.mjs?")},"./core/src/nako_lex_rules.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rules\": function() { return /* binding */ rules; },\n/* harmony export */   \"trimOkurigana\": function() { return /* binding */ trimOkurigana; },\n/* harmony export */   \"unitRE\": function() { return /* binding */ unitRE; }\n/* harmony export */ });\n/* harmony import */ var _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_josi_list.mjs */ \"./core/src/nako_josi_list.mjs\");\n/**\n * なでしこ3字句解析のためのルール\n */\n\nconst kanakanji = /^[\\u3005\\u4E00-\\u9FCF_a-zA-Z0-9ァ-ヶー\\u2460-\\u24FF\\u2776-\\u277F\\u3251-\\u32BF]+/;\nconst hira = /^[ぁ-ん]/;\nconst allHiragana = /^[ぁ-ん]+$/;\nconst wordHasIjoIka = /^.+(以上|以下|超|未満)$/;\nconst errorRead = (ch) => {\n    return function () { throw new Error('突然の『' + ch + '』があります。'); };\n};\nconst unitRE = /^(円|ドル|元|歩|㎡|坪|度|℃|°|個|つ|本|冊|才|歳|匹|枚|皿|セット|羽|人|件|行|列|機|品|m|mm|cm|km|g|kg|t|px|dot|pt|em|b|mb|kb|gb)/;\nconst rules = [\n    // 上から順にマッチさせていく\n    { name: 'ここまで', pattern: /^;;;/ },\n    { name: 'eol', pattern: /^\\n/ },\n    { name: 'eol', pattern: /^;/ },\n    // eslint-disable-next-line no-control-regex\n    { name: 'space', pattern: /^(\\x20|\\x09|・)+/ },\n    { name: 'comma', pattern: /^,/ },\n    { name: 'line_comment', pattern: /^#[^\\n]*/ },\n    { name: 'line_comment', pattern: /^\\/\\/[^\\n]*/ },\n    { name: 'range_comment', pattern: /^\\/\\*/, cbParser: cbRangeComment },\n    { name: 'def_test', pattern: /^●テスト:/ },\n    { name: 'def_func', pattern: /^●/ },\n    // 数値の判定 --- この後nako_lexerにて単位を読む処理が入る(#994)\n    { name: 'number', pattern: /^0[xX][0-9a-fA-F]+(_[0-9a-fA-F]+)*/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^0[oO][0-7]+(_[0-7]+)*/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^0[bB][0-1]+(_[0-1]+)*/, readJosi: true, cb: parseNumber },\n    // 下の三つは小数点が挟まっている場合、小数点から始まっている場合、小数点がない場合の十進法の数値にマッチします\n    { name: 'number', pattern: /^\\d+(_\\d+)*\\.(\\d+(_\\d+)*)?([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^\\.\\d+(_\\d+)*([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'number', pattern: /^\\d+(_\\d+)*([eE][+|-]?\\d+(_\\d+)*)?/, readJosi: true, cb: parseNumber },\n    { name: 'ここから', pattern: /^(ここから),?/ },\n    { name: 'ここまで', pattern: /^(ここまで|💧)/ },\n    { name: 'もし', pattern: /^もしも?/ },\n    // 「ならば」は助詞として定義している\n    { name: '違えば', pattern: /^違(えば)?/ },\n    // 「回」「間」「繰返」「反復」「抜」「続」「戻」「代入」「条件分岐」などは NakoLexer._replaceWord で word から変換\n    // @see nako_reserved_words.js\n    { name: 'shift_r0', pattern: /^>>>/ },\n    { name: 'shift_r', pattern: /^>>/ },\n    { name: 'shift_l', pattern: /^<</ },\n    { name: '===', pattern: /^===/ },\n    { name: '!==', pattern: /^!==/ },\n    { name: 'gteq', pattern: /^(≧|>=|=>)/ },\n    { name: 'lteq', pattern: /^(≦|<=|=<)/ },\n    { name: 'noteq', pattern: /^(≠|<>|!=)/ },\n    { name: '←', pattern: /^(←|<--)/ },\n    { name: 'eq', pattern: /^(=|🟰)/ },\n    { name: 'line_comment', pattern: /^(!|💡)(インデント構文|ここまでだるい)[^\\n]*/ },\n    { name: 'not', pattern: /^(!|💡)/ },\n    { name: 'gt', pattern: /^>/ },\n    { name: 'lt', pattern: /^</ },\n    { name: 'and', pattern: /^(かつ|&&)/ },\n    { name: 'or', pattern: /^(または|或いは|あるいは|\\|\\|)/ },\n    { name: '@', pattern: /^@/ },\n    { name: '+', pattern: /^\\+/ },\n    { name: '-', pattern: /^-/ },\n    { name: '*', pattern: /^(×|\\*)/ },\n    { name: '÷÷', pattern: /^÷÷/ },\n    { name: '÷', pattern: /^(÷|\\/)/ },\n    { name: '%', pattern: /^%/ },\n    { name: '^', pattern: /^\\^/ },\n    { name: '&', pattern: /^&/ },\n    { name: '[', pattern: /^\\[/ },\n    { name: ']', pattern: /^]/, readJosi: true },\n    { name: '(', pattern: /^\\(/ },\n    { name: ')', pattern: /^\\)/, readJosi: true },\n    { name: '|', pattern: /^\\|/ },\n    { name: 'string', pattern: /^🌿/, cbParser: src => cbString('🌿', '🌿', src) },\n    { name: 'string_ex', pattern: /^🌴/, cbParser: src => cbString('🌴', '🌴', src) },\n    { name: 'string_ex', pattern: /^「/, cbParser: src => cbString('「', '」', src) },\n    { name: 'string', pattern: /^『/, cbParser: src => cbString('『', '』', src) },\n    { name: 'string_ex', pattern: /^“/, cbParser: src => cbString('“', '”', src) },\n    { name: 'string_ex', pattern: /^\"/, cbParser: src => cbString('\"', '\"', src) },\n    { name: 'string', pattern: /^'/, cbParser: src => cbString('\\'', '\\'', src) },\n    { name: '」', pattern: /^」/, cbParser: errorRead('」') },\n    { name: '』', pattern: /^』/, cbParser: errorRead('』') },\n    { name: 'func', pattern: /^\\{関数\\},?/ },\n    { name: '{', pattern: /^\\{/ },\n    { name: '}', pattern: /^\\}/, readJosi: true },\n    { name: ':', pattern: /^:/ },\n    { name: '_eol', pattern: /^_\\s*\\n/ },\n    { name: 'dec_lineno', pattern: /^‰/ },\n    // 絵文字変数 = (絵文字)英数字*\n    { name: 'word', pattern: /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF][_a-zA-Z0-9]*/, readJosi: true },\n    { name: 'word', pattern: /^[\\u1F60-\\u1F6F][_a-zA-Z0-9]*/, readJosi: true },\n    { name: 'word', pattern: /^《.+?》/, readJosi: true },\n    // 単語句\n    {\n        name: 'word',\n        pattern: /^[_a-zA-Z\\u3005\\u4E00-\\u9FCFぁ-んァ-ヶ\\u2460-\\u24FF\\u2776-\\u277F\\u3251-\\u32BF]/,\n        cbParser: cbWordParser\n    }\n];\nfunction trimOkurigana(s) {\n    // ひらがなから始まらない場合、送り仮名を削除。(例)置換する\n    if (!hira.test(s)) {\n        return s.replace(/[ぁ-ん]+/g, '');\n    }\n    // 全てひらがな？ (例) どうぞ\n    if (allHiragana.test(s)) {\n        return s;\n    }\n    // 末尾のひらがなのみ (例)お願いします →お願\n    return s.replace(/[ぁ-ん]+$/g, '');\n}\n// Utility for Rule\nfunction cbRangeComment(src) {\n    let res = '';\n    const josi = '';\n    let numEOL = 0;\n    src = src.substring(2); // skip /*\n    const i = src.indexOf('*/');\n    if (i < 0) { // not found\n        res = src;\n        src = '';\n    }\n    else {\n        res = src.substring(0, i);\n        src = src.substring(i + 2);\n    }\n    // 改行を数える\n    for (let i = 0; i < res.length; i++) {\n        if (res.charAt(i) === '\\n') {\n            numEOL++;\n        }\n    }\n    res = res.replace(/(^\\s+|\\s+$)/, ''); // trim\n    return { src, res, josi, numEOL };\n}\n/**\n * @param {string} src\n */\nfunction cbWordParser(src, isTrimOkurigana = true) {\n    /*\n      kanji    = [\\u3005\\u4E00-\\u9FCF]\n      hiragana = [ぁ-ん]\n      katakana = [ァ-ヶー]\n      emoji    = [\\u1F60-\\u1F6F]\n      uni_extra = [\\uD800-\\uDBFF] [\\uDC00-\\uDFFF]\n      alphabet = [_a-zA-Z]\n      numchars = [0-9]\n    */\n    let res = '';\n    let josi = '';\n    while (src !== '') {\n        if (res.length > 0) {\n            // 助詞の判定\n            const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.josiRE.exec(src);\n            if (j) {\n                josi = j[0].replace(/^\\s+/, '');\n                src = src.substr(j[0].length);\n                // 助詞の直後にある「,」を飛ばす #877\n                if (src.charAt(0) === ',') {\n                    src = src.substr(1);\n                }\n                break;\n            }\n        }\n        // カタカナ漢字英数字か？\n        const m = kanakanji.exec(src);\n        if (m) {\n            res += m[0];\n            src = src.substr(m[0].length);\n            continue;\n        }\n        // ひらがな？\n        const h = hira.test(src);\n        if (h) {\n            res += src.charAt(0);\n            src = src.substr(1);\n            continue;\n        }\n        break; // other chars\n    }\n    // 「間」の特殊ルール (#831)\n    // 「等しい間」や「一致する間」なら「間」をsrcに戻す。ただし「システム時間」はそのままにする。\n    if (/[ぁ-ん]間$/.test(res)) {\n        src = res.charAt(res.length - 1) + src;\n        res = res.slice(0, -1);\n    }\n    // 「以上」「以下」「超」「未満」 #918\n    const ii = wordHasIjoIka.exec(res);\n    if (ii) {\n        src = ii[1] + josi + src;\n        josi = '';\n        res = res.substr(0, res.length - ii[1].length);\n    }\n    // 助詞「こと」「である」「です」などは「＊＊すること」のように使うので削除 #936 #939 #974\n    if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.removeJosiMap[josi]) {\n        josi = '';\n    }\n    // 漢字カタカナ英語から始まる語句 --- 送り仮名を省略\n    if (isTrimOkurigana) {\n        res = trimOkurigana(res);\n    }\n    // 助詞だけの語句の場合\n    if (res === '' && josi !== '') {\n        res = josi;\n        josi = '';\n    }\n    return { src, res, josi, numEOL: 0 };\n}\nfunction cbString(beginTag, closeTag, src) {\n    let res = '';\n    let josi = '';\n    let numEOL = 0;\n    src = src.substr(beginTag.length); // skip beginTag\n    const i = src.indexOf(closeTag);\n    if (i < 0) { // not found\n        res = src;\n        src = '';\n    }\n    else {\n        res = src.substr(0, i);\n        src = src.substr(i + closeTag.length);\n        // res の中に beginTag があればエラーにする #953\n        if (res.indexOf(beginTag) >= 0) {\n            if (beginTag === '『') {\n                throw new Error('「『」で始めた文字列の中に「『」を含めることはできません。');\n            }\n            else {\n                throw new Error(`『${beginTag}』で始めた文字列の中に『${beginTag}』を含めることはできません。`);\n            }\n        }\n    }\n    // 文字列直後の助詞を取得\n    const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.josiRE.exec(src);\n    if (j) {\n        josi = j[0].replace(/^\\s+/, '');\n        src = src.substr(j[0].length);\n        // 助詞の後のカンマ #877\n        if (src.charAt(0) === ',') {\n            src = src.substr(1);\n        }\n    }\n    // 助詞「こと」「である」「です」などは「＊＊すること」のように使うので削除 #936 #939 #974\n    if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_0__.removeJosiMap[josi]) {\n        josi = '';\n    }\n    // 改行を数える\n    for (let i = 0; i < res.length; i++) {\n        if (res.charAt(i) === '\\n') {\n            numEOL++;\n        }\n    }\n    return { src, res, josi, numEOL };\n}\nfunction parseNumber(n) {\n    return Number(n.replace(/_/g, ''));\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_lex_rules.mjs?")},"./core/src/nako_lexer.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NakoLexer\": function() { return /* binding */ NakoLexer; }\n/* harmony export */ });\n/* harmony import */ var _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nako_parser_const.mjs */ \"./core/src/nako_parser_const.mjs\");\n/* harmony import */ var _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nako_reserved_words.mjs */ \"./core/src/nako_reserved_words.mjs\");\n/* harmony import */ var _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nako_josi_list.mjs */ \"./core/src/nako_josi_list.mjs\");\n/* harmony import */ var _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nako_lex_rules.mjs */ \"./core/src/nako_lex_rules.mjs\");\n/* harmony import */ var _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nako_errors.mjs */ \"./core/src/nako_errors.mjs\");\n// なでしこの字句解析を行う\n// 既に全角半角を揃えたコードに対して字句解析を行う\n\n// 予約語句\n// (memo)「回」「間」「繰返」「反復」「抜」「続」「戻」「代入」などは _replaceWord で word から変換\n/** @types {Record<string, string>} */\n\n// 助詞の一覧\n\n// 字句解析ルールの一覧\n\n\nclass NakoLexer {\n    /**\n     * @param logger\n     */\n    constructor(logger) {\n        this.logger = logger; // 字句解析した際,確認された関数の一覧\n        this.funclist = {};\n        this.modList = []; // 字句解析した際,取り込むモジュール一覧 --- nako3::lex で更新される\n        this.result = [];\n        this.modName = 'main.nako3'; // モジュール名\n    }\n    /** 関数一覧をセット */\n    setFuncList(listObj) {\n        this.funclist = listObj;\n    }\n    /**\n     * @param tokens\n     * @param {boolean} isFirst\n     * @param {string} filename\n     */\n    replaceTokens(tokens, isFirst, filename) {\n        this.result = tokens;\n        this.modName = NakoLexer.filenameToModName(filename);\n        // 関数の定義があれば funclist を更新\n        NakoLexer.preDefineFunc(tokens, this.logger, this.funclist);\n        this._replaceWord(this.result);\n        if (isFirst) {\n            if (this.result.length > 0) {\n                const eof = this.result[this.result.length - 1];\n                this.result.push({\n                    type: 'eol',\n                    line: eof.line,\n                    column: 0,\n                    file: eof.file,\n                    josi: '',\n                    value: '---',\n                    startOffset: eof.startOffset,\n                    endOffset: eof.endOffset,\n                    rawJosi: ''\n                }); // 改行\n                this.result.push({\n                    type: 'eof',\n                    line: eof.line,\n                    column: 0,\n                    file: eof.file,\n                    josi: '',\n                    value: '',\n                    startOffset: eof.startOffset,\n                    endOffset: eof.endOffset,\n                    rawJosi: ''\n                }); // ファイル末尾\n            }\n            else {\n                this.result.push({\n                    type: 'eol',\n                    line: 0,\n                    column: 0,\n                    file: '',\n                    josi: '',\n                    value: '---',\n                    startOffset: 0,\n                    endOffset: 0,\n                    rawJosi: ''\n                }); // 改行\n                this.result.push({\n                    type: 'eof',\n                    line: 0,\n                    column: 0,\n                    file: '',\n                    josi: '',\n                    value: '',\n                    startOffset: 0,\n                    endOffset: 0,\n                    rawJosi: ''\n                }); // ファイル末尾\n            }\n        }\n        return this.result;\n    }\n    /**\n     * ファイル内で定義されている関数名を列挙する。結果はfunclistに書き込む。その他のトークンの置換処理も行う。\n     * シンタックスハイライトの処理から呼び出すためにstaticメソッドにしている。\n     * @param {Token[]} tokens\n     * @param {import('./nako_logger.mjs').NakoLogger} logger\n     * @param {FuncList} funclist\n     */\n    static preDefineFunc(tokens, logger, funclist) {\n        // 関数を先読みして定義\n        let i = 0;\n        let isFuncPointer = false;\n        const readArgs = () => {\n            const args = [];\n            const keys = {};\n            if (tokens[i].type !== '(') {\n                return [];\n            }\n            i++;\n            while (tokens[i]) {\n                const t = tokens[i];\n                i++;\n                if (t.type === ')') {\n                    break;\n                }\n                if (t.type === 'func') {\n                    isFuncPointer = true;\n                }\n                else if (t.type !== '|' && t.type !== 'comma') {\n                    if (isFuncPointer) {\n                        t.funcPointer = true;\n                        isFuncPointer = false;\n                    }\n                    args.push(t);\n                    if (!keys[t.value]) {\n                        keys[t.value] = [];\n                    }\n                    keys[t.value].push(t.josi);\n                }\n            }\n            const varnames = [];\n            const funcPointers = [];\n            const result = [];\n            const already = {};\n            for (const arg of args) {\n                if (!already[arg.value]) {\n                    const josi = keys[arg.value];\n                    result.push(josi);\n                    varnames.push(arg.value);\n                    if (arg.funcPointer) {\n                        funcPointers.push(arg.value);\n                    }\n                    else {\n                        funcPointers.push(null);\n                    }\n                    already[arg.value] = true;\n                }\n            }\n            return [result, varnames, funcPointers];\n        };\n        // トークンを一つずつ確認\n        while (i < tokens.length) {\n            // タイプの置換\n            const t = tokens[i];\n            // 無名関数の定義：「xxには**」があった場合 ... 暗黙的な関数定義とする\n            if ((t.type === 'word' && t.josi === 'には') || (t.type === 'word' && t.josi === 'は~')) {\n                t.josi = 'には';\n                tokens.splice(i + 1, 0, { type: 'def_func', value: '関数', line: t.line, column: t.column, file: t.file, josi: '', startOffset: t.endOffset, endOffset: t.endOffset, rawJosi: '', tag: '無名関数' });\n                i++;\n                continue;\n            }\n            // N回をN|回に置換\n            if (t.type === 'word' && t.josi === '' && t.value.length >= 2) {\n                if (t.value.match(/回$/)) {\n                    t.value = t.value.substring(0, t.value.length - 1);\n                    // N回を挿入\n                    if (!t.endOffset) {\n                        t.endOffset = 1;\n                    }\n                    const kai = { type: '回', value: '回', line: t.line, column: t.column, file: t.file, josi: '', startOffset: t.endOffset - 1, endOffset: t.endOffset, rawJosi: '' };\n                    tokens.splice(i + 1, 0, kai);\n                    t.endOffset--;\n                    i++;\n                }\n            }\n            // 予約語の置換\n            if (t.type === 'word' && _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"][t.value]) {\n                t.type = _nako_reserved_words_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"][t.value];\n                if (t.value === 'そう') {\n                    t.value = 'それ';\n                }\n            }\n            // 関数定義の確認\n            if (t.type !== 'def_test' && t.type !== 'def_func') {\n                i++;\n                continue;\n            }\n            // 無名関数か普通関数定義かを判定する (1つ前が改行かどうかで判定)\n            let isMumei = true;\n            let prevToken = { type: 'eol' };\n            if (i >= 1) {\n                prevToken = tokens[i - 1];\n            }\n            if (prevToken.type === 'eol') {\n                isMumei = false;\n            }\n            // 関数名や引数を得る\n            const defToken = t;\n            i++; // skip \"●\" or \"関数\"\n            let josi = [];\n            let varnames = [];\n            let funcPointers = [];\n            let funcName = '';\n            let funcNameToken = null;\n            // 関数名の前に引数定義\n            if (tokens[i] && tokens[i].type === '(') {\n                [josi, varnames, funcPointers] = readArgs();\n            }\n            // 関数名を得る\n            if (!isMumei && tokens[i] && tokens[i].type === 'word') {\n                funcNameToken = tokens[i++];\n                funcName = funcNameToken.value;\n            }\n            // 関数名の後で引数定義\n            if (josi.length === 0 && tokens[i] && tokens[i].type === '(') {\n                [josi, varnames, funcPointers] = readArgs();\n            }\n            // 名前のある関数定義ならば関数テーブルに関数名を登録\n            // 無名関数は登録しないように気をつける\n            if (funcName !== '' && funcNameToken) {\n                const modName = NakoLexer.filenameToModName(t.file);\n                funcName = modName + '__' + funcName;\n                if (funcName in funclist) { // 関数の二重定義を警告\n                    // main__は省略 #1223\n                    const dispName = funcName.replace(/^main__/, '');\n                    logger.warn(`関数『${dispName}』は既に定義されています。`, defToken);\n                }\n                funcNameToken.value = funcName;\n                funclist[funcName] = {\n                    type: 'func',\n                    josi,\n                    fn: null,\n                    asyncFn: false,\n                    varnames,\n                    funcPointers\n                };\n            }\n            // 無名関数のために\n            defToken.meta = {\n                type: 'func',\n                josi,\n                varnames,\n                funcPointers\n            };\n        }\n    }\n    /** 文字列を{と}の部分で分割する。中括弧が対応していない場合nullを返す。 */\n    splitStringEx(code) {\n        /** @type {string[]} */\n        const list = [];\n        // \"A{B}C{D}E\" -> [\"A\", \"B}C\", \"D}E\"] -> [\"A\", \"B\", \"C\", \"D\", \"E\"]\n        // \"A{B}C}D{E}F\" -> [\"A\", \"B}C}D\", \"E}F\"] -> [\"A\", \"B\", \"C}D\", \"E\", \"F\"]\n        const arr = code.split(/[{｛]/);\n        list.push(arr[0]);\n        for (const s of arr.slice(1)) {\n            const end = s.replace('｝', '}').indexOf('}');\n            if (end === -1) {\n                return null;\n            }\n            list.push(s.slice(0, end), s.slice(end + 1));\n        }\n        return list;\n    }\n    _replaceWord(tokens) {\n        let comment = [];\n        let i = 0;\n        const getLastType = () => {\n            if (i <= 0) {\n                return 'eol';\n            }\n            return tokens[i - 1].type;\n        };\n        const modSelf = (tokens.length > 0) ? NakoLexer.filenameToModName(tokens[0].file) : 'main.nako3';\n        while (i < tokens.length) {\n            const t = tokens[i];\n            // 関数を強制的に置換( word => func )\n            if (t.type === 'word' && t.value !== 'それ') {\n                // 関数を変換\n                const funcName = t.value;\n                if (funcName.indexOf('__') < 0) {\n                    // 自身のモジュール名を検索\n                    const gname1 = `${modSelf}__${funcName}`;\n                    const gfo1 = this.funclist[gname1];\n                    if (gfo1 && gfo1.type === 'func') {\n                        t.type = 'func';\n                        t.meta = gfo1;\n                        t.value = gname1;\n                        continue;\n                    }\n                    // モジュール関数を置換\n                    for (const mod of this.modList) {\n                        const gname = `${mod}__${funcName}`;\n                        const gfo = this.funclist[gname];\n                        if (gfo && gfo.type === 'func') {\n                            t.type = 'func';\n                            t.meta = gfo;\n                            t.value = gname;\n                            break;\n                        }\n                    }\n                    if (t.type === 'func') {\n                        continue;\n                    }\n                }\n                const fo = this.funclist[funcName];\n                if (fo && fo.type === 'func') {\n                    t.type = 'func';\n                    t.meta = fo;\n                }\n            }\n            // 数字につくマイナス記号を判定\n            // (ng) 5 - 3 || word - 3\n            // (ok) (行頭)-3 || 1 * -3 || Aに -3を 足す\n            if (t.type === '-' && tokens[i + 1] && tokens[i + 1].type === 'number') {\n                // 一つ前の語句が、(行頭|演算子|助詞付きの語句)なら 負数である\n                const ltype = getLastType();\n                if (ltype === 'eol' || _nako_parser_const_mjs__WEBPACK_IMPORTED_MODULE_0__.opPriority[ltype] || tokens[i - 1].josi !== '') {\n                    tokens.splice(i, 1); // remove '-'\n                    tokens[i].value *= -1;\n                }\n            }\n            // 助詞の「は」を = に展開\n            if (t.josi === undefined) {\n                t.josi = '';\n            }\n            if (t.josi === 'は') {\n                if (!t.rawJosi) {\n                    t.rawJosi = t.josi;\n                }\n                const startOffset = (t.endOffset === undefined) ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: 'eq',\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: '',\n                    value: undefined\n                });\n                i += 2;\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                continue;\n            }\n            // 「とは」を一つの単語にする\n            if (t.josi === 'とは') {\n                if (!t.rawJosi) {\n                    t.rawJosi = t.josi;\n                }\n                const startOffset = t.endOffset === undefined ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: t.josi,\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: '',\n                    value: undefined\n                });\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                i += 2;\n                continue;\n            }\n            // 助詞のならばをトークンとする\n            if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.tararebaMap[t.josi]) {\n                const josi = (t.josi === 'でなければ' || t.josi === 'なければ') ? 'でなければ' : 'ならば';\n                if (!t.rawJosi) {\n                    t.rawJosi = josi;\n                }\n                const startOffset = t.endOffset === undefined ? undefined : t.endOffset - t.rawJosi.length;\n                tokens.splice(i + 1, 0, {\n                    type: 'ならば',\n                    value: josi,\n                    line: t.line,\n                    column: t.column,\n                    file: t.file,\n                    startOffset,\n                    endOffset: t.endOffset,\n                    josi: '',\n                    rawJosi: ''\n                });\n                t.josi = t.rawJosi = '';\n                t.endOffset = startOffset;\n                i += 2;\n                continue;\n            }\n            // '_' + 改行 を飛ばす (演算子直後に改行を入れたい場合に使う)\n            if (t.type === '_eol') {\n                tokens.splice(i, 1);\n                continue;\n            }\n            // コメントを飛ばす\n            if (t.type === 'line_comment' || t.type === 'range_comment') {\n                comment.push(t.value);\n                tokens.splice(i, 1);\n                continue;\n            }\n            // 改行にコメントを埋め込む\n            if (t.type === 'eol') {\n                t.value = comment.join('/');\n                comment = [];\n            }\n            i++;\n        }\n    }\n    /**\n     * @param {string} src\n     * @param {number} line\n     * @param {string} filename\n     * @returns {Token[]}\n     */\n    tokenize(src, line, filename) {\n        const srcLength = src.length;\n        const result = [];\n        let columnCurrent;\n        let lineCurrent;\n        let column = 1;\n        let isDefTest = false;\n        while (src !== '') {\n            let ok = false;\n            // 各ルールについて\n            for (const rule of _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__.rules) {\n                // 正規表現でマッチ\n                const m = rule.pattern.exec(src);\n                if (!m) {\n                    continue;\n                }\n                ok = true;\n                // 空白ならスキップ\n                if (rule.name === 'space') {\n                    column += m[0].length;\n                    src = src.substring(m[0].length);\n                    continue;\n                }\n                // マッチしたルールがコールバックを持つなら\n                if (rule.cbParser) {\n                    // コールバックを呼ぶ\n                    /** @type {{ src: string, res: string, josi: string, numEOL: number }} */\n                    let rp;\n                    if (isDefTest && rule.name === 'word') {\n                        rp = rule.cbParser(src, false);\n                    }\n                    else {\n                        try {\n                            rp = rule.cbParser(src);\n                        }\n                        catch (e) {\n                            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.NakoLexerError(e.message, srcLength - src.length, srcLength - src.length + 1, line, filename);\n                        }\n                    }\n                    if (rule.name === 'string_ex') {\n                        // 展開あり文字列 → aaa{x}bbb{x}cccc\n                        const list = this.splitStringEx(rp.res);\n                        if (list === null) {\n                            throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.InternalLexerError('展開あり文字列で値の埋め込み{...}が対応していません。', srcLength - src.length, srcLength - rp.src.length, line, filename);\n                        }\n                        let offset = 0;\n                        for (let i = 0; i < list.length; i++) {\n                            const josi = (i === list.length - 1) ? rp.josi : '';\n                            if (i % 2 === 0) {\n                                result.push({\n                                    type: 'string',\n                                    value: list[i],\n                                    file: filename,\n                                    josi,\n                                    line,\n                                    column,\n                                    preprocessedCodeOffset: srcLength - src.length + offset,\n                                    preprocessedCodeLength: list[i].length + 2 + josi.length\n                                });\n                                // 先頭なら'\"...{'、それ以外なら'}...{'、最後は何でも良い\n                                offset += list[i].length + 2;\n                            }\n                            else {\n                                result.push({ type: '&', value: '&', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: 0 });\n                                result.push({ type: '(', value: '(', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: 0 });\n                                result.push({ type: 'code', value: list[i], josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset, preprocessedCodeLength: list[i].length });\n                                result.push({ type: ')', value: ')', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset + list[i].length, preprocessedCodeLength: 0 });\n                                result.push({ type: '&', value: '&', josi: '', file: filename, line, column, preprocessedCodeOffset: srcLength - src.length + offset + list[i].length, preprocessedCodeLength: 0 });\n                                offset += list[i].length;\n                            }\n                        }\n                        line += rp.numEOL;\n                        column += src.length - rp.src.length;\n                        src = rp.src;\n                        if (rp.numEOL > 0) {\n                            column = 1;\n                        }\n                        break;\n                    }\n                    columnCurrent = column;\n                    column += src.length - rp.src.length;\n                    result.push({ type: rule.name, value: rp.res, josi: rp.josi, line, column: columnCurrent, file: filename, preprocessedCodeOffset: srcLength - src.length, preprocessedCodeLength: src.length - rp.src.length });\n                    src = rp.src;\n                    line += rp.numEOL;\n                    if (rp.numEOL > 0) {\n                        column = 1;\n                    }\n                    break;\n                }\n                // ソースを進める前に位置を計算\n                const srcOffset = srcLength - src.length;\n                // 値を変換する必要があるか？\n                let value = m[0];\n                if (rule.cb) {\n                    value = rule.cb(value);\n                }\n                // ソースを進める\n                columnCurrent = column;\n                lineCurrent = line;\n                column += m[0].length;\n                src = src.substring(m[0].length);\n                if ((rule.name === 'eol' && value === '\\n') || rule.name === '_eol') {\n                    value = line++;\n                    column = 1;\n                }\n                // 数値なら単位を持つか？ --- #994\n                if (rule.name === 'number') {\n                    // 単位があれば読み飛ばす\n                    const um = _nako_lex_rules_mjs__WEBPACK_IMPORTED_MODULE_3__.unitRE.exec(src);\n                    if (um) {\n                        src = src.substring(um[0].length);\n                        column += m[0].length;\n                    }\n                }\n                let josi = '';\n                if (rule.readJosi) {\n                    const j = _nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.josiRE.exec(src);\n                    if (j) {\n                        josi = j[0].replace(/^\\s+/, '');\n                        column += j[0].length;\n                        src = src.substring(j[0].length);\n                        // 助詞の直後にあるカンマを無視 #877\n                        if (src.charAt(0) === ',') {\n                            src = src.substring(1);\n                        }\n                        // 「＊＊である」なら削除 #939 #974\n                        if (_nako_josi_list_mjs__WEBPACK_IMPORTED_MODULE_2__.removeJosiMap[josi]) {\n                            josi = '';\n                        }\n                    }\n                }\n                switch (rule.name) {\n                    case 'def_test': {\n                        isDefTest = true;\n                        break;\n                    }\n                    case 'eol': {\n                        isDefTest = false;\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n                // ここまで‰(#682) を処理\n                if (rule.name === 'dec_lineno') {\n                    line--;\n                    continue;\n                }\n                result.push({\n                    type: rule.name,\n                    value,\n                    line: lineCurrent,\n                    column: columnCurrent,\n                    file: filename,\n                    josi,\n                    preprocessedCodeOffset: srcOffset,\n                    preprocessedCodeLength: (srcLength - src.length) - srcOffset\n                });\n                break;\n            }\n            if (!ok) {\n                throw new _nako_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.InternalLexerError('未知の語句: ' + src.substring(0, 3) + '...', srcLength - src.length, srcLength - srcLength + 3, line, filename);\n            }\n        }\n        return result;\n    }\n    // トークン配列をtype文字列に変換\n    static tokensToTypeStr(tokens, sep) {\n        const a = tokens.map((v) => {\n            return v.type;\n        });\n        return a.join(sep);\n    }\n    /**\n     * ファイル名からモジュール名へ変換\n     * @param {string} filename\n     * @returns {string}\n     */\n    static filenameToModName(filename) {\n        if (!filename) {\n            return 'main';\n        }\n        // パスがあればパスを削除\n        filename = filename.replace(/[\\\\:]/g, '/'); // Windowsのpath記号を/に置換\n        if (filename.indexOf('/') >= 0) {\n            const a = filename.split('/');\n            filename = a[a.length - 1];\n        }\n        filename = filename.replace(/\\.nako3?$/, '');\n        return filename;\n    }\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_lexer.mjs?")},"./core/src/nako_parser_const.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"keizokuJosi\": function() { return /* binding */ keizokuJosi; },\n/* harmony export */   \"opPriority\": function() { return /* binding */ opPriority; },\n/* harmony export */   \"operatorList\": function() { return /* binding */ operatorList; }\n/* harmony export */ });\n/* eslint-disable quote-props */\nconst opPriority = {\n    // and or\n    'and': 1,\n    'or': 1,\n    // compare\n    'eq': 2,\n    'noteq': 2,\n    '===': 2,\n    '!==': 2,\n    'gt': 2,\n    'gteq': 2,\n    'lt': 2,\n    'lteq': 2,\n    '&': 3,\n    // + - << >> >>>\n    '+': 4,\n    '-': 4,\n    'shift_l': 4,\n    'shift_r': 4,\n    'shift_r0': 4,\n    // * /\n    '*': 5,\n    '/': 5,\n    '÷': 5,\n    '÷÷': 5,\n    '%': 5,\n    // ^\n    '^': 6\n};\nconst keizokuJosi = [\n    'いて', 'えて', 'きて', 'けて', 'して', 'って', 'にて', 'みて', 'めて', 'ねて', 'には', 'んで'\n];\nconst operatorList = [];\nfor (const key in opPriority) {\n    operatorList.push(key);\n}\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_parser_const.mjs?")},"./core/src/nako_reserved_words.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/** 予約語 */\nconst reserved = {\n    '回': '回',\n    '回繰返': '回',\n    '間': '間',\n    '間繰返': '間',\n    '繰返': '繰返',\n    '増繰返': '増繰返',\n    '減繰返': '減繰返',\n    '後判定': '後判定',\n    '反復': '反復',\n    '抜': '抜ける',\n    '続': '続ける',\n    '戻': '戻る',\n    '先': '先に',\n    '次': '次に',\n    '代入': '代入',\n    '実行速度優先': '実行速度優先',\n    'パフォーマンスモニタ適用': 'パフォーマンスモニタ適用',\n    '定': '定める',\n    '逐次実行': '逐次実行',\n    '条件分岐': '条件分岐',\n    '増': '増',\n    '減': '減',\n    '変数': '変数',\n    '定数': '定数',\n    'エラー監視': 'エラー監視',\n    'エラー': 'エラー',\n    'それ': 'word',\n    'そう': 'word',\n    '関数': 'def_func',\n    'インデント構文': 'インデント構文',\n    '非同期モード': '非同期モード',\n    'DNCLモード': 'DNCLモード',\n    'モード設定': 'モード設定',\n    '取込': '取込'\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (reserved);\n\n\n//# sourceURL=webpack://nadesiko3/./core/src/nako_reserved_words.mjs?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var s=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](s,s.exports,__webpack_require__),s.exports}__webpack_require__.d=function(n,e){for(var s in e)__webpack_require__.o(e,s)&&!__webpack_require__.o(n,s)&&Object.defineProperty(n,s,{enumerable:!0,get:e[s]})},__webpack_require__.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},__webpack_require__.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./core/src/nako_gen_async.mjs")})();